//@author: a0100927m



	/**
	 * origin: D:\CS2103 Proj\src\ColourPalette.java
	 */

/**
 * 
 * This class provides static colours for the GUI in View.
 * 
 */
public class ColourPalette {
	
	/********************************* Colours for javafx **************************************/
	public static final Color fxWHITE = Color.WHITE;
	public static final Color fxNEAR_WHITE = Color.rgb(250, 250, 250);
	public static final Color occurrenceColour = Color.rgb(42, 186, 143);
			
	public static final Color[] defaultScheme = {Color.rgb(130, 255, 121), 
		fxWHITE, Color.rgb(18, 235, 166), Color.rgb(92, 190, 247), 
			Color.RED, Color.ORANGE, Color.ORCHID};
	public static final Color[] defaultNightScheme = {Color.rgb(89, 213, 100), 
		fxWHITE, Color.rgb(18, 235, 166), Color.rgb(92, 190, 247), 
			Color.RED, Color.ORANGE, Color.ORCHID};
	public static final Color[] goldfishScheme = {Color.rgb(250, 105, 0), 
		Color.WHITE, Color.rgb(224, 228, 204), Color.rgb(167, 219, 216), 
			Color.rgb(105, 210, 231),Color.rgb(105, 169, 231), 
				Color.rgb(243, 134, 48)};
	public static final Color[] brightScheme = {Color.rgb(250, 105, 0), fxWHITE, 
		Color.rgb(247, 196, 31), Color.rgb(224, 224, 90), Color.rgb(204, 243, 144), 
			Color.rgb(152, 242, 140), Color.rgb(252, 147, 10)};
	
	/******************************* Colours for javaswing ************************************/
	public static final StyleContext cont = StyleContext.getDefaultStyleContext();
	
	public static final java.awt.Color WHITE = java.awt.Color.white;
	public static final java.awt.Color BLACK = java.awt.Color.black;
	public static final java.awt.Color caretColour = new java.awt.Color(0, 0, 0, 0);
	public static final java.awt.Color cmdBackgroundColour = new java.awt.Color(50, 50, 50);
	
	public static final AttributeSet attrRed = cont.addAttribute(cont.getEmptySet(),
			StyleConstants.Foreground, new java.awt.Color(255, 41, 41));
	public static final AttributeSet attrBlue = cont.addAttribute(cont.getEmptySet(),
			StyleConstants.Foreground, new java.awt.Color(84, 173, 225));
	public static final AttributeSet attrDarkCyan = cont.addAttribute(cont.getEmptySet(),
			StyleConstants.Foreground, new java.awt.Color(44, 62, 80));
	public static final AttributeSet attrDarkBlue = cont.addAttribute(cont.getEmptySet(),
			StyleConstants.Foreground, new java.awt.Color(5, 82, 199));
	public static final AttributeSet attrOrange = cont.addAttribute(cont.getEmptySet(),
			StyleConstants.Foreground, new java.awt.Color(255, 165, 0));
	public static final AttributeSet attrGreen = cont.addAttribute(cont.getEmptySet(),
			StyleConstants.Foreground, new java.awt.Color(39, 174, 96));
	public static final AttributeSet attrCyan = cont.addAttribute(cont.getEmptySet(),
			StyleConstants.Foreground, new java.awt.Color(16, 217, 153));
	public static final AttributeSet attrGray = cont.addAttribute(cont.getEmptySet(),
			StyleConstants.Foreground, new java.awt.Color(189, 195, 199));
	public static final AttributeSet attrMagenta = cont.addAttribute(cont.getEmptySet(),
			StyleConstants.Foreground, new java.awt.Color(155, 89, 182));
	public static final AttributeSet attrRedNight = cont.addAttribute(cont.getEmptySet(),
			StyleConstants.Foreground, new java.awt.Color(247, 139, 139));
	public static final AttributeSet attrBlueNight = cont.addAttribute(cont.getEmptySet(),
			StyleConstants.Foreground, new java.awt.Color(110, 242, 243));
	public static final AttributeSet attrWhiteNight = cont.addAttribute(cont.getEmptySet(),
			StyleConstants.Foreground, new java.awt.Color(252, 252, 252));
	public static final AttributeSet attrDarkBlueNight = cont.addAttribute(cont.getEmptySet(),
			StyleConstants.Foreground, new java.awt.Color(66, 185, 254));
	public static final AttributeSet attrOrangeNight = cont.addAttribute(cont.getEmptySet(),
			StyleConstants.Foreground, new java.awt.Color(254, 186, 63));
	public static final AttributeSet attrGreenNight = cont.addAttribute(cont.getEmptySet(),
			StyleConstants.Foreground, new java.awt.Color(108, 248, 134));
	public static final AttributeSet attrCyanNight = cont.addAttribute(cont.getEmptySet(),
			StyleConstants.Foreground, new java.awt.Color(63, 248, 189));
	public static final AttributeSet grayNight = cont.addAttribute(cont.getEmptySet(),
			StyleConstants.Foreground, new java.awt.Color(220, 220, 220));
	public static final AttributeSet attrMagentaNight = cont.addAttribute(cont.getEmptySet(),
			StyleConstants.Foreground, new java.awt.Color(238, 152, 233));
	public static final AttributeSet orangeGF = cont.addAttribute(cont.getEmptySet(),
			StyleConstants.Foreground, new java.awt.Color(250, 105, 0));
	public static final AttributeSet lightOrangeGF = cont.addAttribute(cont.getEmptySet(),
			StyleConstants.Foreground, new java.awt.Color(243, 134, 48));
	public static final AttributeSet beachGF = cont.addAttribute(cont.getEmptySet(),
			StyleConstants.Foreground, new java.awt.Color(194, 202, 154));
	public static final AttributeSet paleBlueGF = cont.addAttribute(cont.getEmptySet(),
			StyleConstants.Foreground, new java.awt.Color(167, 219, 216));
	public static final AttributeSet darkBlueGF = cont.addAttribute(cont.getEmptySet(),
			StyleConstants.Foreground, new java.awt.Color(105, 169, 231));
	public static final AttributeSet blueGF = cont.addAttribute(cont.getEmptySet(),
			StyleConstants.Foreground, new java.awt.Color(105,210,231));
	public static final AttributeSet purpleGF = cont.addAttribute(cont.getEmptySet(),
			StyleConstants.Foreground, new java.awt.Color(105, 106, 231));
	public static final AttributeSet greyGF = cont.addAttribute(cont.getEmptySet(),
			StyleConstants.Foreground, new java.awt.Color(143, 143, 143));
	public static final AttributeSet redBright = cont.addAttribute(cont.getEmptySet(),
			StyleConstants.Foreground, new java.awt.Color(255, 0, 61));
	public static final AttributeSet orangeBright = cont.addAttribute(cont.getEmptySet(),
			StyleConstants.Foreground, new java.awt.Color(252, 147, 10));
	public static final AttributeSet yellowBright = cont.addAttribute(cont.getEmptySet(),
			StyleConstants.Foreground, new java.awt.Color(247, 196, 31));
	public static final AttributeSet paleYellowBright = cont.addAttribute(cont.getEmptySet(),
			StyleConstants.Foreground, new java.awt.Color(224, 224, 90));
	public static final AttributeSet paleGreenBright = cont.addAttribute(cont.getEmptySet(),
			StyleConstants.Foreground, new java.awt.Color(204, 243, 144));
	public static final AttributeSet greenBright = cont.addAttribute(cont.getEmptySet(),
			StyleConstants.Foreground, new java.awt.Color(152, 242, 140));
	public static final AttributeSet blueBright = cont.addAttribute(cont.getEmptySet(),
			StyleConstants.Foreground, new java.awt.Color(196, 216, 248));
	public static final AttributeSet pinkBright = cont.addAttribute(cont.getEmptySet(),
			StyleConstants.Foreground, new java.awt.Color(254, 203, 200));
	
	/******************************* Colour sets for javaswing ********************************/
	public static final AttributeSet[] defaultDaySchemeSwing = {attrGray, attrGreen, attrDarkCyan, 
		attrOrange, attrCyan, attrBlue, attrRed, attrDarkBlue, attrMagenta};
	public static final AttributeSet[] defaultNightSchemeSwing = {grayNight, attrGreenNight, 
		attrWhiteNight, attrOrangeNight, attrCyanNight, attrBlueNight, attrRedNight, attrDarkBlueNight,
		attrMagentaNight};
	public static final AttributeSet[] goldfishSchemeSwing = {attrGray, orangeGF, greyGF,
		darkBlueGF, beachGF, paleBlueGF, blueGF, purpleGF, lightOrangeGF};	
	public static final AttributeSet[] brightSchemeSwing = {grayNight, redBright, pinkBright,
		greenBright, yellowBright, paleYellowBright, paleGreenBright, blueBright, orangeBright};
	
}

	// End of segment: D:\CS2103 Proj\src\ColourPalette.java





	/**
	 * origin: D:\CS2103 Proj\src\Command.java
	 */

	/**
	 * Undo the ADD command
	 */
	public String undo() {
		int index = model.getIndexFromPending(createdTask);
		model.removeTaskFromPendingNoTrash(index);
		assert model.getTaskFromPending(index).equals(createdTask);
		return Common.MESSAGE_SUCCESSFUL_UNDO;
	}
	
	// End of segment: D:\CS2103 Proj\src\Command.java





	/**
	 * origin: D:\CS2103 Proj\src\Command.java
	 */

	/**
	 * Memorize the initial state of the edited task
	 */
	private void setOriginalTask() {
		originalTask = new Task();
		originalTask.setIsImportant(editedTask.isImportantTask());
		originalTask.setStartDate(editedTask.getStartDate());
		originalTask.setEndDate(editedTask.getEndDate());
		originalTask.setStartDateString(editedTask.getStartDateString());
		originalTask.setEndDateString(editedTask.getEndDateString());
		originalTask.setWorkInfo(editedTask.getWorkInfo());
		originalTask.setTag(editedTask.getTag());
		originalTask.setIndexId(editedTask.getIndexId());
		originalTask.setLatestModifiedDate(editedTask.getLatestModifiedDate());
		originalTask.setOccurrence(editedTask.getNumOccurrences(), editedTask.getCurrentOccurrence());
	}
	
	/**
	 * Memorize the aimed state of the edited task
	 */
	private void setTargetTask(){
		targetTask = new Task();
		targetTask.setIsImportant(editedTask.isImportantTask());
		targetTask.setStartDate(editedTask.getStartDate());
		targetTask.setEndDate(editedTask.getEndDate());
		targetTask.setStartDateString(editedTask.getStartDateString());
		targetTask.setEndDateString(editedTask.getEndDateString());
		targetTask.setWorkInfo(editedTask.getWorkInfo());
		targetTask.setTag(editedTask.getTag());
		targetTask.setIndexId(editedTask.getIndexId());
		targetTask.setLatestModifiedDate(editedTask.getLatestModifiedDate());
		targetTask.setOccurrence(editedTask.getNumOccurrences(), editedTask.getCurrentOccurrence());
	}
	
	// End of segment: D:\CS2103 Proj\src\Command.java





	/**
	 * origin: D:\CS2103 Proj\src\Command.java
	 */

	/**
	 * Undo EDIT command
	 */
	public String undo() {
		editedTask.setIsImportant(originalTask.isImportantTask());
		editedTask.setStartDate(originalTask.getStartDate());
		editedTask.setEndDate(originalTask.getEndDate());
		editedTask.setStartDateString(originalTask.getStartDateString());
		editedTask.setEndDateString(originalTask.getEndDateString());
		editedTask.setWorkInfo(originalTask.getWorkInfo());
		editedTask.setTag(originalTask.getTag());
		editedTask.setIndexId(originalTask.getIndexId());
		editedTask.setLatestModifiedDate(originalTask.getLatestModifiedDate());
		editedTask.setOccurrence(originalTask.getNumOccurrences(), originalTask.getCurrentOccurrence());
		editedTask.updateLatestModifiedDate();
		Common.sortList(modifiedList);

		return Common.MESSAGE_SUCCESSFUL_UNDO;
	}
	
	// End of segment: D:\CS2103 Proj\src\Command.java





	/**
	 * origin: D:\CS2103 Proj\src\Command.java
	 */

	/**
	 * Undo the REMOVE command
	 */
	public String undo() {
		for (int i = 0; i < removedTaskInfo.size(); i++) {
			Task removedTask = removedTaskInfo.get(i);
			reverseStatus(removedTask);
			modifiedList.add(removedTask);
			removeTaskFromTrash(i);
		}
		
		removedTaskInfo.clear();
		Common.sortList(modifiedList);

		return Common.MESSAGE_SUCCESSFUL_UNDO;
	}

	private void removeTaskFromTrash(int i) {
		if (isPendingTab() || isCompleteTab()) {
			int index = model.getIndexFromTrash(removedTaskInfo.get(i));
			model.removeTask(index, Common.TRASH_TAB);
		}
	}
	
	// End of segment: D:\CS2103 Proj\src\Command.java





	/**
	 * origin: D:\CS2103 Proj\src\Command.java
	 */

/**
 * 
 * Class ClearAllCommand. This class executes command to clear all tasks in a list.
 * 
 */
class ClearAllCommand extends IndexCommand {
	// List of tasks which will be cleared
	private Task[] clearedTasks;
	// List of original tasks in trash
	private Task[] originalTrashTasks;
	
	/**
	 * Constructor
	 * 
	 * @param model
	 *            model of tasks in the application
	 * @param tabIndex
	 *            the current tab
	 */
	public ClearAllCommand(Model model, int tabIndex) {
		super(model, tabIndex);
	}
	
	/**
	 * Execute the CLEAR command
	 */
	public String execute() {
		setOriginalTasksInTrash();
		setModifiedList();
		processClear();
		return Common.MESSAGE_SUCCESSFUL_CLEAR_ALL;
	}
	
	/**
	 * This function determine which will be the modified list for this command
	 */
	private void setModifiedList() {
		if (isSearchedResults()) {
			modifiedList = getSearchList(tabIndex);
		} else {
			modifiedList = getModifiedList(tabIndex);
		}
	}
	
	/**
	 * This function saves the original state list of tasks in trash list
	 */
	private void setOriginalTasksInTrash() {
		originalTrashTasks = new Task[model.getTrashList().size()];
		for (int i = 0; i < model.getTrashList().size(); i++) {
			originalTrashTasks[i] = model.getTaskFromTrash(i);
		}
	}

	/**
	 * This is the main function for the clearing process
	 */
	private void processClear(){
		clearedTasks = new Task[modifiedList.size()];
		for (int i = modifiedList.size() - 1; i >= 0; i--) {
			if (isPendingTab()) {
				clearedTasks[i] = model.getTaskFromPending(convertIndex(i));
				modifyStatus(clearedTasks[i]);
			} else if (isCompleteTab()) {
				clearedTasks[i] = model.getTaskFromComplete(convertIndex(i));
			}
			model.removeTask(convertIndex(i), tabIndex);
		}
		
		if (isPendingTab() || isCompleteTab()) {
			Common.sortList(model.getTrashList());
		}
	}
	
	/**
	 * Undo CLEAR command
	 */
	public String undo() {
		if (isPendingTab()) {
			recoverTasksForPendingTab();
		} else if (isCompleteTab()) {
			recoverTasksForCompleteTab();
		}
		
		resetTasksInTrash();
		Common.sortList(model.getTrashList());
		return Common.MESSAGE_SUCCESSFUL_UNDO;
	}

	/**
	 * This function resets the list of tasks in trash tab back to its original state
	 */
	private void resetTasksInTrash() {
		model.getTrashList().clear();
		for (int i = 0; i < originalTrashTasks.length; i++) {
			model.addTaskToTrash(originalTrashTasks[i]);
		}
	}
	
	/**
	 * This function recover cleared tasks for complete tab
	 */
	private void recoverTasksForCompleteTab() {
		for (int i = 0; i < clearedTasks.length; i++) {
			model.addTaskToComplete(clearedTasks[i]);
		}
		Common.sortList(model.getCompleteList());
	}
	
	/**
	 * This function recover cleared tasks for pending tab
	 */
	private void recoverTasksForPendingTab() {
		for (int i = 0; i < clearedTasks.length; i++) {
			model.addTaskToPending(clearedTasks[i]);
			reverseStatus(clearedTasks[i]);
		}
		Common.sortList(model.getPendingList());
	}
	
	// End of segment: D:\CS2103 Proj\src\Command.java





	/**
	 * origin: D:\CS2103 Proj\src\Command.java
	 */

/**
 * 
 * Class CompleteCommand. This class executes command to complete a list of given indices.
 * 
 */
class CompleteCommand extends IndexCommand {
	// List of tasks to complete
	private Task[] toCompleteTasks;
	// Indices of these tasks in the complete list
	private int[] indexInCompleteList;
	
	/**
	 * Constructor of this class
	 * 
	 * @param parsedUserCommand
	 *            the array of indices from the command parsed by Parser class
	 * @param model
	 *            model of tasks in the application
	 * @param tabIndex
	 *            the current tab
	 */
	public CompleteCommand(String[] parsedUserCommand, Model model, int tabIndex) {
		super(model, tabIndex);
		assert parsedUserCommand != null;
		modifiedList = this.model.getPendingList();
		indexCount = parsedUserCommand.length;
		indexList = new int[indexCount];
		indexInCompleteList = new int[indexCount];
		toCompleteTasks = new Task[indexCount];
		getListOfIndices(parsedUserCommand);
	}
	
	/**
	 * Execute COMPLETE command
	 */
	public String execute() {
		Arrays.sort(indexList);
		checkSuitableTab();
		checkValidIndexes();
		processComplete();
		retrieveIndexesAfterProcessing();

		return Common.MESSAGE_SUCCESSFUL_COMPLETE;
	}
		
	/**
	 * This is the main function for the completing process
	 */
	private void processComplete(){
		for (int i = indexCount - 1; i >= 0; i--) {
			int completeIndex = convertIndex(indexList[i] - 1);
			Task toComplete = model.getTaskFromPending(completeIndex);
			toCompleteTasks[i] = toComplete;
			modifyStatus(toComplete);
			model.completeTaskFromPending(completeIndex);
		}
		sortInvolvedLists();
	}
	
	// End of segment: D:\CS2103 Proj\src\Command.java





	/**
	 * origin: D:\CS2103 Proj\src\Command.java
	 */

	/**
	 * Get the indices of these tasks after they move to the complete list
	 */
	private void retrieveIndexesAfterProcessing(){
		for (int i = 0; i < indexCount; i++) {
			indexInCompleteList[i] = model.getIndexFromComplete(toCompleteTasks[i]);
		}
		Arrays.sort(indexInCompleteList);
	}
	
	// End of segment: D:\CS2103 Proj\src\Command.java





	/**
	 * origin: D:\CS2103 Proj\src\Command.java
	 */

	/**
	 * Undo COMPLETE command
	 */
	public String undo() {
		for (int i = indexCount - 1; i >= 0; i--) {
			Task toPending = model.getTaskFromComplete(indexInCompleteList[i]);
			reverseStatus(toPending);
			model.removeTaskFromCompleteNoTrash(indexInCompleteList[i]);
			model.addTaskToPending(toPending);
		}
		sortInvolvedLists();

		return Common.MESSAGE_SUCCESSFUL_UNDO;
	}
	
	// End of segment: D:\CS2103 Proj\src\Command.java





	/**
	 * origin: D:\CS2103 Proj\src\Command.java
	 */

/**
 * 
 * Class IncompleteCommand
 * 
 */
class IncompleteCommand extends IndexCommand {
	// List of tasks to be incompleted
	private Task[] toIncompleteTasks;
	// Indices of these tasks in pending list
	private int[] indexInIncompleteList;

	/**
	 * Constructor of this class
	 * 
	 * @param parsedUserCommand
	 *            array of indices from the command parsed by Parser class
	 * @param model
	 *            model of tasks in the application
	 * @param tabIndex
	 *            the current tab
	 */
	public IncompleteCommand(String[] parsedUserCommand, Model model,
			int tabIndex) {
		super(model, tabIndex);
		assert parsedUserCommand != null;
		modifiedList = this.model.getCompleteList();
		indexCount = parsedUserCommand.length;
		indexInIncompleteList = new int[indexCount];
		toIncompleteTasks = new Task[indexCount];

		getListOfIndices(parsedUserCommand);
	}

	/**
	 * Execute INCOMPLETE command
	 */
	public String execute() {
		Arrays.sort(indexList);
		checkSuitableTab();
		checkValidIndexes();
		
		processIncomplete();
		retrieveIndexesAfterProcessing();
		
		return Common.MESSAGE_SUCCESSFUL_INCOMPLETE;
	}
	
	/** 
	 * This is the main function for incompleting process
	 */
	private void processIncomplete(){
		for (int i = indexCount - 1; i >= 0; i--) {
			int incompleteIndex = convertIndex(indexList[i] - 1);
			Task toPending = model.getTaskFromComplete(incompleteIndex);
			modifyStatus(toPending);
			toIncompleteTasks[i] = toPending;
			model.getCompleteList().remove(incompleteIndex);
			model.addTaskToPending(toPending);
		}
		sortInvolvedLists();
	}
	
	// End of segment: D:\CS2103 Proj\src\Command.java





	/**
	 * origin: D:\CS2103 Proj\src\Command.java
	 */

	/**
	 * This function is used to get the indices of these tasks in pending list after processing
	 */
	private void retrieveIndexesAfterProcessing(){
		for (int i = 0; i < indexCount; i++) {
			indexInIncompleteList[i] = model
					.getIndexFromPending(toIncompleteTasks[i]);
		}
		Arrays.sort(indexInIncompleteList);
	}
	
	// End of segment: D:\CS2103 Proj\src\Command.java





	/**
	 * origin: D:\CS2103 Proj\src\Command.java
	 */

	/**
	 * Undo for INCOMPLETE command
	 */
	public String undo() {
		for (int i = indexCount - 1; i >= 0; i--) {
			Task toComplete = model.getTaskFromPending(indexInIncompleteList[i]);
			reverseStatus(toComplete);
			toIncompleteTasks[i] = toComplete;
			model.getPendingList().remove(indexInIncompleteList[i]);
			model.addTaskToComplete(toComplete);
		}
		sortInvolvedLists();
		return Common.MESSAGE_SUCCESSFUL_UNDO;
	}
	
	// End of segment: D:\CS2103 Proj\src\Command.java





	/**
	 * origin: D:\CS2103 Proj\src\Command.java
	 */

/**
 * 
 * Class MarkCommand. This class executes command to mark a list of indices as important
 * 
 */
class MarkCommand extends IndexCommand {
	
	/**
	 * Constructor of this class
	 * 
	 * @param parsedUserCommand
	 *            array of indices from the command parsed by Parser class
	 * @param model
	 *            model of tasks in the application
	 * @param tabIndex
	 *            the current tab
	 */
	public MarkCommand(String[] parsedUserCommand, Model model, int tabIndex) {
		super(model, tabIndex);
		assert parsedUserCommand != null;
		modifiedList = getModifiedList(tabIndex);
		indexCount = parsedUserCommand.length;
		getListOfIndices(parsedUserCommand);
	}

	/**
	 * Execute MARK command
	 */
	public String execute() {
		Arrays.sort(indexList);
		checkValidIndexes();
		for (int i = 0; i < indexCount; i++) {
			int markIndex = convertIndex(indexList[i] - 1);
			Task targetTask = modifiedList.get(markIndex);
			targetTask.setIsImportant(true);
			targetTask.updateLatestModifiedDate();
		}

		return Common.MESSAGE_SUCCESSFUL_MARK;
	}
	
	/**
	 * Undo MARK command
	 */
	public String undo() {
		for (int i = 0; i < indexCount; i++) {
			int unmarkIndex = convertIndex(indexList[i] - 1);
			Task targetTask = modifiedList.get(unmarkIndex);
			targetTask.setIsImportant(false);
			targetTask.updateLatestModifiedDate();
		}
		return Common.MESSAGE_SUCCESSFUL_UNDO;
	}
	
	// End of segment: D:\CS2103 Proj\src\Command.java





	/**
	 * origin: D:\CS2103 Proj\src\Command.java
	 */

/**
 * 
 * Class UnmarkCommand. This class executes command to unmark a list of indices in the list
 * 
 */
class UnmarkCommand extends IndexCommand {
	/**
	 * Constructor of this class
	 * 
	 * @param parsedUserCommand
	 *            array of indices from the command parsed by Parser class
	 * @param model
	 *            model of tasks in the application
	 * @param tabIndex
	 *            the current tab
	 */
	public UnmarkCommand(String[] parsedUserCommand, Model model, int tabIndex) {
		super(model, tabIndex);
		assert parsedUserCommand != null;
		modifiedList = getModifiedList(tabIndex);
		indexCount = parsedUserCommand.length;
		getListOfIndices(parsedUserCommand);
	}

	/**
	 * Execute UNMARK command
	 */
	public String execute() {
		Arrays.sort(indexList);
		checkValidIndexes();
		for (int i = 0; i < indexCount; i++) {
			int unmarkIndex = convertIndex(indexList[i] - 1);
			Task targetTask = modifiedList.get(unmarkIndex);
			targetTask.setIsImportant(false);
			targetTask.updateLatestModifiedDate();
		}

		return Common.MESSAGE_SUCCESSFUL_UNMARK;
	}
	
	/**
	 * Undo UNMARK command
	 */
	public String undo() {
		for (int i = 0; i < indexCount; i++) {
			int markIndex = convertIndex(indexList[i] - 1);
			Task targetTask = modifiedList.get(markIndex);
			targetTask.setIsImportant(true);
			targetTask.updateLatestModifiedDate();
		}
		return Common.MESSAGE_SUCCESSFUL_UNDO;
	}
	
	// End of segment: D:\CS2103 Proj\src\Command.java





	/**
	 * origin: D:\CS2103 Proj\src\Command.java
	 */

/**
 * 
 * Class HelpCommand. This class execute command to show the help window.
 * 
 */
class HelpCommand extends Command {
	// The main interface of the application
	private View view;
	
	/**
	 * Constructor of this class
	 * 
	 * @param model
	 *            model of tasks in application
	 * @param view
	 *            main interface
	 */
	public HelpCommand(Model model, View view) {
		super(model, view.getTabIndex());
		this.view = view;
	}
	
	/**
	 * Execute HELP command
	 */
	public String execute() {
		view.showHelpPage();
		return Common.MESSAGE_SUCCESSFUL_HELP;
	}
}

	// End of segment: D:\CS2103 Proj\src\Command.java





	/**
	 * origin: D:\CS2103 Proj\src\Command.java
	 */

/**
 * 
 * Class SettingsCommand. This class executes command to show SETTINGS dialog
 * 
 */
class SettingsCommand extends Command {
	// Main interface of the application
	private View view;
	// Indicator what calls the settings command
	private String origin;
	
	/**
	 * Constructor of this class
	 * 
	 * @param model
	 *            model of tasks in the application
	 * @param view
	 *            main interface
	 * @param origin
	 *            indicator what calls this command
	 */
	public SettingsCommand(Model model, View view, String origin) {
		super(model, view.getTabIndex());
		this.view = view;
		this.origin = origin;
	}
	
	/**
	 * Execute SETTINGS command
	 */
	public String execute() {
		view.showSettingsPage(origin);
		return Common.MESSAGE_SUCCESSFUL_SETTINGS;
	}
}


	// End of segment: D:\CS2103 Proj\src\Command.java





	/**
	 * origin: D:\CS2103 Proj\src\Common.java
	 */

	/******************************key combination*************************************/
	static final KeyCombination undo_hot_key = new KeyCodeCombination(
			KeyCode.Z, KeyCodeCombination.CONTROL_DOWN);
	static final KeyCombination redo_hot_key = new KeyCodeCombination(
			KeyCode.Y, KeyCodeCombination.CONTROL_DOWN);
	static final KeyCombination esc = new KeyCodeCombination(KeyCode.ESCAPE);
	static final KeyCombination saveSettings = new KeyCodeCombination(
			KeyCode.S, KeyCombination.CONTROL_DOWN);
	static final KeyCombination collapseWindow = new KeyCodeCombination(KeyCode.UP,
			KeyCombination.CONTROL_DOWN);
	static final KeyCombination expandWindow = new KeyCodeCombination(KeyCode.DOWN,
			KeyCombination.CONTROL_DOWN);
	static final KeyCombination hideWindow = new KeyCodeCombination(KeyCode.H,
			KeyCombination.CONTROL_DOWN, KeyCombination.SHIFT_DOWN);
	static final KeyCombination traditionalCloseWindow = new KeyCodeCombination(
			KeyCode.F4, KeyCombination.ALT_DOWN);
	static final KeyCombination changeTab = new KeyCodeCombination(KeyCode.TAB,
			KeyCombination.CONTROL_DOWN);
	
	/****************************** tab index **********************************************/
	static final int PENDING_TAB = 0;
	static final int COMPLETE_TAB = 1;
	static final int TRASH_TAB = 2;
	
	/******************************index of command info ***************************************/
	static final int INDEX_REDUNDANT_INFO = -2;
	static final int INDEX_COMMAND_TYPE = -1;
	static final int INDEX_WORK_INFO = 0;
	static final int INDEX_TAG = 1;
	static final int INDEX_START_DATE = 2;
	static final int INDEX_END_DATE = 3;
	static final int INDEX_IS_IMPT = 4;
	static final int INDEX_REPEATING = 5;
	static final int INDEX_INDEX_INFO = 6;
	
	static final int MINUTE_IN_MILLIS = 60000;
	
	/***********************************theme mode ************************************************/
	static final String DAY_MODE = "Day mode";
	static final String NIGHT_MODE = "Night mode";
	static final String BRIGHT = "Bright";
	static final String GOLDFISH = "Goldfish";
	
	// End of segment: D:\CS2103 Proj\src\Common.java





	/**
	 * origin: D:\CS2103 Proj\src\Control.java
	 */

	/**
	 * UNDO command execution
	 */
	private String executeUndoCommand() throws IOException {
		if (isUnderSyncingProcess()){
			return Common.MESSAGE_UNDO_RESTRICTION;
		}
		
		if (commandHistory.isUndoable()) {
			if(view != null) {
				executeShowCommand();
			}
			TwoWayCommand undoCommand = commandHistory.getPrevCommandForUndo();
			String feedback = undoCommand.undo();
			storeTask();
			return feedback;
		} 
		return Common.MESSAGE_INVALID_UNDO;
	}
	
	/**
	 * REDO command execution
	 */
	private String executeRedoCommand() throws IOException {
		if (isUnderSyncingProcess()){
			return Common.MESSAGE_REDO_RESTRICTION;
		}
		
		if (commandHistory.isRedoable()) {
			if (commandHistory.isAfterSearch()) {
				TwoWayCommand.setIndexType(TwoWayCommand.SEARCHED);
			}
			if(view != null) {
				executeShowCommand();
			}
			TwoWayCommand redoCommand = commandHistory.getPrevCommandForRedo();
			redoCommand.redo();
			storeTask();
			return Common.MESSAGE_SUCCESSFUL_REDO;
		} 
		return Common.MESSAGE_INVALID_REDO;
	}
	
	// End of segment: D:\CS2103 Proj\src\Control.java





	/**
	 * origin: D:\CS2103 Proj\src\Control.java
	 */

	/**
	 * CLEAR command execution
	 */
	private String executeClearCommand() throws IOException {
		boolean isAfterSearch = TwoWayCommand.listedIndexType;
		int tabIndex = getTabIndex();
		assert tabIndex >= 0 && tabIndex <= 2;
		Command clearCommand = new ClearAllCommand(model, tabIndex);
		String feedback = clearCommand.execute();
		
		if (feedback.equals(Common.MESSAGE_SUCCESSFUL_CLEAR_ALL)) {
			commandHistory.updateCommand((TwoWayCommand) clearCommand, isAfterSearch);
			storeTask();
			if(view != null) {
				executeShowCommand();
			}
		}
		return feedback;
	}
	
	/**
	 * COMPLETE command execution
	 */
	private String executeCompleteCommand(String[] parsedUserCommand)
			throws IOException {
		boolean isAfterSearch = TwoWayCommand.listedIndexType;
		int tabIndex = getTabIndex();
		assert tabIndex >= 0 && tabIndex <= 2;
		Command completeCommand = new CompleteCommand(parsedUserCommand, model, tabIndex);
		String feedback = completeCommand.execute();

		if (feedback.equals(Common.MESSAGE_SUCCESSFUL_COMPLETE)) {
			commandHistory.updateCommand((TwoWayCommand) completeCommand, isAfterSearch);
			storeTask();
			if(view != null) {
				executeShowCommand();
			}
		}
		return feedback;
	}
	
	/**
	 * INCOMPLETE command execution
	 */
	private String executeIncompleteCommand(String[] parsedUserCommand)
			throws IOException {
		boolean isAfterSearch = TwoWayCommand.listedIndexType;
		int tabIndex = getTabIndex();
		assert tabIndex >= 0 && tabIndex <= 2;
		Command incompleteCommand = new IncompleteCommand(parsedUserCommand, model, tabIndex);
		String feedback = incompleteCommand.execute();

		if (feedback.equals(Common.MESSAGE_SUCCESSFUL_INCOMPLETE)) {
			commandHistory.updateCommand((TwoWayCommand) incompleteCommand, isAfterSearch);
			storeTask();
			if(view != null) {
				executeShowCommand();
			}
		}
		return feedback;
	}
	
	// End of segment: D:\CS2103 Proj\src\Control.java





	/**
	 * origin: D:\CS2103 Proj\src\Control.java
	 */

	/**
	 * MARK command execution
	 */
	private String executeMarkCommand(String[] parsedUserCommand)
			throws IOException {
		boolean isAfterSearch = TwoWayCommand.listedIndexType;
		int tabIndex = getTabIndex();
		assert tabIndex >= 0 && tabIndex <= 2;
		Command markCommand = new MarkCommand(parsedUserCommand, model, tabIndex);
		String feedback = markCommand.execute();

		if (feedback.equals(Common.MESSAGE_SUCCESSFUL_MARK)) {
			commandHistory.updateCommand((TwoWayCommand) markCommand, isAfterSearch);
			storeTask();
			if(view != null) {
				executeShowCommand();
			}
		}
		return feedback;
	}
	
	/**
	 * UNMARK command execution
	 */
	private String executeUnmarkCommand(String[] parsedUserCommand)
			throws IOException {
		boolean isAfterSearch = TwoWayCommand.listedIndexType;
		int tabIndex = getTabIndex();
		assert tabIndex >= 0 && tabIndex <= 2;
		Command unmarkCommand = new UnmarkCommand(parsedUserCommand, model, tabIndex);
		String feedback = unmarkCommand.execute();

		if (feedback.equals(Common.MESSAGE_SUCCESSFUL_UNMARK)) {
			commandHistory.updateCommand((TwoWayCommand) unmarkCommand, isAfterSearch);
			storeTask();
			if(view != null) {
				executeShowCommand();
			}
		}
		return feedback;
	}
	
	/**
	 * HELP command execution
	 */
	private String executeHelpCommand() {
		Command helpCommand = new HelpCommand(model, view);
		return helpCommand.execute();
	}
	
	/**
	 * SETTINGS command execution
	 */
	private String executeSettingsCommand(String origin) throws IOException{
		view.getStage().hide();
		String previousTheme = model.getThemeMode();
		if(syncTimer != null)
			syncTimer.cancel();
		
		Command settingsCommand = new SettingsCommand(model, view, origin);
		String feedback = settingsCommand.execute();
		
		if (feedback.equals(Common.MESSAGE_SUCCESSFUL_SETTINGS)) {
			settingStore.updateToFile();
			updateGUI(previousTheme);
			initializeAutoSync();
			updateTimeFormat();
		}
		view.getStage().toFront();
		view.getStage().show();
		return feedback;
	}
	
	// End of segment: D:\CS2103 Proj\src\Control.java





	/**
	 * origin: D:\CS2103 Proj\src\Help.java
	 */

/**
 * 
 * This class provides the main graphic user interface for the Help panel.
 * 
 */
public class Help{
	private static Logger log = Logger.getLogger("Help");
	private final KeyCombination nextPage = new KeyCodeCombination(KeyCode.RIGHT, KeyCombination.CONTROL_DOWN);
	private final KeyCombination backPage = new KeyCodeCombination(KeyCode.LEFT, KeyCombination.CONTROL_DOWN);
	
	private static Help oneHelpPage;
	public Model model;
	
	private Scene helpScene;
	private Stage helpStage;
	private Group root;
	private Group buttons;
	private ImageView helpPage;
	private Button backButton;
	private Button nextButton;
	private Button exitButton;
	private double dragAnchorX;
	private double dragAnchorY;
	
	/**
	 * This is the constructor for class Help. 
	 * 
	 * @param model
	 *            model of lists of tasks
	 */
	private Help(Model model){	
		initializeModel(model);
		setupInitialStage();	
		setupScene();
		setupShortcuts();
		setupDraggable();
	}
	
	/**
	 * This creates one instance of Help
	 * 
	 * @param model
	 *            model of lists of tasks
	 * @return the instance of Help
	 */
	public static Help getInstanceHelp(Model model){
		if (oneHelpPage == null){
			oneHelpPage = new Help(model);
		}		
		return oneHelpPage;
	}
	
	// shows the Help page at page 1
	public void showHelpPage(){
		changeToFirstPage();
		helpStage.show();
	}
	
	/************************** sets up general GUI of Help ****************************/
	/**
	 * This initializes the model of lists of tasks
	 * 
	 * @param model
	 *            model of lists of tasks
	 */
	private void initializeModel(Model model){
		this.model = model;
	}
	
	// set up the stage for the Help page
	private void setupInitialStage(){
		helpPage = new ImageView();
		buttons = new Group();
		helpStage = new Stage();
		helpStage.initStyle(StageStyle.UNDECORATED);
		helpStage.setWidth(600);
		helpStage.setHeight(750);
		Rectangle2D screenBounds = Screen.getPrimary().getVisualBounds();
		helpStage.setX((screenBounds.getWidth() - helpStage.getWidth()) / 2);
		helpStage.setY((screenBounds.getHeight() - helpStage.getHeight()) / 2);
		helpStage.setTitle("iDo Help Page");
		helpStage.getIcons().add(
				new Image(getClass().getResource("iDo_traybar.png")
						.toExternalForm()));
		setupButtons();
		changeToFirstPage();
	}
	
	// create the scene of the stage
	private void setupScene(){
		root = new Group();
		root.getChildren().add(helpPage);
		root.getChildren().add(buttons);
		helpScene = new Scene(root, 600, 730);
		helpScene.getStylesheets().addAll(
				getClass().getResource("dayCustomization.css").toExternalForm());
		helpStage.setScene(helpScene);
	}
	
	// create shortcut keys for Help page
	private void setupShortcuts(){
		root.setOnKeyPressed(new EventHandler<KeyEvent>(){
			public void handle(KeyEvent e) {
				log.log(Level.INFO, "Executing shortcut key...");
				if (nextPage.match(e)) {
					log.log(Level.INFO, "Pressing ctrl + right...");
					changeToSecondPage();
				} else if (backPage.match(e)){
					log.log(Level.INFO, "Pressing ctrl + left...");
					changeToFirstPage();
				} else if (Common.esc.match(e)){
					log.log(Level.INFO, "Pressing esc for help page...");
					helpStage.close();
				}
			}
		});
	}
	
	// set up draggable
	private void setupDraggable() {
		root.setOnMousePressed(new EventHandler<MouseEvent>() {
			@Override
			public void handle(MouseEvent me) {
				dragAnchorX = me.getScreenX() - helpStage.getX();
				dragAnchorY = me.getScreenY() - helpStage.getY();
			}
		});

		root.setOnMouseDragged(new EventHandler<MouseEvent>() {
			@Override
			public void handle(MouseEvent me) {
				helpStage.setX(me.getScreenX() - dragAnchorX);
				helpStage.setY(me.getScreenY() - dragAnchorY);
			}
		});
	}
	
	// set up all buttons on help page
	private void setupButtons() {
		setupBackButton();
		setupNextButton();
		setupExitButton();
		buttons.getChildren().add(backButton);
		buttons.getChildren().add(nextButton);
		buttons.getChildren().add(exitButton);
		buttons.setLayoutX(510);
		buttons.setLayoutY(25);
	}
	
	/************************** changes display image of Help ****************************/
	// changes the image shown on Help page to page 1
	private void changeToFirstPage(){
		setupImage(getFirstHelpImage());
		nextButton.setVisible(true);
		nextButton.setDisable(false);
		backButton.setVisible(false);
		backButton.setDisable(true);
	}
	
	// changes the image shown on Help page to page 2
	private void changeToSecondPage(){
		setupImage(getSecondHelpImage());
		backButton.setVisible(true);
		backButton.setDisable(false);
		nextButton.setVisible(false);
		nextButton.setDisable(true);
	}
	
	/**
	 * This sets up the help image as the background of the stage
	 * 
	 * @param helpImage
	 *            images of the Help background
	 */
	private void setupImage(Image helpImage){
		helpPage.setImage(helpImage);
		helpPage.setFitWidth(600);
		helpPage.setPreserveRatio(true);
		helpPage.setSmooth(true);
		helpPage.setCache(true);
	}
	
	/**
	 * Get function of page 1 Help image
	 * 
	 * @return firstHelpImage
	 *            image page 1 of Help
	 */
	private Image getFirstHelpImage(){
		Image firstHelpImage;
		if (model.getThemeMode().equals(Common.DAY_MODE)){
			firstHelpImage = new Image(getClass().getResourceAsStream("helpPage1.png"));
		} else {
			firstHelpImage = new Image(getClass().getResourceAsStream("helpNightPage1.png"));
		}
		return firstHelpImage;
	}
	
	/**
	 * Get function of page 2 Help image
	 * 
	 * @return secondHelpImage
	 *            image page 2 of Help
	 */
	private Image getSecondHelpImage(){
		Image secondHelpImage;
		if (model.getThemeMode().equals(Common.DAY_MODE)){
			secondHelpImage = new Image(getClass().getResourceAsStream("helpPage2.png"));	
		} else{
			secondHelpImage = new Image(getClass().getResourceAsStream("helpNightPage2.png"));	
		}
		return secondHelpImage;
	}
	
	/************************** sets up the individual Buttons ****************************/
	// sets up Button to go from page 1 to 2
	private void setupNextButton() {
		nextButton = new Button("");
		nextButton.setId("next");
		nextButton.setPrefSize(30, 30);
		nextButton.setOnMouseClicked(new EventHandler<MouseEvent>() {
			public void handle(MouseEvent e) {
				changeToSecondPage();
			}
		});
	}
	
	// sets up Button to go from page 2 to 1
	private void setupBackButton() {
		backButton = new Button("");
		backButton.setId("back");
		backButton.setPrefSize(30, 30);
		backButton.setOnMouseClicked(new EventHandler<MouseEvent>() {
			public void handle(MouseEvent e) {
				changeToFirstPage();
			}
		});
	}
	
	// sets up Exit Button to exit Help
	private void setupExitButton() {
		exitButton = new Button("");
		exitButton.setId("close_help");
		exitButton.setPrefSize(25, 25);
		exitButton.setTranslateX(40);
		exitButton.setTranslateY(3);
		exitButton.setOnMouseClicked(new EventHandler<MouseEvent>() {
			public void handle(MouseEvent e) {
				helpStage.close();
			}
		});
	}	
	
}

	// End of segment: D:\CS2103 Proj\src\Help.java





	/**
	 * origin: D:\CS2103 Proj\src\History.java
	 */

/**
 * 
 * History class: This class stores and retrieves past commands.
 * 
 */
class History {
	private static Logger log = Logger.getLogger("History");
	private Stack<TwoWayCommand> prevCommandsForUndo;
	private Stack<TwoWayCommand> prevCommandsForRedo;
	private boolean undoable;
	private boolean redoable;
	private boolean isOperatedAfterSearch;

	/**
	 * This is the constructor for class History. 
	 */
	public History() {
		prevCommandsForUndo = new Stack<TwoWayCommand>();
		prevCommandsForRedo = new Stack<TwoWayCommand>();
		undoable = false;
		redoable = false;
		isOperatedAfterSearch = false;
	}
	
	/************************ GET Functions **********************************/
	public boolean isUndoable() {
		return undoable;
	}
	
	public boolean isRedoable() {
		return redoable;
	}
	
	// End of segment: D:\CS2103 Proj\src\History.java





	/**
	 * origin: D:\CS2103 Proj\src\History.java
	 */

	public TwoWayCommand getPrevCommandForUndo() {
		assert undoable == true;
		TwoWayCommand previousCommand = prevCommandsForUndo.pop();
		prevCommandsForRedo.push(previousCommand);
		log.log(Level.INFO, "Moved one previous command from undo to redo.");
		redoable = true;
		if (prevCommandsForUndo.empty()){
			undoable = false;
		}
		return previousCommand;
	}
	
	public TwoWayCommand getPrevCommandForRedo(){
		assert redoable == true;
		TwoWayCommand previousCommand = prevCommandsForRedo.pop();
		prevCommandsForUndo.push(previousCommand);
		log.log(Level.INFO, "Moved one previous command from redo to undo.");
		undoable = true;
		if (prevCommandsForRedo.empty()){
			redoable = false;
		}
		return previousCommand;
	}
	
	/************************ SET Functions **********************************/
	public void setUndoable(boolean undoable) {
		this.undoable = undoable;
	}

	public void setRedoable(boolean redoable) {
		this.redoable = redoable;
	}
	
	public void clearUndoStack(){
		prevCommandsForUndo.clear();
		undoable = false;
	}
	
	public void clearRedoStack(){
		prevCommandsForRedo.clear();
		redoable = false;
	}
	
	// End of segment: D:\CS2103 Proj\src\History.java





	/**
	 * origin: D:\CS2103 Proj\src\History.java
	 */

	/************************ UPDATE Functions **********************************/
	// update with most recent TwoWayCommand without prior searching
	public void updateCommand(TwoWayCommand newCommand) {
		prevCommandsForUndo.push(newCommand);
		clearRedoStack();
		log.log(Level.INFO, "Cleared redo stack and added new command to undo stack.");
		undoable = true;
	}
	
	// End of segment: D:\CS2103 Proj\src\History.java





	/**
	 * origin: D:\CS2103 Proj\src\Login.java
	 */

/**
 * 
 * This class provides the main graphic user interface for the Login panel.
 * 
 */
public class Login {
	private static final boolean STORE_SUCCESSFUL = true;
	private static final boolean STORE_FAIL = false;
	
	private final KeyCombination saveInput = new KeyCodeCombination(KeyCode.ENTER);
	
	private static Login oneLoginPage;
	private Model model;
	
	private Scene loginScene;
	private Stage loginStage;
	private Group root;
	private Group buttons;
	private GridPane grid;
	private double dragAnchorX;
	private double dragAnchorY;
	private TextField googleAccountTextfield;
	private PasswordField pwBox;
	private PasswordField pwRetypeBox;
	

	/**
	 * This is the constructor for class Login. 
	 * 
	 * @param model
	 *            model of lists of tasks
	 */
	private Login(Model model){
		initializeModel(model);
		setupStage();
		setupForm();
		setupButtons();
		setupScene();
		setupDraggable();
		setupShortcuts();
	}
	
	/**
	 * This creates one instance of Login
	 * 
	 * @param model
	 *            model of lists of tasks
	 * @return the instance of Login
	 */
	public static Login getInstanceLogin(Model model){
		if (oneLoginPage == null){
			oneLoginPage = new Login(model);
		}		
		return oneLoginPage;
	}
	
	// shows the Login page
	public void showLoginPage(){
		loginStage.showAndWait();
	}
	
	/************************** sets up general GUI of Login ****************************/
	/**
	 * This initializes the model of lists of tasks
	 * 
	 * @param model
	 *            model of lists of tasks
	 */
	private void initializeModel(Model model){
		this.model = model;
	}
	
	// set up the stage for the Login page
	private void setupStage(){
		loginStage = new Stage();
		loginStage.initStyle(StageStyle.UNDECORATED);
		loginStage.initModality(Modality.APPLICATION_MODAL);
		loginStage.setWidth(415.5);
		loginStage.setHeight(315);
		Rectangle2D screenBounds = Screen.getPrimary().getVisualBounds();
		loginStage.setX((screenBounds.getWidth() - loginStage.getWidth()) / 2);
		loginStage.setY((screenBounds.getHeight() - loginStage.getHeight()) / 2);
		loginStage.setTitle("iDo Login");
		loginStage.getIcons().add(
				new Image(getClass().getResource("iDo_traybar.png")
						.toExternalForm()));
	}
	
	// set up the form to fill in details
	private void setupForm(){
		grid = new GridPane();
		grid.setAlignment(Pos.CENTER_LEFT);
		grid.setHgap(10);
		grid.setVgap(10);
		grid.setPadding(new Insets(85, 25, 25, 40));
		setupTextfields();
	}
	
	// create the scene of the stage
	private void setupScene(){
		root = new Group();
		root.getChildren().add(setupBackground());
		root.getChildren().add(grid);
		root.getChildren().add(buttons);
		loginScene = new Scene(root, 415.5, 315);
		loginScene.getStylesheets().addAll(
				getClass().getResource("dayCustomization.css").toExternalForm());
		loginStage.setScene(loginScene);
	}
	
	// create shortcut keys for Login page
	private void setupShortcuts(){
		root.setOnKeyPressed(new EventHandler<KeyEvent>(){
			public void handle(KeyEvent e) {
				if (Common.esc.match(e)) {
					loginStage.close();
				} else if (saveInput.match(e)){
					if (storeUserInfo()){
						loginStage.close();
					} 
				}
			}
		});
	}
	
	// set up draggable
	private void setupDraggable() {
		root.setOnMousePressed(new EventHandler<MouseEvent>() {
			@Override
			public void handle(MouseEvent me) {
				dragAnchorX = me.getScreenX() - loginStage.getX();
				dragAnchorY = me.getScreenY() - loginStage.getY();
			}
		});

		root.setOnMouseDragged(new EventHandler<MouseEvent>() {
			@Override
			public void handle(MouseEvent me) {
				loginStage.setX(me.getScreenX() - dragAnchorX);
				loginStage.setY(me.getScreenY() - dragAnchorY);
			}
		});
	}
	
	// set up all buttons on login page
	private void setupButtons(){
		buttons = new Group();
		buttons.getChildren().add(setupSaveButton());
		buttons.getChildren().add(setupExitButton());
		buttons.setLayoutX(340);
		buttons.setLayoutY(240);
	}
	
	// set up all textfields on login page
	private void setupTextfields(){
		setupUserTextfield();
		setupPasswordTextfield();
		setupPasswordRetypeTextfield();
	}
	
	/************************** sets up the individual Textfields ****************************/
	// set up the Google account textfield
	private void setupUserTextfield(){
		Label googleAccount = new Label("Google account:");
		grid.add(googleAccount, 0, 1);
		googleAccountTextfield = new TextField();
		googleAccountTextfield.requestFocus();
		googleAccountTextfield.setId("input");
		grid.add(googleAccountTextfield, 1, 1);
	}
	
	// set up the Password textfield
	private void setupPasswordTextfield(){
		Label pw = new Label("Password:");
		grid.add(pw, 0, 2);
		pwBox = new PasswordField();
		grid.add(pwBox, 1, 2);
	}
	
	// set up the Password Retype textfield
	private void setupPasswordRetypeTextfield(){
		Label pwRetype = new Label("Retype password:");
		grid.add(pwRetype, 0, 3);
		pwRetypeBox = new PasswordField();
		grid.add(pwRetypeBox, 1, 3);
	}
	
	/************************** sets up the individual Buttons ****************************/
	/**
	 * This sets up the save button
	 * 
	 * @return saveButton
	 *            button to save user info
	 */
	private Button setupSaveButton(){
		Button saveButton = new Button("");
		saveButton.setId("save");
		saveButton.setPrefSize(76, 42);
		saveButton.setTranslateX(-95);
		saveButton.setOnMouseClicked(new EventHandler<MouseEvent>() {
			public void handle(MouseEvent e) {
				if (storeUserInfo()){
					loginStage.close();
				} 
			}
		});	
		return saveButton;
	}
	
	/**
	 * This sets up the exit button
	 * 
	 * @return cancelButton
	 *            button to exit
	 */
	private Button setupExitButton(){
		Button cancelButton = new Button("");
		cancelButton.setId("esc");
		cancelButton.setPrefSize(42, 42);
		cancelButton.setOnMouseClicked(new EventHandler<MouseEvent>() {
			public void handle(MouseEvent e) {
				loginStage.close();
				if (storeUserInfo()){
					loginStage.close();
				}
			}
		});	
		return cancelButton;
	}
	
	/************************** sets up background image Login ****************************/
	/**
	 * This sets up the login image as the background of the stage
	 * 
	 * @return loginBg
	 *            image of the Login background
	 */
	private ImageView setupBackground(){
		Image loginImage = new Image(getClass().getResourceAsStream("login.png"));
		ImageView loginBg = new ImageView();
		loginBg.setImage(loginImage);
		loginBg.setFitWidth(415.5);
		loginBg.setPreserveRatio(true);
		loginBg.setSmooth(true);
		loginBg.setCache(true);
	
		return loginBg;
	}
	
	// End of segment: D:\CS2103 Proj\src\Login.java





	/**
	 * origin: D:\CS2103 Proj\src\Model.java
	 */

	/********************************** GET the index from given task ******************************/
	public int getIndexFromPending(Task task) {
		return pending.indexOf(task);
	}

	public int getIndexFromComplete(Task task) {
		return complete.indexOf(task);
	}

	public int getIndexFromTrash(Task task) {
		return trash.indexOf(task);
	}
	
	
	/****************************** ADD a task to the list *******************************/
	public void addTaskToPending(Task newPendingTask) {
		pending.add(newPendingTask);
	}

	public void addTaskToComplete(Task newCompleteTask) {
		complete.add(newCompleteTask);
	}

	public void addTaskToTrash(Task newTrashTask) {
		trash.add(newTrashTask);
	}

	/******************** REMOVE a task with indicated index *******************************/
	public void removeTask(int index, int tabIndex) {
		if (tabIndex == PENDING_TAB) {
			removeTaskFromPending(index);
		} else if (tabIndex == COMPLETE_TAB) {
			removeTaskFromComplete(index);
		} else if (tabIndex == TRASH_TAB) {
			removeTaskFromTrash(index);
		}
	}

	private void removeTaskFromPending(int index) {
		try {
			Task t = pending.remove(index);
			if (t.getStatus() != Task.Status.ADDED_WHEN_SYNC) {
				removedIdDuringSync.add(t.getIndexId());
			}
			trash.add(t);
		} catch (IndexOutOfBoundsException e) {
			logger.log(Level.WARNING, MESSAGE_OUT_OF_BOUNDS_INDEX);
		}
	}

	private void removeTaskFromComplete(int index) {
		try {
			Task t = complete.remove(index);
			trash.add(t);
		} catch (IndexOutOfBoundsException e) {
			logger.log(Level.WARNING, MESSAGE_OUT_OF_BOUNDS_INDEX);
		}
	}

	private void removeTaskFromTrash(int index) {
		try {
			trash.remove(index);
		} catch (IndexOutOfBoundsException e) {
			logger.log(Level.WARNING, MESSAGE_OUT_OF_BOUNDS_INDEX);
		}
	}

	/***************************** REMOVE a task with indicated index permanently, not moving to trash *******************/
	public void removeTaskFromPendingNoTrash(int index) {
		try {
			pending.remove(index);
		} catch (IndexOutOfBoundsException e) {
			logger.log(Level.WARNING, MESSAGE_OUT_OF_BOUNDS_INDEX);
		}
	}

	public void removeTaskFromCompleteNoTrash(int index) {
		try {
			complete.remove(index);
		} catch (IndexOutOfBoundsException e) {
			logger.log(Level.WARNING, MESSAGE_OUT_OF_BOUNDS_INDEX);
		}
	}

	/******************************complete a task from pending***************************************/
	public void completeTaskFromPending(int index) {
		try {
			Task t = pending.remove(index);
			if (t.getStatus() != Task.Status.ADDED_WHEN_SYNC) {
				removedIdDuringSync.add(t.getIndexId());
			}
			addTaskToComplete(t);
		} catch (IndexOutOfBoundsException e) {
			logger.log(Level.WARNING, MESSAGE_OUT_OF_BOUNDS_INDEX);
		}
	}
	
	/************************************** SET a specific searchList *********************************/
	public void setSearchPendingList(ObservableList<Task> searchList) {
		searchPending = searchList;
	}

	public void setSearchCompleteList(ObservableList<Task> searchList) {
		searchComplete = searchList;
	}

	public void setSearchTrashList(ObservableList<Task> searchList) {
		searchTrash = searchList;
	}
	
	// End of segment: D:\CS2103 Proj\src\Model.java





	/**
	 * origin: D:\CS2103 Proj\src\Model.java
	 */

	public String getColourScheme(){
		return colourScheme;
	}
	
	public boolean getDisplayRemaining() {
		return displayRemaining;
	}
	public boolean hasAutoSync() {
		return isAutoSync;
	}
	
	public String getUsername(){
		return username;
	}
	
	public String getPassword(){
		return password;
	}
	
	public int getSyncPeriod(){
		return syncPeriod;
	}
	
	/***************************************** SET functions ********************************************/
	public void setThemeMode(String themeMode){
		this.themeMode = themeMode;
	}

	public void setDisplayRemaining(boolean displayRemaining){
		this.displayRemaining = displayRemaining;
	}

	public void setAutoSync(boolean isAutoSync) {
		this.isAutoSync = isAutoSync;
	}
	
	public void setColourScheme(String colourScheme){
		this.colourScheme = colourScheme;
	}
	
	public void setUsername(String username){
		this.username = username;
	}
	
	public void setPassword(String password){
		this.password = password;
	}
	
	public void setSyncPeriod(int syncPeriod){
		this.syncPeriod = syncPeriod;
	}
}
	// End of segment: D:\CS2103 Proj\src\Model.java





	/**
	 * origin: D:\CS2103 Proj\src\Settings.java
	 */

	/**
	 * This is the constructor for class Settings. 
	 * 
	 * @param model
	 *            model of lists of tasks
	 */
	private Settings(Model model) {
		initializeKeyVariables(model);
		setupStage();
		setupContent();
		setupButtons();
		setupScene();
		setupShortcuts();
		setupDraggable();
	}
	
	// End of segment: D:\CS2103 Proj\src\Settings.java





	/**
	 * origin: D:\CS2103 Proj\src\Settings.java
	 */

	/**
	 * This creates one instance of Settings
	 * 
	 * @param model
	 *            model of lists of tasks
	 * @return the instance of Settings
	 */
	public static Settings getInstanceSettings(Model model) {
		if (oneSettingsPage == null) {
			oneSettingsPage = new Settings(model);
		}
		return oneSettingsPage;
	}

	/**
	 * This shows the Settings stage
	 * 
	 * @param checkUsernamePassword
	 *            String that determines which error message to show
	 */
	public void showSettingsPage(String checkUsernamePassword) {
		showTextFields();
		showErrorTexts(checkUsernamePassword);
		showTimeDisplay();
		showThemeMode();
		showColourScheme();
		showSyncMode();	
		settingsStage.showAndWait();
	}

	/************************** sets up general GUI of Settings ****************************/
	/**
	 * This initializes the model of lists of tasks
	 * 
	 * @param model
	 *            model of lists of tasks
	 */
	private void initializeKeyVariables(Model model){
		this.model = model;
	}
	
	// set up the stage for Settings
	private void setupStage() {
		settingsStage = new Stage();
		settingsStage.initStyle(StageStyle.UNDECORATED);
		settingsStage.initModality(Modality.APPLICATION_MODAL);
		settingsStage.setWidth(599);
		settingsStage.setHeight(450);
		Rectangle2D screenBounds = Screen.getPrimary().getVisualBounds();
		settingsStage
				.setX((screenBounds.getWidth() - settingsStage.getWidth()) / 2);
		settingsStage.setY((screenBounds.getHeight() - settingsStage
				.getHeight()) / 2);
		settingsStage.setTitle("iDo Settings");
		settingsStage.getIcons().add(
				new Image(getClass().getResource("iDo_traybar.png")
						.toExternalForm()));
	}
	
	// set up the all content in Settings 
	private void setupContent() {
		setupGrid();
		setupTextfields();
		setupTimeFormat();
		setupThemeMode();
		setupColourScheme();
		setupSyncMode();
		setupSyncPeriod();
	}
	
	// set up the scene for Settings stage
	private void setupScene() {
		root = new Group();
		root.getChildren().add(setupBackground());
		root.getChildren().add(grid);
		root.getChildren().add(buttons);
		settingsScene = new Scene(root, Color.rgb(70, 70, 70));
		settingsScene.getStylesheets().addAll(
				getClass().getResource("dayCustomization.css").toExternalForm());
		settingsStage.setScene(settingsScene);
	}
	
	// set up all Buttons
	private void setupButtons() {
		buttons = new Group();
		buttons.getChildren().add(setupSaveButton());
		buttons.getChildren().add(setupExitButton());
		buttons.setLayoutX(520);
		buttons.setLayoutY(375);
	}
	
	// set up shortcut keys
	private void setupShortcuts() {
		root.setOnKeyPressed(new EventHandler<KeyEvent>() {
			public void handle(KeyEvent e) {
				if (Common.esc.match(e)) {
					settingsStage.close();
				} else if (Common.saveSettings.match(e)) {
					if (storeSettingChanges()) {
						settingsStage.close();
					}
				}
			}
		});
	}

	// set up draggable
	private void setupDraggable() {
		root.setOnMousePressed(new EventHandler<MouseEvent>() {
			@Override
			public void handle(MouseEvent me) {
				dragAnchorX = me.getScreenX() - settingsStage.getX();
				dragAnchorY = me.getScreenY() - settingsStage.getY();
			}
		});
		root.setOnMouseDragged(new EventHandler<MouseEvent>() {
			@Override
			public void handle(MouseEvent me) {
				settingsStage.setX(me.getScreenX() - dragAnchorX);
				settingsStage.setY(me.getScreenY() - dragAnchorY);
			}
		});
	}
	
	/************************** individual methods to show Settings fields ****************************/
	// shows the Google account and password in their respective textfields
	private void showTextFields(){
		googleAccountTextfield.setText(model.getUsername());
		pwBox.setText(model.getPassword());
		pwRetypeBox.setText(model.getPassword());
	}
		
	/**
	 * This shows the error messages for Google account and Password
	 * 
	 * @param checkUsernamePassword
	 *            String that determines which error message to show
	 */
	private void showErrorTexts(String checkUsernamePassword){
		if (checkUsernamePassword.equals(Control.CALL_NORMAL_SETTINGS)){
			showNormalSettings();
		} else if (checkUsernamePassword.equals(Control.CALL_SETTINGS_FROM_SYNC)){
			showErrorInvalidAccountPassword();
		} else if (checkUsernamePassword.equals(Common.MESSAGE_PASSWORDS_MATCH_FAIL)){
			showErrorDifferentPasswords();
		}
	}
	
	// End of segment: D:\CS2103 Proj\src\Settings.java





	/**
	 * origin: D:\CS2103 Proj\src\Settings.java
	 */

	// shows normal settings, i.e without error messages
	private void showNormalSettings(){
		invalidUsername.setVisible(false);
		invalidPassword.setVisible(false);
		differentPassword.setVisible(false);
	}
	
	// shows error message for invalid account or password
	private void showErrorInvalidAccountPassword(){
		invalidUsername.setVisible(true);
		invalidPassword.setVisible(true);
		differentPassword.setVisible(false);
	}
	
	// shows error message for non-matching passwords
	private void showErrorDifferentPasswords(){
		invalidUsername.setVisible(false);
		invalidPassword.setVisible(false);
		differentPassword.setVisible(true);
	}
	
	/************************** sets up individual content fields ****************************/
	// set up the grid
	private void setupGrid(){
		grid = new GridPane();
		grid.setAlignment(Pos.CENTER_LEFT);
		grid.setHgap(10);
		grid.setVgap(10);
		grid.setPadding(new Insets(85, 25, 25, 40));
	}	
	
	// set up the text fields
	private void setupTextfields() {
		setupUserTextfield();
		setupPasswordTextfield();
		setupPasswordRetypeTextfield();
		setupErrorTexts();
	}

	// set up the error messages
	private void setupErrorTexts(){
		invalidUsername = new Text("Account may be invalid.");
		invalidPassword = new Text("Password may be invalid.");
		differentPassword = new Text(Common.MESSAGE_PASSWORDS_MATCH_FAIL);
		
		invalidUsername.setVisible(false);
		invalidPassword.setVisible(false);
		differentPassword.setVisible(false);
		
		invalidUsername.setId("error_text");
		invalidPassword.setId("error_text");
		differentPassword.setId("error_text");
		
		grid.add(invalidUsername, 2, 1);
		grid.add(invalidPassword, 2, 2);
		grid.add(differentPassword, 2, 3);
	}
	
	// set up the colour scheme
	private void setupColourScheme() {
		Label colourScheme = new Label("Colour scheme:");
		grid.add(colourScheme, 0, 7);

		ObservableList<String> colourOptions = FXCollections
				.observableArrayList(Common.DAY_MODE, Common.NIGHT_MODE,
						Common.GOLDFISH, Common.BRIGHT);

		colourSchemes = new ComboBox<String>(colourOptions);
		colourSchemes.setPrefWidth(175);
		if (model.getColourScheme() != null) {
			colourSchemes.setValue(model.getColourScheme());
		} else {
			if (model.getThemeMode().equals(Common.NIGHT_MODE)) {
				colourSchemes.setValue(Common.NIGHT_MODE);
			} else {
				colourSchemes.setValue(Common.DAY_MODE);
			}
		}
		grid.add(colourSchemes, 1, 7);
	}
	
	// End of segment: D:\CS2103 Proj\src\Settings.java





	/**
	 * origin: D:\CS2103 Proj\src\Settings.java
	 */

	/************************** sets up background image Settings ****************************/
	/**
	 * This sets up the settings image as the background of the stage
	 * 
	 * @return loginBg
	 *            image of the Settings background
	 */
	private ImageView setupBackground() {
		bgImage = new ImageView();
		bgImage.setFitWidth(600);
		bgImage.setPreserveRatio(true);
		bgImage.setSmooth(true);
		bgImage.setCache(true);

		return bgImage;
	}

	// End of segment: D:\CS2103 Proj\src\Settings.java





	/**
	 * origin: D:\CS2103 Proj\src\Settings.java
	 */

	/************************** sets up the individual Textfields ****************************/
	// set up the Google account textfield
	private void setupUserTextfield(){
		Label googleAccount = new Label("Google account:");
		grid.add(googleAccount, 0, 1);
		googleAccountTextfield = new TextField();
		googleAccountTextfield.setText(model.getUsername());
		googleAccountTextfield.setId("input");
		grid.add(googleAccountTextfield, 1, 1);
	}
	
	// set up the Password textfield
	private void setupPasswordTextfield(){
		Label pw = new Label("Password:");
		grid.add(pw, 0, 2);
		pwBox = new PasswordField();
		pwBox.setText(model.getPassword());
		grid.add(pwBox, 1, 2);
	}
	
	// set up the Password Retype textfield
	private void setupPasswordRetypeTextfield(){
		Label pwRetype = new Label("Retype password:");
		grid.add(pwRetype, 0, 3);
		pwRetypeBox = new PasswordField();
		pwRetypeBox.setText(model.getPassword());
		grid.add(pwRetypeBox, 1, 3);
	}
	
	/************************** sets up individual Buttons ****************************/
	/**
	 * This sets up the save button
	 * 
	 * @return saveButton
	 *            button to save user info
	 */
	private Button setupSaveButton() {
		Button saveButton = new Button("");
		saveButton.setId("save");
		saveButton.setPrefSize(76, 42);
		saveButton.setTranslateX(-95);
		saveButton.setOnMouseClicked(new EventHandler<MouseEvent>() {
			public void handle(MouseEvent e) {
				if (storeSettingChanges()) {
					settingsStage.close();
				}
			}
		});
		return saveButton;
	}

	/**
	 * This sets up the exit button
	 * 
	 * @return cancelButton
	 *            button to exit
	 */
	private Button setupExitButton() {
		Button exitButton = new Button("");
		exitButton.setId("esc");
		exitButton.setPrefSize(42, 42);
		exitButton.setOnMouseClicked(new EventHandler<MouseEvent>() {
			public void handle(MouseEvent e) {
				settingsStage.close();
			}
		});
		return exitButton;
	}
}

	// End of segment: D:\CS2103 Proj\src\Settings.java





	/**
	 * origin: D:\CS2103 Proj\src\TestHistory.java
	 */

/**
 * 
 * HistoryTest class: This class tests the functionality of History class.
 * 
 */
public class TestHistory {

	@Test
	public void test() {
		History testHistory = new History();
		
		// boundary case where the user's first command is undo (no commands before that)
		assertEquals(false, testHistory.isUndoable());
		
		// boundary case where the user's first command is redo (no commands before that)
		assertEquals(false, testHistory.isRedoable());
		
		// boundary case where the user's first command is redo (no commands before that)
		assertEquals(false, testHistory.isAfterSearch());
		
		// valid case where a command was executed
		String[] addInfo = new String[] {"task", "", "", "", "", ""};
		AddCommand add = new AddCommand(addInfo, new Model(), 1);
		testHistory.updateCommand(add);
		assertEquals(true, testHistory.isUndoable());
		assertEquals(false, testHistory.isRedoable());
		
		// valid case where an undo command was executed
		testHistory.getPrevCommandForUndo();
		assertEquals(true, testHistory.isRedoable());
		
		// valid case where there is more than one command
		testHistory.getPrevCommandForRedo();
		testHistory.updateCommand(add, true);
		testHistory.getPrevCommandForUndo();
		assertEquals(true, testHistory.isUndoable());
		assertEquals(true, testHistory.isRedoable());	
		assertEquals(true, testHistory.isAfterSearch());	
	}

}

	// End of segment: D:\CS2103 Proj\src\TestHistory.java





	/**
	 * origin: D:\CS2103 Proj\src\View.java
	 */

	/**
	 * This function will show the login page for the user to input his Google
	 * account when he first uses the application. The user can choose to input
	 * his Google account or not.
	 */
	private void showLoginPage() {
		if (checkFirstTimeLogin()) {
			loginPage = Login.getInstanceLogin(model);
			loginPage.showLoginPage();
		}
	}

	// Check whether this is the first time user uses the application
	private boolean checkFirstTimeLogin() {
		return model.getUsername() == null;
	}

	/**
	 * This function is used to to setup the popup windows appearing when user
	 * type some specific commands. These popup windows comprise help window and
	 * setting window.
	 */
	private void setupPopupWindows() {
		setupHelpPage();
		setupSettingsPage();
	}

	// Setup the content of help window
	private void setupHelpPage() {
		helpPage = Help.getInstanceHelp(model);
	}

	// Process opening the help window
	public void showHelpPage() {
		Platform.runLater(new Runnable() {
			@Override
			public void run() {
				helpPage.showHelpPage();
			}
		});

	}

	// Setup the content of settings window
	private void setupSettingsPage() {
		settingsPage = Settings.getInstanceSettings(model);
	}

	// Process opening the settings window
	public void showSettingsPage(String checkUsernamePassword) {
		settingsPage.showSettingsPage(checkUsernamePassword);
	}
	
	// End of segment: D:\CS2103 Proj\src\View.java





	/**
	 * origin: D:\CS2103 Proj\src\View.java
	 */

	// Create the indicator whether the application is under syncing progress or
	// not
	private void createSyncProgressIndicator() {
		syncProgress = new ProgressIndicator();
		setSyncProgressVisible(false);
	}

	/**
	 * Set the visibility of the sync progress
	 * 
	 * @param isVisible
	 *            indicator whether to show or not
	 */
	public void setSyncProgressVisible(final boolean isVisible) {
		Platform.runLater(new Runnable() {
			@Override
			public void run() {
				syncProgress.setVisible(isVisible);
			}
		});
	}
	
	// End of segment: D:\CS2103 Proj\src\View.java





	/**
	 * origin: D:\CS2103 Proj\src\View.java
	 */

	/**
	 * Set the colour scheme for iDo
	 * 
	 * @param colourOption
	 *            the chosen colour option
	 */
	public void setColourScheme(String colourOption) {
		chooseDayScheme();

		if (colourOption.equals(Common.DAY_MODE)) {
			chooseDayScheme();
		} else if (colourOption.equals(Common.NIGHT_MODE)) {
			chooseNightScheme();
		} else if (colourOption.equals(GOLDFISH_COLOUR_THEME)) {
			chooseGoldfishScheme();
		} else if (colourOption.equals(BRIGHT_COLOUR_THEME)) {
			chooseBrightScheme();
		}
	}

	/*
	 * Choose the "Bright" scheme for the application
	 */
	private void chooseBrightScheme() {
		colourScheme = ColourPalette.brightScheme;
		colourSchemeCommandLine = ColourPalette.brightSchemeSwing;
	}

	/*
	 * Choose the "Goldfish" scheme for the application
	 */
	private void chooseGoldfishScheme() {
		colourScheme = ColourPalette.goldfishScheme;
		colourSchemeCommandLine = ColourPalette.goldfishSchemeSwing;
	}

	/*
	 * Choose the "Default night" scheme for the application
	 */
	private void chooseNightScheme() {
		colourScheme = ColourPalette.defaultNightScheme;
		colourSchemeCommandLine = ColourPalette.defaultNightSchemeSwing;
	}

	/*
	 * Choose the "Default day" scheme for the application
	 */
	private void chooseDayScheme() {
		colourScheme = ColourPalette.defaultScheme;
		colourSchemeCommandLine = ColourPalette.defaultDaySchemeSwing;
	}

	
}

	// End of segment: D:\CS2103 Proj\src\View.java





