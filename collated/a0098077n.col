//@author: a0098077n



	/**
	 * origin: D:\CS2103 Proj\src\Command.java
	 */

/****************************************** Abstract Class Command ***************************/
public abstract class Command {
	protected static final String SPARSE_DAY_RECURRING_REGEX = "(every)\\s*(\\d+)\\s*(mondays?|tuesdays?|wednesdays?|thursdays?|fridays?|saturdays?|sundays?)";
	protected static final String FREQUENT_DAY_RECURRING_REGEX = "(every\\s*1?\\s*)(monday|tuesday|wednesday|thursday|friday|saturday|sunday)(\\s?)";
	protected static final String SPARSE_RECURRING_REGEX = "every\\s*\\d+\\s*(days?|weeks?|months?|years?)";
	protected static final String FREQUENT_RECURRING_REGEX = "(every\\s*1?\\s*)(day|week|month|year)(\\s?)";
	protected static final String OCCURRENCE_PATTERN = "(.*)(\\s+)(\\d+)(\\s+times?.*)";
	protected static final String HAVING_START_DATE = "having start date";
	protected static final String HAVING_END_DATE = "having end date";

	// Model containing lists of tasks to process
	protected Model model;
	// Current tab when the command is processed
	protected int tabIndex;

	public Command(Model model){
		this.model = model;
	}
	
	public Command(Model model, int tabIndex) {
		this.model = model;
		this.tabIndex = tabIndex;
	}

	// Abstract function executing command to be implemented in extended classes
	public abstract String execute();
	
	/**
	 * This function is used to get the corresponding search list basing on the
	 * current tab
	 * 
	 * @param tabIndex
	 *            the index of the current tab
	 * @return the corresponding search list
	 */
	protected ObservableList<Task> getSearchList(int tabIndex) {
		if (isPendingTab()) {
			return model.getSearchPendingList();
		} else if (isCompleteTab()) {
			return model.getSearchCompleteList();
		} else {
			return model.getSearchTrashList();
		}
	}
	
	/**
	 * This function is used to check for invalid dates from the task which the
	 * command is currently working on
	 * 
	 * @param isRepetitive
	 *            Indicator whether the task is a recurring task or not
	 * @param hasStartDate
	 *            Indicator whether the task has a start date
	 * @param hasEndDate
	 *            Indicator whether the task has an end date
	 * @param startDate
	 *            the start date of the task if it has
	 * @param endDate
	 *            the end date of the task if it has
	 * @param repeatingType
	 *            the type of repetition of the task if it is a recurring task
	 */
	protected void checkInvalidDates(boolean isRepetitive,
			boolean hasStartDate, boolean hasEndDate, CustomDate startDate,
			CustomDate endDate, String repeatingType) {
		boolean isTimedTask = hasStartDate && hasEndDate;
		if (isTimedTask) {
			boolean hasEndDateBeforeStartDate = CustomDate.compare(endDate, startDate) < 0;
			if (hasEndDateBeforeStartDate) {
				throw new IllegalArgumentException(Common.MESSAGE_INVALID_DATE_RANGE);
			}
		}
		
		if (isRepetitive && (!hasStartDate || !hasEndDate)) { // Recurring task without indicating dates
			throw new IllegalArgumentException(Common.MESSAGE_INVALID_START_END_DATES);
		}
		
		if (isRepetitive) { // recurring task
			checkDifference(startDate, endDate, repeatingType);
		}
	}
	
	/**
	 * This function is used to check whether the difference between start date
	 * and end date of a task is valid for the corresponding type of repetition
	 * 
	 * @param startDate
	 *            the start date of the task
	 * @param endDate
	 *            the end date of the task
	 * @param repeatingType
	 *            the type of repetition
	 */
	private void checkDifference(CustomDate startDate, CustomDate endDate,
			String repeatingType) {
		long expectedDifference = CustomDate
				.getUpdateDistance(repeatingType);
		long actualDifference = endDate.getTimeInMillis()
				- startDate.getTimeInMillis();
		if (actualDifference > expectedDifference) {
			throw new IllegalArgumentException(Common.MESSAGE_INVALID_TIME_REPETITIVE);
		}
	}
	
	/**
	 * This function is used to modify the end date of the task the command is
	 * currently working on to be suitable to the standard in the application
	 * 
	 * @param startDate
	 *            the start date of the task
	 * @param endDate
	 *            the end date of the task
	 */
	protected void updateTimeForEndDate(CustomDate startDate, CustomDate endDate){
		boolean isMidnight = endDate != null && endDate.getHour() == 0
				&& endDate.getMinute() == 0;
		if (isMidnight) {
			endDate.setHour(23);
			endDate.setMinute(59);
		}
		
		boolean hasNoIndicatedDate = endDate.hasIndicatedDate() == false
				&& startDate != null;
		if (hasNoIndicatedDate) {
			endDate.setYear(startDate.getYear());
			endDate.setMonth(startDate.getMonth());
			endDate.setDate(startDate.getDate());
		}
	}
	
	// Check if the current tab is pending tab
	protected boolean isPendingTab(){
		return tabIndex == Common.PENDING_TAB;
	}
	
	// Check if the current tab is complete tab
	protected boolean isCompleteTab(){
		return tabIndex == Common.COMPLETE_TAB;
	}
	
	// Check if the current tab is trash tab
	protected boolean isTrashTab(){
		return tabIndex == Common.TRASH_TAB;
	}
	
	/**
	 * This function is used to get the modified list basing on the current tab
	 * @param tabIndex the index of the current tab
	 * @return the corresponding list
	 */
	protected ObservableList<Task> getModifiedList(int tabIndex){
		if (isPendingTab()) {
			return model.getPendingList();
		} else if (isCompleteTab()) {
			return model.getCompleteList();
		} else {
			return model.getTrashList();
		}
	}
	
	// End of segment: D:\CS2103 Proj\src\Command.java





	/**
	 * origin: D:\CS2103 Proj\src\Command.java
	 */

/****************************************************************************************
 * Abstract class TwoWayCommand extended from class Command to support undo and redo	*
 *																						*
 ****************************************************************************************/

abstract class TwoWayCommand extends Command {
	protected static final boolean SEARCHED = true;
	protected static final boolean SHOWN = false;
	protected static final int INVALID = -1;
	
	// The current type of index in the list, whether it is the original or the results from search
	protected static boolean listedIndexType;
	// The modified list that the command will work on
	protected ObservableList<Task> modifiedList;

	public TwoWayCommand(Model model, int tabIndex) {
		super(model, tabIndex);
	}
	
	// Abstract function undoing command to be implemented in extended classes
	public abstract String undo();
	// Abstract function redoing command to be implemented in extended classes
	public abstract String redo();
	
	// End of segment: D:\CS2103 Proj\src\Command.java





	/**
	 * origin: D:\CS2103 Proj\src\Command.java
	 */

/************************************************************************************************************
 * Abstract class IndexCommand extended from class TwoWayCommand to work more specifically on indices		*
 *																											*
 ************************************************************************************************************/
abstract class IndexCommand extends TwoWayCommand{
	// The list of indices which the command will work on
	protected int[] indexList;
	// The number of indices
	protected int indexCount;
	
	public IndexCommand(Model model, int tabIndex){
		super(model, tabIndex);
	}
	
	/**
	 * This function is used to check if the list of indices is valid or not
	 */
	protected void checkValidIndexes(){
		for (int i = 0; i < indexCount - 1; i++) {
			if (indexList[i] == indexList[i + 1]) {
				throw new IllegalArgumentException(Common.MESSAGE_DUPLICATE_INDEXES);
			}
		}
		
		int MAX_INDEX = indexCount - 1;
		int MIN_INDEX = 0;
		
		if (convertIndex(indexList[MAX_INDEX] - 1) == INVALID
				|| convertIndex(indexList[MIN_INDEX] - 1) == INVALID) {
			throw new IllegalArgumentException(Common.MESSAGE_INDEX_OUT_OF_BOUNDS);
		}
	}
	
	/**
	 * This function is used to get list of indices
	 * @param parsedUserCommand
	 */
	protected void getListOfIndices(String[] parsedUserCommand) {
		indexList = new int[indexCount];
		for (int i = 0; i < indexCount; i++) {
			indexList[i] = Integer.valueOf(parsedUserCommand[i]);
		}
	}
}

	// End of segment: D:\CS2103 Proj\src\Command.java





	/**
	 * origin: D:\CS2103 Proj\src\Command.java
	 */

	/**
	 * Redo the ADD command
	 */
	public String redo(){
		model.addTaskToPending(createdTask);
		createdTask.setStatus(Task.Status.NEWLY_ADDED);
		Common.sortList(model.getPendingList());
		return Common.MESSAGE_SUCCESSFUL_REDO;
	}
	
	// End of segment: D:\CS2103 Proj\src\Command.java





	/**
	 * origin: D:\CS2103 Proj\src\Command.java
	 */

	/**
	 * Determine the target date info from the command input
	 * 
	 * @param hasRepetitiveKey
	 *            indicator whether the command has a new repetitive key
	 * @param hasWorkInfoKey
	 *            indicator whether the command has a new work info key
	 * @param hasStartDateKey
	 *            indicator whether the command has a new start date key
	 * @param hasEndDateKey
	 *            indicator whether the command has a new end date key
	 */
	private void determineDateInfoOfTargetTask(boolean hasRepetitiveKey,
			boolean hasWorkInfoKey, boolean hasStartDateKey,
			boolean hasEndDateKey) {
		if (!hasRepetitiveKey && !hasWorkInfoKey) {
			repeatingType = editedTask.getTag().getRepetition();
		}
		
		if (hasStartDateKey) {
			startDate = new CustomDate(startDateString);
		} else {
			startDate = editedTask.getStartDate();
		}
		
		if (hasEndDateKey) {
			endDate = new CustomDate(endDateString);
			updateTimeForEndDate(startDate, endDate);
		} else {
			endDate = editedTask.getEndDate();
		}
		
		if(hasStartDateKey || hasEndDateKey || hasRepetitiveKey){
			editedTask.setCurrentOccurrence(1);
		} 
		
		if(hasRepetitiveKey){
			editedTask.setNumOccurrences(0);
		}
		if(hasWorkInfoKey){
			editedTask.setNumOccurrences(0);
			editedTask.setCurrentOccurrence(1);
		}
	}
	
	/**
	 * This function is used to modify the tag for the editedTask
	 */
	private void setTag() {
		if (!tag.equals(Common.NULL)) {
			editedTask.setTag(new Tag(tag, repeatingType));
			if (tag.equals(Common.HASH_TAG)) {
				editedTask.getTag().setTag(Common.HYPHEN);
			}
		} else {
			editedTask.setTag(new Tag(editedTask.getTag().getTag(), repeatingType));
		}
	}
	
	// End of segment: D:\CS2103 Proj\src\Command.java





	/**
	 * origin: D:\CS2103 Proj\src\Command.java
	 */

	/**
	 * Redo EDIT command
	 */
	public String redo() {
		editedTask.setIsImportant(targetTask.isImportantTask());
		editedTask.setStartDate(targetTask.getStartDate());
		editedTask.setEndDate(targetTask.getEndDate());
		editedTask.setStartDateString(targetTask.getStartDateString());
		editedTask.setEndDateString(targetTask.getEndDateString());
		editedTask.setWorkInfo(targetTask.getWorkInfo());
		editedTask.setTag(targetTask.getTag());
		editedTask.setIndexId(targetTask.getIndexId());
		editedTask.setLatestModifiedDate(targetTask.getLatestModifiedDate());
		editedTask.setOccurrence(targetTask.getNumOccurrences(), targetTask.getCurrentOccurrence());
		editedTask.updateLatestModifiedDate();
		Common.sortList(modifiedList);
		
		return Common.MESSAGE_SUCCESSFUL_REDO;
	}
}

/*****************************Subclass of IndexCommand************************************************/
	// End of segment: D:\CS2103 Proj\src\Command.java





	/**
	 * origin: D:\CS2103 Proj\src\Command.java
	 */

	/**
	 * Redo the REMOVE command
	 */
	public String redo(){
		processRemove();
		sortInvolvedLists();

		return Common.MESSAGE_SUCCESSFUL_REDO;
	}
	
	/**
	 * This function is used to modify the status of a task when the a certain
	 * command is working on it
	 * 
	 * @param modifiedTask
	 *            the task which will have it status changed
	 */
	protected void modifyStatus(Task modifiedTask){
		if (isPendingTab() && modifiedTask.hasNewlyAddedStatus()) {
			modifiedTask.setStatus(Task.Status.UNCHANGED);
		} else if (isPendingTab() && modifiedTask.hasUnchangedStatus()) {
			modifyStatusForUnchangedTask(modifiedTask);
		}
	}

	private void modifyStatusForUnchangedTask(Task modifiedTask) {
		if (Control.syncThread == null || !Control.syncThread.isRunning()) {
			modifiedTask.setStatus(Task.Status.DELETED);
		} else {
			modifiedTask.setStatus(Task.Status.DELETED_WHEN_SYNC);
		}
	}
	
	/**
	 * This function is used to reverse the status of a task when a certain
	 * command is working on it
	 * 
	 * @param reversedTask
	 *            the task which will have its status reversed
	 */
	protected void reverseStatus(Task reversedTask){
		if (isPendingTab() && reversedTask.hasUnchangedStatus()) {
			reverseStatusForUnchangedTask(reversedTask);
		} else if (isPendingTab() && reversedTask.hasDeletedStatus()) {
			reversedTask.setStatus(Task.Status.UNCHANGED);
		}
	}

	private void reverseStatusForUnchangedTask(Task reversedTask) {
		if (Control.syncThread == null || !Control.syncThread.isRunning()) {
			reversedTask.setStatus(Task.Status.NEWLY_ADDED);
		} else {
			reversedTask.setStatus(Task.Status.ADDED_WHEN_SYNC);
		}
	}
}

	// End of segment: D:\CS2103 Proj\src\Command.java





	/**
	 * origin: D:\CS2103 Proj\src\Command.java
	 */

	/**
	 * Redo CLEAR command
	 */
	public String redo(){
		processClear();
		return Common.MESSAGE_SUCCESSFUL_REDO;
	}
	
	/**
	 * This function is used to modify the status of a task when the a certain
	 * command is working on it
	 * 
	 * @param modifiedTask
	 *            the task which will have it status changed
	 */
	protected void modifyStatus(Task modifiedTask){
		if (isPendingTab() && modifiedTask.hasNewlyAddedStatus()) {
			modifiedTask.setStatus(Task.Status.UNCHANGED);
		} else if (isPendingTab() && modifiedTask.hasUnchangedStatus()) {
			modifyStatusForUnchangedTask(modifiedTask);
		}
	}

	private void modifyStatusForUnchangedTask(Task modifiedTask) {
		if (Control.syncThread == null || !Control.syncThread.isRunning()) {
			modifiedTask.setStatus(Task.Status.DELETED);
		} else {
			modifiedTask.setStatus(Task.Status.DELETED_WHEN_SYNC);
		}
	}
	
	/**
	 * This function is used to reverse the status of a task when a certain
	 * command is working on it
	 * 
	 * @param reversedTask
	 *            the task which will have its status reversed
	 */
	protected void reverseStatus(Task reversedTask){
		if (isPendingTab() && reversedTask.hasUnchangedStatus()) {
			reverseStatusForUnchangedTask(reversedTask);
		} else if (isPendingTab() && reversedTask.hasDeletedStatus()) {
			reversedTask.setStatus(Task.Status.UNCHANGED);
		}
	}

	private void reverseStatusForUnchangedTask(Task reversedTask) {
		if (Control.syncThread == null || !Control.syncThread.isRunning()) {
			reversedTask.setStatus(Task.Status.NEWLY_ADDED);
		} else {
			reversedTask.setStatus(Task.Status.ADDED_WHEN_SYNC);
		}
	}
}

	// End of segment: D:\CS2103 Proj\src\Command.java





	/**
	 * origin: D:\CS2103 Proj\src\Command.java
	 */

	/**
	 * Sort the 2 lists which are involved in this process
	 */
	private void sortInvolvedLists() {
		Common.sortList(model.getPendingList());
		Common.sortList(model.getCompleteList());
	}
	
	// End of segment: D:\CS2103 Proj\src\Command.java





	/**
	 * origin: D:\CS2103 Proj\src\Command.java
	 */

	/**
	 * Check whether the current tab is suitable for the COMPLETE command
	 */
	private void checkSuitableTab(){
		if (tabIndex != Common.PENDING_TAB) {
			throw new IllegalArgumentException(Common.MESSAGE_WRONG_COMPLETE_TABS);
		}
	}
	
	// End of segment: D:\CS2103 Proj\src\Command.java





	/**
	 * origin: D:\CS2103 Proj\src\Command.java
	 */

	/**
	 * Redo COMPLETE command
	 */
	public String redo(){
		processComplete();
		retrieveIndexesAfterProcessing();

		return Common.MESSAGE_SUCCESSFUL_REDO;
	}
	
	/**
	 * This function is used to modify the status of a task when the a certain
	 * command is working on it
	 * 
	 * @param modifiedTask
	 *            the task which will have it status changed
	 */
	protected void modifyStatus(Task modifiedTask){
		if (isPendingTab() && modifiedTask.hasNewlyAddedStatus()) {
			modifiedTask.setStatus(Task.Status.UNCHANGED);
		} else if (isPendingTab() && modifiedTask.hasUnchangedStatus()) {
			modifyStatusForUnchangedTask(modifiedTask);
		}
	}

	private void modifyStatusForUnchangedTask(Task modifiedTask) {
		if (Control.syncThread == null || !Control.syncThread.isRunning()) {
			modifiedTask.setStatus(Task.Status.DELETED);
		} else {
			modifiedTask.setStatus(Task.Status.DELETED_WHEN_SYNC);
		}
	}
	
	/**
	 * This function is used to reverse the status of a task when a certain
	 * command is working on it
	 * 
	 * @param reversedTask
	 *            the task which will have its status reversed
	 */
	protected void reverseStatus(Task reversedTask){
		if (isPendingTab() && reversedTask.hasUnchangedStatus()) {
			reverseStatusForUnchangedTask(reversedTask);
		} else if (isPendingTab() && reversedTask.hasDeletedStatus()) {
			reversedTask.setStatus(Task.Status.UNCHANGED);
		}
	}

	private void reverseStatusForUnchangedTask(Task reversedTask) {
		if (Control.syncThread == null || !Control.syncThread.isRunning()) {
			reversedTask.setStatus(Task.Status.NEWLY_ADDED);
		} else {
			reversedTask.setStatus(Task.Status.ADDED_WHEN_SYNC);
		}
	}
}

	// End of segment: D:\CS2103 Proj\src\Command.java





	/**
	 * origin: D:\CS2103 Proj\src\Command.java
	 */

	/**
	 * This function is used to sort the involved lists in the process
	 */
	private void sortInvolvedLists() {
		Common.sortList(model.getPendingList());
		Common.sortList(model.getCompleteList());
	}
	
	// End of segment: D:\CS2103 Proj\src\Command.java





	/**
	 * origin: D:\CS2103 Proj\src\Command.java
	 */

	/**
	 * Check whether the current tab is suitable for executing INCOMPLETE commmand
	 */
	private void checkSuitableTab(){
		if (tabIndex != Common.COMPLETE_TAB) {
			throw new IllegalArgumentException(Common.MESSAGE_WRONG_INCOMPLETE_TABS);
		}
	}
	
	// End of segment: D:\CS2103 Proj\src\Command.java





	/**
	 * origin: D:\CS2103 Proj\src\Command.java
	 */

	/**
	 * Redo for INCOMPLETE command
	 */
	public String redo(){
		processIncomplete();
		retrieveIndexesAfterProcessing();
		
		return Common.MESSAGE_SUCCESSFUL_REDO;
	}
	
	/**
	 * This function is used to modify the status of a task when the a certain
	 * command is working on it
	 * 
	 * @param modifiedTask
	 *            the task which will have it status changed
	 */
	protected void modifyStatus(Task modifiedTask){
		if (isCompleteTab() && modifiedTask.hasUnchangedStatus()) {
			modifyStatusForUnchangedTask(modifiedTask);
		} else if (isCompleteTab() && modifiedTask.hasDeletedStatus()) {
			modifiedTask.setStatus(Task.Status.UNCHANGED);
		}
	}

	private void modifyStatusForUnchangedTask(Task modifiedTask) {
		if (Control.syncThread == null || !Control.syncThread.isRunning()) {
			modifiedTask.setStatus(Task.Status.NEWLY_ADDED);
		} else {
			modifiedTask.setStatus(Task.Status.ADDED_WHEN_SYNC);
		}
	}
	
	/**
	 * This function is used to reverse the status of a task when a certain
	 * command is working on it
	 * 
	 * @param reversedTask
	 *            the task which will have its status reversed
	 */
	protected void reverseStatus(Task reversedTask){
		if (isCompleteTab() && reversedTask.hasNewlyAddedStatus()) {
			reversedTask.setStatus(Task.Status.UNCHANGED);
		} else if (isCompleteTab() && reversedTask.hasUnchangedStatus()) {
			reverseStatusForUnchangedTask(reversedTask);
		}
	}

	private void reverseStatusForUnchangedTask(Task reversedTask) {
		if (Control.syncThread == null || !Control.syncThread.isRunning()) {
			reversedTask.setStatus(Task.Status.DELETED);
		} else {
			reversedTask.setStatus(Task.Status.DELETED_WHEN_SYNC);
		}
	}
}

	// End of segment: D:\CS2103 Proj\src\Command.java





	/**
	 * origin: D:\CS2103 Proj\src\Command.java
	 */

/**
 * 
 * Class RecoverCommand. This class executes command to recover tasks in trash list.
 * 
 */
class RecoverCommand extends IndexCommand {
	// List of tasks to be recovered
	private Task[] toRecoverTasks;
	// Indices of these tasks in the pending list
	private int[] indexInPendingList;

	/**
	 * Constructor of this class
	 * 
	 * @param parsedUserCommand
	 *            array of indices from the command parsed by Parser class
	 * @param model
	 *            model of tasks in the application
	 * @param tabIndex
	 *            the current tab
	 */
	public RecoverCommand(String[] parsedUserCommand, Model model,
			int tabIndex) {
		super(model, tabIndex);
		assert parsedUserCommand != null;
		modifiedList = this.model.getTrashList();
		indexCount = parsedUserCommand.length;
		indexInPendingList = new int[indexCount];
		toRecoverTasks = new Task[indexCount];

		getListOfIndices(parsedUserCommand);
	}
	
	/**
	 * Execute RECOVER command
	 */
	public String execute() {
		Arrays.sort(indexList);
		checkSuitableTab();
		checkValidIndexes();
		processRecover();
		retrieveIndexesAfterProcessing();
		
		return Common.MESSAGE_SUCCESSFUL_RECOVER;
	}
	
	/**
	 * This is the main function for recovering process
	 */
	private void processRecover(){
		for (int i = indexCount - 1; i >= 0; i--) {
			int recoverIndex = convertIndex(indexList[i] - 1);
			Task toPending = model.getTaskFromTrash(recoverIndex);
			modifyStatus(toPending);
			toRecoverTasks[i] = toPending;
			model.getTrashList().remove(recoverIndex);
			model.addTaskToPending(toPending);
		}
		sortInvolvedLists();
	}
	
	/**
	 * This function is used to sort involved lists in the process
	 */
	private void sortInvolvedLists() {
		Common.sortList(model.getPendingList());
		Common.sortList(model.getTrashList());
	}
	
	/**
	 * This function is used to get the indices of these tasks in pending list after processing
	 */
	private void retrieveIndexesAfterProcessing(){
		for (int i = 0; i < indexCount; i++) {
			indexInPendingList[i] = model
					.getIndexFromPending(toRecoverTasks[i]);
		}
		Arrays.sort(indexInPendingList);
	}
	
	/**
	 * Check whether the current tab is suitable for executing RECOVER command
	 */
	private void checkSuitableTab(){
		if (tabIndex != Common.TRASH_TAB) {
			throw new IllegalArgumentException(Common.MESSAGE_WRONG_RECOVER_TABS);
		}
	}
	
	/**
	 * Undo the RECOVER command
	 */
	public String undo() {
		for (int i = indexCount - 1; i >= 0; i--) {
			Task toTrash = model.getTaskFromPending(indexInPendingList[i]);
			reverseStatus(toTrash);
			toRecoverTasks[i] = toTrash;
			model.getPendingList().remove(indexInPendingList[i]);
			model.addTaskToTrash(toTrash);
		}
		sortInvolvedLists();

		return Common.MESSAGE_SUCCESSFUL_UNDO;
	}
	
	/** 
	 * Redo the RECOVER command
	 */
	public String redo(){
		processRecover();
		retrieveIndexesAfterProcessing();
		
		return Common.MESSAGE_SUCCESSFUL_REDO;
	}
	
	/**
	 * This function is used to modify the status of a task when the a certain
	 * command is working on it
	 * 
	 * @param modifiedTask
	 *            the task which will have it status changed
	 */
	protected void modifyStatus(Task modifiedTask){
		if (isTrashTab() && modifiedTask.hasUnchangedStatus()) {
			modifyStatusForUnchangedTask(modifiedTask);
		} else if (isTrashTab() && modifiedTask.hasDeletedStatus()) {
			modifiedTask.setStatus(Task.Status.UNCHANGED);
		}
	}

	private void modifyStatusForUnchangedTask(Task modifiedTask) {
		if (Control.syncThread == null || !Control.syncThread.isRunning()) {
			modifiedTask.setStatus(Task.Status.NEWLY_ADDED);
		} else {
			modifiedTask.setStatus(Task.Status.ADDED_WHEN_SYNC);
		}
	}
	
	/**
	 * This function is used to reverse the status of a task when a certain
	 * command is working on it
	 * 
	 * @param reversedTask
	 *            the task which will have its status reversed
	 */
	protected void reverseStatus(Task reversedTask){
		if (isTrashTab() && reversedTask.hasNewlyAddedStatus()) {
			reversedTask.setStatus(Task.Status.UNCHANGED);
		} else if (isTrashTab() && reversedTask.hasUnchangedStatus()) {
			reverseStatusForUnchangedTask(reversedTask);
		}
	}

	private void reverseStatusForUnchangedTask(Task reversedTask) {
		if (Control.syncThread == null || !Control.syncThread.isRunning()) {
			reversedTask.setStatus(Task.Status.DELETED);
		} else {
			reversedTask.setStatus(Task.Status.DELETED_WHEN_SYNC);
		}
	}
}

	// End of segment: D:\CS2103 Proj\src\Command.java





	/**
	 * origin: D:\CS2103 Proj\src\Command.java
	 */

	/**
	 * Redo MARK command
	 */
	public String redo(){
		for (int i = 0; i < indexCount; i++) {
			int markIndex = convertIndex(indexList[i] - 1);
			Task targetTask = modifiedList.get(markIndex);
			targetTask.setIsImportant(true);
			targetTask.updateLatestModifiedDate();
		}

		return Common.MESSAGE_SUCCESSFUL_REDO;
	}
}

	// End of segment: D:\CS2103 Proj\src\Command.java





	/**
	 * origin: D:\CS2103 Proj\src\Command.java
	 */

	/**
	 * Redo UNMARK command
	 */
	public String redo(){
		for (int i = 0; i < indexCount; i++) {
			int unmarkIndex = convertIndex(indexList[i] - 1);
			Task targetTask = modifiedList.get(unmarkIndex);
			targetTask.setIsImportant(false);
			targetTask.updateLatestModifiedDate();
		}

		return Common.MESSAGE_SUCCESSFUL_REDO;
	}
}

	// End of segment: D:\CS2103 Proj\src\Command.java





	/**
	 * origin: D:\CS2103 Proj\src\Command.java
	 */

/**********************************Subclass of Command**********************************************/

/**
 * 
 * Class SearchCommand. This class executes command to search for list of tasks with required infos.
 * 
 */
class SearchCommand extends Command {
	// The searched work info
	private String workInfo;
	// The searched tag
	private String tag;
	// The searched start date string
	private String startDateString;
	// The searched end date string
	private String endDateString;
	// The searched repeating type
	private String repeatingType;
	private int numOccurrences = 0;
	// Search for important task
	private String isImpt;
	// The main interface of the application
	private View view;
	// The initial list for searching
	private ObservableList<Task> initialList;
	// The latest list of searched results
	private ObservableList<Task> searchList;
	// The searched start and end dates
	private CustomDate startDate, endDate;
	// Indicator if this is the first field searched
	private boolean isFirstTimeSearch;
	// Indicator if this is currently under real time search
	private boolean isRealTimeSearch;
	
	/**
	 * 
	 * @param parsedUserCommand
	 * @param model
	 * @param view
	 * @param isRealTimeSearch
	 */
	public SearchCommand(String[] parsedUserCommand, Model model, View view, boolean isRealTimeSearch) {
		super(model, view.getTabIndex());
		assert parsedUserCommand != null;
		this.view = view;
		this.isRealTimeSearch = isRealTimeSearch;
		
		workInfo = parsedUserCommand[0];
		tag = parsedUserCommand[1];
		startDateString = parsedUserCommand[2];
		endDateString = parsedUserCommand[3];
		isImpt = parsedUserCommand[4];
		repeatingType = parsedUserCommand[5];
		splitRepeatingInfo();
		
		initialList = getModifiedList(tabIndex);
		searchList = FXCollections.observableArrayList();
		
		isFirstTimeSearch = true;
	}
	
	/**
	 * Execute the SEARCH command
	 */
	public String execute() {
		processSearch();
		if (!isRealTimeSearch && searchList.isEmpty()) {
			return Common.MESSAGE_NO_RESULTS;
		}
		TwoWayCommand.setIndexType(TwoWayCommand.SEARCHED);
		updateSearchResults();
		return Common.MESSAGE_SUCCESSFUL_SEARCH;
	}
	
	/** 
	 * This function is used to update the search results on the GUI
	 */
	private void updateSearchResults() {
		if (isPendingTab()) {
			model.setSearchPendingList(searchList);
			view.getPendingTable().setItems(model.getSearchPendingList());
		} else if (isCompleteTab()) {
			model.setSearchCompleteList(searchList);
			view.getCompleteTable().setItems(model.getSearchCompleteList());
		} else {
			model.setSearchTrashList(searchList);
			view.getTrashTable().setItems(model.getSearchTrashList());
		}
	}
	
	/**
	 * This is the main function for searching process
	 */
	public void processSearch() {
		processWorkInfo();
		processTag();
		processStartDate();
		processEndDate();
		processIsImportant();
		processRepeatingType();
		processNumOccurrences();
	}
	
	/**
	 * This function is used to determine the type of repetition and number of
	 * occurrences for search info
	 */
	private void splitRepeatingInfo() {
		setOccurrences();
		repeatingType = setRepeatingType(repeatingType);
	}
	
	/**
	 * Set the searched number of occurrences
	 */
	private void setOccurrences() {
		if (repeatingType.matches(OCCURRENCE_PATTERN)) {
			int num = Integer.valueOf(repeatingType.replaceAll(
					OCCURRENCE_PATTERN, "$3"));
			numOccurrences = num;
			repeatingType = repeatingType.replaceAll(OCCURRENCE_PATTERN, "$1");
		} else {
			numOccurrences = 0;
		}
	}
	
	// Process searching for start date
	private void processStartDate() {
		if (!startDateString.equals(Common.NULL)) {
			startDate = new CustomDate(startDateString);
			if (isFirstTimeSearch) {
				searchList = searchStartDate(initialList, startDate);
			} else {
				searchList = searchStartDate(searchList, startDate);
			}
			isFirstTimeSearch = false;
		}
	}
	
	// Process searching for end date
	private void processEndDate() {
		if (!endDateString.equals(Common.NULL)) {
			endDate = new CustomDate(endDateString);
			if (startDate != null && endDate.hasIndicatedDate() == false) {
				endDate.setYear(startDate.getYear());
				endDate.setMonth(startDate.getMonth());
				endDate.setDate(startDate.getDate());
			}
			if (isFirstTimeSearch) {
				searchList = searchEndDate(initialList, endDate);
			} else {
				searchList = searchEndDate(searchList, endDate);
			}

			isFirstTimeSearch = false;
		}
	}
	
	//Process searching for important task
	private void processIsImportant(){
		if (isImpt.equals(Common.TRUE)) {
			if (isFirstTimeSearch) {
				searchList = searchImportantTask(initialList);
			} else {
				searchList = searchImportantTask(searchList);
			}
			isFirstTimeSearch = false;
		}
	}
	
	// Process searching for number of occurrences
	private void processNumOccurrences(){
		if (numOccurrences != 0) {
			if (isFirstTimeSearch) {
				searchList = searchOccurrenceNum(initialList, numOccurrences);
			} else {
				searchList = searchOccurrenceNum(searchList, numOccurrences);
			}
			isFirstTimeSearch = false;
		}
	}
	
	// Process searching for type of repetition
	private void processRepeatingType(){
		if (!repeatingType.equals(Common.NULL)) {
			if (isFirstTimeSearch) {
				searchList = searchRepeatingType(initialList, repeatingType);
			} else {
				searchList = searchRepeatingType(searchList, repeatingType);
			}
			isFirstTimeSearch = false;
		}
	}
	
	// Process searching for tag
	private void processTag(){
		if (!tag.equals(Common.NULL)) {
			if (isFirstTimeSearch) {
				searchList = searchTag(initialList, tag);
			} else {
				searchList = searchTag(searchList, tag);
			}
			isFirstTimeSearch = false;
		}
	}
	
	// Process searching for task info
	private void processWorkInfo(){
		if (!workInfo.equals(Common.NULL)) {
			if (isFirstTimeSearch) {
				searchList = searchWorkInfo(initialList, workInfo);
			} else {
				searchList = searchWorkInfo(searchList, workInfo);
			}
			isFirstTimeSearch = false;
		}
	}
	
	/**
	 * This function is used to return the results of task with requested number
	 * of occurrences
	 * 
	 * @param list
	 *            the searched list
	 * @param occurNum
	 *            the request number of occurences
	 * @return the result list
	 */
	private static ObservableList<Task> searchOccurrenceNum(ObservableList<Task> list, int occurNum) {
		ObservableList<Task> result = FXCollections.observableArrayList();
		for (int i = 0; i < list.size(); i++) {
			if (list.get(i).getNumOccurrences() == occurNum) {
				result.add(list.get(i));
			}
		}
		return result;
	}
	
	/**
	 * This function is used to return the results of important tasks
	 * 
	 * @param list
	 *            the searched list
	 * @return the result list
	 */
	private static ObservableList<Task> searchImportantTask(
			ObservableList<Task> list) {
		ObservableList<Task> result = FXCollections.observableArrayList();
		for (int i = 0; i < list.size(); i++) {
			if (list.get(i).isImportantTask()) {
				result.add(list.get(i));
			}
		}
		return result;
	}

	/**
	 * This function is used to return the results of task with requested tag
	 * 
	 * @param list
	 *            the searched list
	 * @param tagName
	 *            the requested tag
	 * @return the result list
	 */
	private static ObservableList<Task> searchTag(ObservableList<Task> list,
			String tagName) {
		ObservableList<Task> result = FXCollections.observableArrayList();
		for (int i = 0; i < list.size(); i++) {
			String tag = list.get(i).getTag().getTag();
			if (tag.toLowerCase().contains(tagName.toLowerCase())) {
				result.add(list.get(i));
			}
		}
		return result;
	}
	
	/**
	 * This function is used to return the results of task with requested type
	 * of repetition
	 * 
	 * @param list
	 *            the searched list
	 * @param repeatingType
	 *            the requested type of repetition
	 * @return the result list
	 */
	private static ObservableList<Task> searchRepeatingType(
			ObservableList<Task> list, String repeatingType) {
		ObservableList<Task> result = FXCollections.observableArrayList();
		for (int i = 0; i < list.size(); i++) {
			String repetition = list.get(i).getTag().getRepetition();
			if (repetition.equalsIgnoreCase(repeatingType)) {
				result.add(list.get(i));
			}
		}
		return result;
	}
	
	/**
	 * This function is used to return the results of task with requested start
	 * date
	 * 
	 * @param list
	 *            the searched list
	 * @param date
	 *            the requested date
	 * @return the result list
	 */
	private static ObservableList<Task> searchStartDate(
			ObservableList<Task> list, CustomDate date) {
		ObservableList<Task> result = FXCollections.observableArrayList();
		boolean hasIndicatedTime = date.getHour() != 0 || date.getMinute() != 0;
		if (hasIndicatedTime) {
			searchAtTimeLevelForStartDate(list, date, result);
		} else {
			searchAtDateLevelForStartDate(list, date, result);
		}
		return result;
	}
	
	// Search by comparing time
	private static void searchAtDateLevelForStartDate(
			ObservableList<Task> list, CustomDate date,
			ObservableList<Task> result) {
		for (int i = 0; i < list.size(); i++) {
			CustomDate startDate = list.get(i).getStartDate();
			if (startDate != null && CustomDate.dateCompare(startDate, date) >= 0)
				result.add(list.get(i));
		}
	}
	
	// Search by just comparing date
	private static void searchAtTimeLevelForStartDate(
			ObservableList<Task> list, CustomDate date,
			ObservableList<Task> result) {
		for (int i = 0; i < list.size(); i++) {
			CustomDate startDate = list.get(i).getStartDate();
			if (startDate != null
					&& CustomDate.compare(startDate, date) >= 0) {
				result.add(list.get(i));
			}
		}
	}
	
	/**
	 * This function is used to return the results of tasks with requested end
	 * date
	 * 
	 * @param list
	 *            the searched list
	 * @param date
	 *            the requested date
	 * @return the result list
	 */
	private static ObservableList<Task> searchEndDate(ObservableList<Task> list,
			CustomDate date) {
		ObservableList<Task> result = FXCollections.observableArrayList();
		updateDateForEndDate(date);
		
		boolean hasIndicatedTime = date.getHour() != 23 && date.getMinute() != 59;
		if (hasIndicatedTime) {
			searchAtTimeLevelForEndDate(list, date, result);
		} else {
			searchAtDateLevelForEndDate(list, date, result);
		}
		return result;
	}

	// Search by comparing date
	private static void searchAtDateLevelForEndDate(ObservableList<Task> list,
			CustomDate date, ObservableList<Task> result) {
		for (int i = 0; i < list.size(); i++) {
			CustomDate endDate = list.get(i).getEndDate();
			if (endDate != null && CustomDate.dateCompare(endDate, date) <= 0) {
				result.add(list.get(i));
			}
		}
	}
	
	// Search by comparing time
	private static void searchAtTimeLevelForEndDate(ObservableList<Task> list,
			CustomDate date, ObservableList<Task> result) {
		for (int i = 0; i < list.size(); i++) {
			CustomDate endDate = list.get(i).getEndDate();
			if (endDate != null && CustomDate.compare(endDate, date) <= 0) {
				result.add(list.get(i));
			}
		}
	}
	
	// Update time for end date if it is midnight
	private static void updateDateForEndDate(CustomDate date) {
		boolean isMidnight = date.getHour() == 0 && date.getMinute() == 0;
		if (isMidnight) {
			date.setHour(23);
			date.setMinute(59);
		}
	}
	
	/**
	 * This function is used to return the results of task containing requested
	 * work info
	 * 
	 * @param list
	 *            the searched list
	 * @param workInfo
	 *            the requested work info
	 * @return the result list
	 */
	private static ObservableList<Task> searchWorkInfo(
			ObservableList<Task> list, String workInfo) {
		ObservableList<Task> result = FXCollections.observableArrayList();
		for (int i = 0; i < list.size(); i++) {
			String searchedWorkInfo = list.get(i).getWorkInfo().toLowerCase();
			String tag = list.get(i).getTag().getTag().toLowerCase().substring(1);
			if (searchedWorkInfo.contains(workInfo.toLowerCase()) || (!tag.equals("") && tag.contains(workInfo.toLowerCase()))) {
				result.add(list.get(i));
			}
		}
		return result;
	}
}

	// End of segment: D:\CS2103 Proj\src\Command.java





	/**
	 * origin: D:\CS2103 Proj\src\Command.java
	 */

/**
 * 
 * Class ShowAllCommand. This class executes command to show all tasks in the list
 * 
 */
class ShowAllCommand extends Command {
	// The main interface of the application
	private View view;
	
	/**
	 * Constructor
	 * 
	 * @param model
	 *            model of tasks in the application
	 * @param view
	 *            the interface of the application
	 */
	public ShowAllCommand(Model model, View view) {
		super(model, view.getTabIndex());
		this.view = view;
	}
	
	/**
	 * Execute SHOW command
	 */
	public String execute() {
		TwoWayCommand.setIndexType(TwoWayCommand.SHOWN);
		setContent();
		return Common.MESSAGE_SUCCESSFUL_SHOW_ALL;
	}
	
	/**
	 * Set the content of the corresponding list back to the full list of tasks
	 */
	private void setContent() {
		if (isPendingTab()) {
			view.getPendingTable().setItems(model.getPendingList());
		} else if (isCompleteTab()) {
			view.getCompleteTable().setItems(model.getCompleteList());
		} else {
			view.getTrashTable().setItems(model.getTrashList());
		}
	}
}

	// End of segment: D:\CS2103 Proj\src\Command.java





	/**
	 * origin: D:\CS2103 Proj\src\Command.java
	 */

/**
 * 
 * Class ExitCommand. This class executes command to exit the application
 * 
 */
class ExitCommand extends Command {
	/**
	 * Constructor of this class
	 * 
	 * @param model
	 *            model of tasks in the application
	 * @param tabIndex
	 *            the current tab
	 */
	public ExitCommand(Model model, int tabIndex) {
		super(model, tabIndex);
	}
	
	/**
	 * Execute EXIT command
	 */
	public String execute() {
		System.exit(0);
		return null;
	}
}

	// End of segment: D:\CS2103 Proj\src\Command.java





	/**
	 * origin: D:\CS2103 Proj\src\Control.java
	 */

	/**
	 * Main Function of the application
	 * @param args
	 */
	public static void main(String[] args) {
		Application.launch(args);
	}

	@Override
	public void start(final Stage primaryStage) {
		loadData();
		loadGUI(primaryStage);
		loadTimer();
	}
	
	// End of segment: D:\CS2103 Proj\src\Control.java





	/**
	 * origin: D:\CS2103 Proj\src\Control.java
	 */

	/**
	 * Initialize the graphical user interface of the application. Setup the
	 * listeners and key bindings in the interface
	 * 
	 * @param primaryStage
	 *            the main window of the application
	 */
	private void loadGUI(Stage primaryStage) {
		view = new View(model, primaryStage);
		addListenerForPreferences();
		handleEventForCommandLine();
		updateLastOverdueTasks();
		storeSettings();
	}
	
	
	/**
	 * Update the lines separating overdue tasks and ongoing tasks in all lists
	 */
	private void updateLastOverdueTasks() {
		updateOverdueLine(model.getPendingList());
		updateOverdueLine(model.getCompleteList());
		updateOverdueLine(model.getTrashList());
	}
	
	/**
	 * Setup handling for all necessary events for command line
	 */
	private void handleEventForCommandLine() {
		setupChangeListener();
		handleKeyEvent();
	}
	
	/**
	 * Setup the change listener in the command line
	 */
	private void setupChangeListener() {
		view.getCommandLine().getDocument().addDocumentListener(new DocumentListener() {
			@Override
			public void removeUpdate(DocumentEvent e) {
				realTimeUpdate();
			}

			@Override
			public void insertUpdate(DocumentEvent e) {
				realTimeUpdate();
			}

			@Override
			public void changedUpdate(DocumentEvent e) {
	
			}
			
			/**
			 * Real time update in the interface due to changes in the content of command line
			 */
			private void realTimeUpdate() {
				String command = view.getCommandLine().getText();
				update(command);
				checkValid(command);
			}
			
			/**
			 * The real time update including updating in the feedback and the
			 * results of searching
			 * 
			 * @param command
			 *            the current content in the command line
			 */
			private void update(String command) {
				realTimeFeedback(command);
				
				if (isSearchCommand(command)) {
					realTimeSearch(command);
				} else if (isValidIndexCommand(command)) {
					realTimeCommandExecution(command);
				}
			}
			
			/**
			 * Check whether this command is valid for real time search
			 * @param command current content in the command line
			 */
			private void checkValid(String command) {
				if (isInvalidRealTimeCommand(command)) {
					isRealTimeSearch = false;
					executeShowCommand();
				}
			}
			
			// Indicate if this is an invalid real time command and currently
			// under real time searched
			private boolean isValidIndexCommand(String command) {
				return isRemoveCommand(command) || isRecoverCommand(command)
						|| isMarkCommand(command) || isUnmarkCommand(command)
						|| isCompleteCommand(command)
						|| isIncompleteCommand(command);
			}

			private boolean isInvalidRealTimeCommand(String command) {
				return isRealTimeSearch && !isSearchCommand(command)
						&& !isValidIndexCommand(command);
			}

			private void realTimeCommandExecution(String command) {
				String content = Common.removeFirstWord(command);

				if (!content.matches("\\s*") && !content.matches("\\s*\\d+.*")) {
						realTimeSearch("search " + content);
				}
			}
			
			// Indicator whether this is a remove command
			private boolean isRemoveCommand(String command) {
				return Parser.determineCommandType(command) == Common.COMMAND_TYPES.REMOVE;
			}
			
			// Indicator whether this is a recover command
			private boolean isRecoverCommand(String command){
				return Parser.determineCommandType(command) == Common.COMMAND_TYPES.RECOVER;
			}
			
			// Indicator whether this is a mark command
			private boolean isMarkCommand(String command){
				return Parser.determineCommandType(command) == Common.COMMAND_TYPES.MARK;
			}
			
			// Indicator whether this is an unmark command
			private boolean isUnmarkCommand(String command){
				return Parser.determineCommandType(command) == Common.COMMAND_TYPES.UNMARK;
			}
			
			// Indicator whether this is a complete command
			private boolean isCompleteCommand(String command){
				return Parser.determineCommandType(command) == Common.COMMAND_TYPES.COMPLETE;
			}
			
			// Indicator whether this is an incomplete command
			private boolean isIncompleteCommand(String command){
				return Parser.determineCommandType(command) == Common.COMMAND_TYPES.INCOMPLETE;
			}
			
			// Indicator whether this is a search command
			private boolean isSearchCommand(String command) {
				return Parser.determineCommandType(command) == Common.COMMAND_TYPES.SEARCH;
			}
			
			/**
			 * This function check whether this command is an index command
			 * 
			 * @param command
			 *            content of the command line
			 * @return true if this command works with indices, vice versa
			 */
			private boolean isIndexCommand(String command) {
				String content = Common.removeFirstWord(command);
				String[] splitContent = Common.splitBySpace(content);
				String checkedIndex = splitContent[0];
				try {
					checkIndex(checkedIndex);
					return true;
				} catch (NumberFormatException e) {
					return false;
				}
			}
			
			// Process checking the index
			private void checkIndex(String checkedIndex) throws NumberFormatException {
				if(checkedIndex.contains(Common.HYPHEN)){
					checkRangeIndex(checkedIndex);
				} else{
					Integer.valueOf(checkedIndex);
				}
			}
			
			// Process checking specifically for the range of indices
			private void checkRangeIndex(String rangeIndex) throws NumberFormatException{
				String[] splitContent = rangeIndex.split(Common.HYPHEN);
				if(splitContent.length != 2)
					throw new NumberFormatException("Invalid range for index");
				Integer.parseInt(splitContent[0]);
				Integer.parseInt(splitContent[1]);
			}
			
			/**
			 * Setup the real time feedback or suggestion to users
			 * 
			 * @param command
			 *            content of the command line
			 */
			private void realTimeFeedback(String command) {
				if (Parser.checkEmptyCommand(command)) {
					view.setFeedback(Common.MESSAGE_REQUEST_COMMAND);
				} else {
					updateFeedback(command);
				}
			}
			
			/**
			 * Update the real time feedback according to type of the command
			 * 
			 * @param command
			 *            content of the command line
			 */
			private void updateFeedback(String command) {
				Common.COMMAND_TYPES commandType = Parser
						.determineCommandType(command);
				switch (commandType) {
				case ADD:
					view.setFeedback(Common.MESSAGE_ADD_TIP);
					break;
				case EDIT:
					view.setFeedback(Common.MESSAGE_EDIT_TIP);
					break;
				case REMOVE:
					setFeedbackForRemoveCommand(command);
					break;
				case RECOVER:
					setFeedbackForRecoverCommand(command);
					break;
				case SEARCH:
					view.setFeedback(Common.MESSAGE_SEARCH_TIP);
					break;
				case SHOW_ALL:
					view.setFeedback(Common.MESSAGE_SHOW_ALL_TIP);
					break;
				case UNDO:
					view.setFeedback(Common.MESSAGE_UNDO_TIP);
					break;
				case REDO:
					view.setFeedback(Common.MESSAGE_REDO_TIP);
					break;
				case MARK:
					setFeedbackForMarkCommand(command);
					break;
				case UNMARK:
					setFeedbackForUnmarkCommand(command);
					break;
				case COMPLETE:
					setFeedbackForCompleteCommand(command);
					break;
				case INCOMPLETE:
					setFeedbackForIncompleteCommand(command);
					break;
				case TODAY:
					view.setFeedback(Common.MESSAGE_TODAY_TIP);
					break;
				case CLEAR_ALL:
					view.setFeedback(Common.MESSAGE_CLEAR_ALL_TIP);
					break;
				case HELP:
					view.setFeedback(Common.MESSAGE_HELP_TIP);
					break;
				case SYNC:
					view.setFeedback(Common.MESSAGE_SYNC_TIP);
					break;
				case SETTINGS:
					view.setFeedback(Common.MESSAGE_SETTINGS_TIP);
					break;
				case EXIT:
					view.setFeedback(Common.MESSAGE_EXIT_TIP);
					break;
				case INVALID:
					view.setFeedback(command);
					break;
				}
			}

			private void setFeedbackForIncompleteCommand(String command) {
				if (isIndexCommand(command)) {
					view.setFeedback(Common.MESSAGE_INCOMPLETE_INDEX_TIP);
				} else {
					view.setFeedback(Common.MESSAGE_INCOMPLETE_INFO_TIP);
				}
			}

			private void setFeedbackForCompleteCommand(String command) {
				if (isIndexCommand(command)) {
					view.setFeedback(Common.MESSAGE_COMPLETE_INDEX_TIP);
				} else {
					view.setFeedback(Common.MESSAGE_COMPLETE_INFO_TIP);
				}
			}

			private void setFeedbackForUnmarkCommand(String command) {
				if (isIndexCommand(command)) {
					view.setFeedback(Common.MESSAGE_UNMARK_INDEX_TIP);
				} else {
					view.setFeedback(Common.MESSAGE_UNMARK_INFO_TIP);
				}
			}

			private void setFeedbackForMarkCommand(String command) {
				if (isIndexCommand(command)) {
					view.setFeedback(Common.MESSAGE_MARK_INDEX_TIP);
				} else {
					view.setFeedback(Common.MESSAGE_MARK_INFO_TIP);
				}
			}

			private void setFeedbackForRecoverCommand(String command) {
				if (isIndexCommand(command)) {
					view.setFeedback(Common.MESSAGE_RECOVER_INDEX_TIP);
				} else {
					view.setFeedback(Common.MESSAGE_RECOVER_INFO_TIP);
				}
			}

			private void setFeedbackForRemoveCommand(String command) {
				if (isIndexCommand(command)) {
					view.setFeedback(Common.MESSAGE_REMOVE_INDEX_TIP);
				} else {
					view.setFeedback(Common.MESSAGE_REMOVE_INFO_TIP);
				}
			}
		});
	}
	
	/**
	 * Setup handling key events executed in the interface
	 */
	private void handleKeyEvent() {
		setupHotkeys();
		setupKeyBindingsForCommandLine();
	}
	
	// Setup key bindings for the command line
	private void setupKeyBindingsForCommandLine() {
		InputMap map = view.getCommandLine().getInputMap();
		assert map != null;
		addKeyBindingForExecution(map);
		addKeyBindingForUndo(map);
		addKeyBindingForRedo(map);
		addKeyBidningForHelp(map);
	}
	
	// Setup the hot keys in the application
	private void setupHotkeys() {
		view.getMainRoot().setOnKeyPressed(new EventHandler<KeyEvent>() {
			public void handle(KeyEvent keyEvent) {
				if (Common.undo_hot_key.match(keyEvent)) {
					isRealTimeSearch = false;
					String feedback = executeCommand("undo");
					updateFeedback(feedback);
				} else if (Common.redo_hot_key.match(keyEvent)) {
					isRealTimeSearch = false;
					String feedback = executeCommand("redo");
					updateFeedback(feedback);
				} else if (keyEvent.getCode() == KeyCode.F1) {
					isRealTimeSearch = false;
					String feedback = executeCommand("help");
					updateFeedback(feedback);
				}
			}
		});
	}
	
	/*
	 * Key binding for ENTER
	 */
	@SuppressWarnings("serial")
	private void addKeyBindingForExecution(InputMap map) {
		Action enterAction = new AbstractAction() {
			@Override
			public void actionPerformed(java.awt.event.ActionEvent e) {
				Platform.runLater(new Runnable() {
					@Override
					public void run() {
						isRealTimeSearch = false;
						String feedback = executeCommand(view.getCommandLine().getText());
						updateFeedback(feedback);
					}
				});
			}
		};
		
		// Get KeyStroke for enter key
		KeyStroke enterKey = KeyStroke.getKeyStroke(
				com.sun.glass.events.KeyEvent.VK_ENTER, 0);
		// Override enter for a pane
		map.put(enterKey, enterAction);
	}
	
	/*
	 *  Key binding for Ctrl + Z
	 */
	@SuppressWarnings("serial")
	private void addKeyBindingForUndo(InputMap map) {
		Action undoAction = new AbstractAction() {
			@Override
			public void actionPerformed(ActionEvent e) {
				Platform.runLater(new Runnable() {
					@Override
					public void run() {
						isRealTimeSearch = false;
						String feedback = executeCommand("undo");
						updateFeedback(feedback);
					}
				});
			}
		};
		KeyStroke undoKey = KeyStroke.getKeyStroke(
				com.sun.glass.events.KeyEvent.VK_Z,
				java.awt.event.InputEvent.CTRL_DOWN_MASK);
		map.put(undoKey, undoAction);
	}	
	
	/*
	 * Key binding for Ctrl + Y
	 */
	@SuppressWarnings("serial")
	private void addKeyBindingForRedo(InputMap map) {
		Action redoAction = new AbstractAction() {
			@Override
			public void actionPerformed(ActionEvent e) {
				Platform.runLater(new Runnable() {
					@Override
					public void run() {
						isRealTimeSearch = false;
						String feedback = executeCommand("redo");
						updateFeedback(feedback);
					}
				});
			}
		};
		KeyStroke redoKey = KeyStroke.getKeyStroke(
				com.sun.glass.events.KeyEvent.VK_Y,
				java.awt.event.InputEvent.CTRL_DOWN_MASK);
		map.put(redoKey, redoAction);
	}
	
	/*
	 * Key binding for F1
	 */
	@SuppressWarnings("serial")
	private void addKeyBidningForHelp(InputMap map) {
		Action helpAction = new AbstractAction() {
			@Override
			public void actionPerformed(ActionEvent e) {
				Platform.runLater(new Runnable() {
					@Override
					public void run() {
						isRealTimeSearch = false;
						String feedback = executeCommand("help");
						updateFeedback(feedback);
					}
				});
			}
		};
		KeyStroke helpKey = KeyStroke.getKeyStroke(
				com.sun.glass.events.KeyEvent.VK_F1, 0);
		map.put(helpKey, helpAction);
	}

	/*
	 * Add the listener for the Preferences MenuItem in the PopupMenu in system
	 * tray of the application
	 */
	private void addListenerForPreferences(){
		view.getSettingsItemInPopupMenu().addActionListener(createPreferencesListenerInSystemTray());
	}
	
	// Create the specific ActionListener
	private ActionListener createPreferencesListenerInSystemTray() {
		return new ActionListener() {
			@Override
			public void actionPerformed(java.awt.event.ActionEvent e) {
				Platform.runLater(new Runnable() {
					@Override
					public void run() {
						isRealTimeSearch = false;
						String feedback = executeCommand("settings");
						updateFeedback(feedback);
					}
				});
			}
		};
	}
	
	// End of segment: D:\CS2103 Proj\src\Control.java





	/**
	 * origin: D:\CS2103 Proj\src\Control.java
	 */

	private int getTabIndex() {
		if(view == null){
			return tabIndexTest;
		}
		int tabIndex = view.getTabIndex();
		return tabIndex;
	}
	
	// End of segment: D:\CS2103 Proj\src\Control.java





	/**
	 * origin: D:\CS2103 Proj\src\Control.java
	 */

	/**
	 * SEARCH command execution
	 */
	private String executeSearchCommand(String[] parsedUserCommand,
			boolean isRealTimeSearch) {
		Command searchCommand = new SearchCommand(parsedUserCommand, model, view,
				isRealTimeSearch);
		return searchCommand.execute();
	}
	
	/**
	 * TODAY command execution
	 */
	private String executeTodayCommand(boolean isRealTimeSearch) {
		return executeCommand("search today");
	}
	
	// End of segment: D:\CS2103 Proj\src\Control.java





	/**
	 * origin: D:\CS2103 Proj\src\Control.java
	 */

	/**
	 * RECOVER command execution
	 */
	private String executeRecoverCommand(String[] parsedUserCommand) throws IOException{
		boolean isAfterSearch = TwoWayCommand.listedIndexType;
		int tabIndex = getTabIndex();
		assert tabIndex >= 0 && tabIndex <= 2;
		Command recoverCommand = new RecoverCommand(parsedUserCommand, model, tabIndex);
		String feedback = recoverCommand.execute();
		
		if(feedback.equals(Common.MESSAGE_SUCCESSFUL_RECOVER)){
			commandHistory.updateCommand((TwoWayCommand)recoverCommand, isAfterSearch);
			storeTask();
			if(view != null) {
				executeShowCommand();
			}
		}
		return feedback;
	}
	
	// End of segment: D:\CS2103 Proj\src\Control.java





	/**
	 * origin: D:\CS2103 Proj\src\Control.java
	 */

	/*
	 * Update the time format display after changing settings
	 */
	private void updateTimeFormat() {
		CustomDate.setDisplayRemaining(model.doDisplayRemaining());
		Platform.runLater(new Runnable() {
			@Override
			public void run() {
				updateAllTasks();
			}
		});
	}
		
	/*
	 * Update the interface including theme mode and color scheme after changing settings
	 */
	private void updateGUI(String previousTheme) {
		boolean hasThemeChanged = !previousTheme.equals(model.getThemeMode());
		if(hasThemeChanged)
				view.customizeGUI();
		view.setColourScheme(model.getColourScheme());
		setupChangeListener();
	}
	
	// End of segment: D:\CS2103 Proj\src\Control.java





	/**
	 * origin: D:\CS2103 Proj\src\Control.java
	 */

	private void clearCommandLine() {
		view.getCommandLine().setText("");
	}
	
	/**
	 * EXIT command execution
	 */
	private String executeExitCommand() {
		int tabIndex = getTabIndex();
		assert tabIndex >= 0 && tabIndex <= 2;
		Command exitCommand = new ExitCommand(model, tabIndex);
		if(isUnderSyncingProcess()){
			return Common.MESSAGE_EXIT_RESTRICTION;
		}
		
		return exitCommand.execute();
	}
	
	// End of segment: D:\CS2103 Proj\src\Control.java





	/**
	 * origin: D:\CS2103 Proj\src\Control.java
	 */

	/**
	 * SHOW command execution
	 */
	private String executeShowCommand() {
		Command showCommand = new ShowAllCommand(model, view);
		int tabIndex = getTabIndex();
		assert tabIndex >= 0 && tabIndex <= 2;
		updateOverdueLineForSpecificTab(tabIndex);
		
		return showCommand.execute();
	}
	
	/**
	 * Update the last overdue task in a specific tab
	 * 
	 * @param tab
	 *            the given tab
	 */
	private void updateOverdueLineForSpecificTab(int tab) {
		if(tab == Common.PENDING_TAB){
			updateOverdueLine(model.getPendingList());
		} else if(tab == Common.COMPLETE_TAB){
			updateOverdueLine(model.getCompleteList());
		} else if(tab == Common.TRASH_TAB){
			updateOverdueLine(model.getTrashList());
		}
	}
	
	// Check whether the feedback is a signal of successful execution
	private boolean successfulExecution(String feedback) {
		return feedback.equals(Common.MESSAGE_NO_RESULTS)
				|| feedback.equals(Common.MESSAGE_SUCCESSFUL_REMOVE)
				|| feedback.equals(Common.MESSAGE_SUCCESSFUL_RECOVER)
				|| feedback.equals(Common.MESSAGE_SUCCESSFUL_ADD)
				|| feedback.equals(Common.MESSAGE_SUCCESSFUL_CLEAR_ALL)
				|| feedback.equals(Common.MESSAGE_SUCCESSFUL_COMPLETE)
				|| feedback.equals(Common.MESSAGE_SUCCESSFUL_EDIT)
				|| feedback.equals(Common.MESSAGE_SUCCESSFUL_INCOMPLETE)
				|| feedback.equals(Common.MESSAGE_SUCCESSFUL_MARK)
				|| feedback.equals(Common.MESSAGE_SUCCESSFUL_SEARCH)
				|| feedback.equals(Common.MESSAGE_SUCCESSFUL_SHOW_ALL)
				|| feedback.equals(Common.MESSAGE_SUCCESSFUL_UNMARK)
				|| feedback.equals(Common.MESSAGE_SUCCESSFUL_UNDO)
				|| feedback.equals(Common.MESSAGE_SUCCESSFUL_REDO)
				|| feedback.equals(Common.MESSAGE_SUCCESSFUL_HELP)
				|| feedback.equals(Common.MESSAGE_SUCCESSFUL_SETTINGS)
				|| feedback.equals(Common.MESSAGE_SYNC_SUCCESSFUL);
	}
	
	/*****************************Timer and update control of system*************************************************/
	
	/**
	 * Initialize the auto sync and update timer 
	 */
	private void loadTimer() {
		initializeUpdateTimer();
		initializeAutoSync();
	}
	
	// Setup the update timer for task every 1 minute
	private void initializeUpdateTimer() {
		Timer updateTimer = new Timer();
		updateTimer.schedule(new TimerTask() {
			@Override
			public void run() {
				updateAllTasks();
				checkDisplayMessages();
			}
		}, 0, Common.MINUTE_IN_MILLIS);
	}
	
	// End of segment: D:\CS2103 Proj\src\Control.java





	/**
	 * origin: D:\CS2103 Proj\src\Control.java
	 */

	/**
	 * This function checks which tasks in pending list need to be reminded
	 */
	private void checkDisplayMessages() {
		ObservableList<Task> list = model.getPendingList();
		for (int i = 0; i < list.size(); i++) {
			if (list.get(i).isImportantTask()) {
				displayMessageForImportantTask(list.get(i));
			}
		}
	}
	
	// Check whether a task should be reminded
	private void displayMessageForImportantTask(Task task) {
		int remainingTimeForStartDate = task.getStartDate().getRemainingTime();
		int remainingTimeForEndDate = task.getEndDate().getRemainingTime();
		if (isTimeForReminding(remainingTimeForStartDate)) {
			displayMessageForStartDate(task.getWorkInfo(),remainingTimeForStartDate);
		} else if (isTimeForReminding(remainingTimeForEndDate)) {
			displayMessageForEndDate(task.getWorkInfo(), remainingTimeForEndDate);
		}
	}
	
	// Indicator that the remaining time is valid to be reminded
	private boolean isTimeForReminding(int remainingTime) {
		return remainingTime <= 60 && remainingTime > 0 && remainingTime % 15 == 0;
	}
	
	// Reminded a task as the task is about to end
	private void displayMessageForEndDate(String taskInfo,
			int remainingTimeForEndDate) {
		view.getTrayIcon().displayMessage("Reminder", String.format(Common.POPUP_MESSAGE_END_DATE,  taskInfo, remainingTimeForEndDate),
				MessageType.INFO);
	}
	
	// Reminded a task as the task is about to start
	private void displayMessageForStartDate(String taskInfo,
			int remainingTimeForStartDate) {
		view.getTrayIcon().displayMessage("Reminder", String.format(Common.POPUP_MESSAGE_START_DATE, taskInfo, remainingTimeForStartDate),
				MessageType.INFO);
	}
	
	// Update the time of all tasks currently in the application
	private void updateAllTasks() {
		CustomDate.updateCurrentDate();
		updateList(model.getPendingList());
		updateList(model.getCompleteList());
		updateList(model.getTrashList());
	}
	
	/**
	 * This function updates the string displays for dates of all tasks in the
	 * given list. If this is a recurring task and falls behind the current time,
	 * the time will be updated
	 * 
	 * @param list
	 *            the given list
	 */
	private static void updateList(ObservableList<Task> list) {
		for (int i = 0; i < list.size(); i++) {
			list.get(i).updateDateString();
			if (list.get(i).isRecurringTask()) {
				list.get(i).updateDateForRepetitiveTask();
			}
		}
		Common.sortList(list);
	}
	
	/**
	 * Update the last overdue task in a given list
	 * 
	 * @param list
	 *            the given list
	 */
	private static void updateOverdueLine(ObservableList<Task> list) {
		boolean hasLastOverdueTask = false;
		for (int i = list.size() - 1; i >= 0; i--) {
			list.get(i).setIsLastOverdue(false);
			boolean isLastOverdue = !hasLastOverdueTask && list.get(i).isOverdueTask();
			if (isLastOverdue) {
				list.get(i).setIsLastOverdue(true);
				hasLastOverdueTask = true;
			}
		}
	}
	
	// End of segment: D:\CS2103 Proj\src\Control.java





	/**
	 * origin: D:\CS2103 Proj\src\CustomDate.java
	 */

/**
 *
 * This class is used to store the start date and end date in iDo
 * It provides the conversions for various type of inputs or class objects
 *
 */
public class CustomDate {
	final private static int VALID = 1;
	final private static int INVALID = -1;
	final public static int OUT_OF_BOUNDS = 0;
	final private static int MAXIMUM_LENGTH_OF_DATE_INFO = 4;
	final private static int MAXIMUM_LENGTH_FOR_DATE_PART = 2;
	final private static int MAXIMUM_LENGTH_FOR_TIME_PART = 2;
	final private static int EMPTY_DATE_INFO = 0;
	final private static int SUNDAY = 8;
	final private static int MINUTE_IN_MILLIS = 60 * 1000;
	final public static long DAY_IN_MILLIS = 24 * 60 * 60 * 1000;
	final private static long SIX_HOURS_IN_MILLIS = 6 * 60 * 60 * 1000;
	final private static long WEEK_IN_MILLIS = 7 * 24 * 60 * 60 * 1000;
	final private static long MONTH_IN_MILLIS = 30L * 24 * 60 * 60 * 1000;
	final private static long YEAR_IN_MILLIS = 365 * 24 * 60 * 60 * 1000;
	final private static long FIRST_TWELVE_HOURS = 12 * 60;
	final private static int HOUR_IN_MINUTES = 60;
	final private static String DAILY_REGEX = "(every)(\\d+)(days?)";
	final private static String WEEKLY_REGEX = "(every)(\\d+)(weeks?)";
	final private static String MONTHLY_REGEX = "(every)(\\d+)(months?)";
	final private static String YEARLY_REGEX = "(every)(\\d+)(years?)";
	final private static int LARGER = 1;
	final private static int SMALLER = -1;
	final private static int EQUAL = 0;

	// The common current date among CustomDate object
	private static GregorianCalendar currentDate;

	// The option whether to display remaining time according to the current time
	private static boolean displayRemaining = true;

	// The target date of CustomDate object
	private GregorianCalendar sourceDate;

	// The date info of this target date
	private String dateInfo;
	// Indicator whether the dateInfo has indicated the specific date
	boolean hasIndicatedDate;
	
	// Default constructors
	public CustomDate() {
		sourceDate = new GregorianCalendar();
	}
	
	/**
	 *  Constructor from a DateTime object by converting its string format into the desired format
	 *  DateTime format: YYYY/MM/DDTHH:MM:SS
	 * @param dateTime the DateTime object 
	 */
	public CustomDate(DateTime dateTime){
		String dateTimeString = dateTime.toString();
		String date = dateTimeString.substring(8, 10);
		String month = dateTimeString.substring(5, 7);
		String year = dateTimeString.substring(0, 4);
		String time = "00:00";
		String second = "00";
		
		boolean hasTime = dateTimeString.length() > 10;
		if (hasTime) {
			time = dateTimeString.substring(11, 16);
			second = dateTimeString.substring(17, 19);
		}
		String customDateFormat = date + "/" + month + "/" + year + " " + time;
		
		sourceDate = new GregorianCalendar();
		convert(customDateFormat);
		setSecond(Integer.parseInt(second));
	}
	
	/**
	 * Constructor from an input string
	 * @param inputDateString the input of date
	 */
	public CustomDate(String inputDateString) {
		sourceDate = new GregorianCalendar();
		convert(inputDateString);
	}
	
	// Set whether to display the remaining time or not
	public static void setDisplayRemaining(boolean displayRemaining){
		CustomDate.displayRemaining = displayRemaining;
	}
	
	/*************** GET functions to get corresponding time elements in CustomDate *****************/
	public int getYear() {
		return sourceDate.get(Calendar.YEAR);
	}

	public int getMonth() {
		return sourceDate.get(Calendar.MONTH);
	}

	public int getDate() {
		return sourceDate.get(Calendar.DATE);
	}

	public int getHour() {
		return sourceDate.get(Calendar.HOUR_OF_DAY);
	}

	public int getMinute() {
		return sourceDate.get(Calendar.MINUTE);
	}
	
	public int getSecond(){
		return sourceDate.get(Calendar.SECOND);
	}
	
	public long getTimeInMillis() {
		return sourceDate.getTimeInMillis();
	}
	
	// Check whether the dateInfo has indicated an exact date
	public boolean hasIndicatedDate(){
		return hasIndicatedDate;
	}

	/************************** SET methods to set the time elements in CustomDate **************/
	public void setHour(int hour) {
		sourceDate.set(Calendar.HOUR_OF_DAY, hour);
	}

	public void setMinute(int minute) {
		sourceDate.set(Calendar.MINUTE, minute);
	}
	
	public void setDate(int date){
		sourceDate.set(Calendar.DATE, date);
	}
	
	public void setMonth(int month){
		sourceDate.set(Calendar.MONTH, month);
	}
	
	public void setYear(int year){
		sourceDate.set(Calendar.YEAR, year);
	}
	
	public void setSecond(int second){
		sourceDate.set(Calendar.SECOND, second);
	}
	
	public void setTimeInMillis(long millis) {
		sourceDate.setTimeInMillis(millis);
	}

	/**
	 * Convert the CustomDate object into DateTime object from Google Library
	 * 
	 * @return the DateTime object
	 */
	public DateTime returnInDateTimeFormat() {
		return new DateTime(sourceDate.getTime(), TimeZone.getDefault());
	}
	
	/**
	 * Convert into CustomDate object from the string format of recurring date from Google Library
	 * Recurring date format: DDMMYYTHHMMSS
	 * @param recurrenceDateString the string with format from Google Library
	 * @return the converted CustomDate object
	 */
	public static CustomDate convertFromRecurringDateString(String recurrenceDateString){
		String year = recurrenceDateString.substring(0, 4);
		String month = recurrenceDateString.substring(4, 6);
		String date = recurrenceDateString.substring(6, 8);
		String hour = recurrenceDateString.substring(9, 11);
		String minute = recurrenceDateString.substring(11, 13);
		
		return new CustomDate(date+"/" + Integer.parseInt(month) + "/" + year + " " + hour + ":" + minute);
	}
	
	/**
	 * Get the recurring format from Google Library from the CustomDate object
	 * @return the string in required format
	 */
	public String returnInRecurringFormat(){
		DecimalFormat df = new DecimalFormat("00");
		String year = String.valueOf(getYear());
		String month = df.format(getMonth()+1);
		String date = df.format(getDate());
		String hour = df.format(getHour());
		String minute = df.format(getMinute());
		String second = "00";
		
		return year + month + date + "T" + hour + minute+second;
	}

	/**
	 * This function is used to convert this CustomDate object to string with
	 * format for display in GUI
	 * 
	 * @param isStartDate
	 *            check whether this is a start or end date
	 * @return the required String displayed on GUI
	 */
	public String toString(boolean isStartDate) {
		updateCurrentDate();
		boolean hasTime = hasTime(isStartDate);
	
		// Check the capability to display remaining time
		if (displayRemaining && !beforeCurrentTime() && lessThan6Hours()) {
			return getRemainingTimeString();
		}
	
		// Check if the time is tonight
		if (isTonight()) {
			return "Tonight";
		}
	
		// Otherwise, display the standard format
		String result = "";
		result += getDateString();
		result += getTimeString(hasTime);
		return result;
	}

	/**
	 * Get the remaining time relatively to the current time in String
	 * @return the required string with correct format for display
	 */
	public String getRemainingTimeString() {
		int remainingTime = (int) (sourceDate.getTimeInMillis() - currentDate.getTimeInMillis()) / MINUTE_IN_MILLIS;
		int remainingHours = remainingTime / HOUR_IN_MINUTES;
		int remainingMinutes = remainingTime % HOUR_IN_MINUTES;
		return remainingHours + "h " + remainingMinutes + "m";
	}
	
	public int getRemainingTime(){
		int remainingTime = (int) (sourceDate.getTimeInMillis() - currentDate.getTimeInMillis()) / MINUTE_IN_MILLIS;
		return remainingTime;
	}

	/**
	 * Get the string of the date in CustomDate object
	 * 
	 * @return the required string with correct format
	 */
	private String getDateString() {
		if (isToday()) {
			return "Today";
		} else {
			String dateString;
			dateString = sourceDate.get(Calendar.DATE) + " " + getMonthString(sourceDate.get(Calendar.MONTH));
			if (!isCurrentYear()) {
				dateString += " " + sourceDate.get(Calendar.YEAR);
			}
			return dateString;
		}
	}
	
	/**
	 * Get the string of the time in CustomDate object
	 * @param hasTime to check whether the dateInfo string does indicate the time
	 * @return the required string with correct format
	 */
	private String getTimeString(boolean hasTime) {
		if (hasTime) {
			DecimalFormat df = new DecimalFormat("00");
			return "\n " + sourceDate.get(Calendar.HOUR_OF_DAY) + ":" + df.format(sourceDate.get(Calendar.MINUTE));
		}
		return "";
	}
	
	// Check whether the target year is the current year
	private boolean isCurrentYear() {
		return sourceDate.get(Calendar.YEAR) == currentDate.get(Calendar.YEAR);
	}
	
	/**
	 * Convert a CustomDate object into string with required format from DataStorage class
	 * 
	 * @param storedDate
	 *            the object needed to be converted
	 * @return the String format of this object
	 */
	public static String convertString(CustomDate storedDate) {
		if (storedDate == null)
			return "-";
		
		int date = storedDate.sourceDate.get(Calendar.DATE);
		int month = storedDate.sourceDate.get(Calendar.MONTH);
		int year = storedDate.sourceDate.get(Calendar.YEAR);
		int hour = storedDate.sourceDate.get(Calendar.HOUR_OF_DAY);
		int minute = storedDate.sourceDate.get(Calendar.MINUTE);
		
		return date + "/" + (month + 1) + "/" + year + " " + hour + ":" + minute;
	}

	/**
	 * This function is used to compare 2 CustomDate objects
	 * 
	 * @param date1
	 *            the first date
	 * @param date2
	 *            the second date
	 * @return value indicating the result of comparison
	 */
	public static int compare(CustomDate date1, CustomDate date2) {
		int difference = 0;
		if (date1 == null && date2 == null) {
			return EQUAL;
		} else if (date1 == null && date2 != null) {
			return LARGER;
		} else if (date1 != null && date2 == null) {
			return SMALLER;
		}

		for (int i = 0; i < 6; i++) {
			if (i == 0) {
				difference = date1.getYear() - date2.getYear();
			} else if (i == 1) {
				difference = date1.getMonth() - date2.getMonth();
			} else if (i == 2) {
				difference = date1.getDate() - date2.getDate();
			} else if (i == 3) {
				difference = date1.getHour() - date2.getHour();
			} else if(i == 4) {
				difference = date1.getMinute() - date2.getMinute();
			} else{
				difference = date1.getSecond() - date2.getSecond();
			}
			if (difference != 0) {
				return difference;
			}
		}

		return difference;
	}


	/**
	 * This function is used to compare 2 CustomDate objects only according to
	 * their dates, not their times
	 * 
	 * @param date1
	 *            the first date
	 * @param date2
	 *            the second date
	 * @return value indicating the result of comparison
	 */
	public static int dateCompare(CustomDate date1, CustomDate date2) {
		int difference = 0;
		if (date1 == null && date2 == null) {
			return EQUAL;
		} else if (date1 == null && date2 != null) {
			return LARGER;
		} else if (date1 != null && date2 == null) {
			return SMALLER;
		}
		
		for (int i = 0; i < 3; i++) {
			if (i == 0) {
				difference = date1.getYear() - date2.getYear();
			} else if (i == 1) {
				difference = date1.getMonth() - date2.getMonth();
			} else if (i == 2) {
				difference = date1.getDate() - date2.getDate();
			}
			if (difference != 0) {
				return difference;
			}
		}
		
		return difference;
	}
	
	// Check whether the sourceDate is before current time
	public boolean beforeCurrentTime() {
		return (currentDate.getTimeInMillis() - sourceDate.getTimeInMillis()) > 0;
	}

	// Refresh the current time
	public static void updateCurrentDate() {
		currentDate = new GregorianCalendar();
	}
	
	// End of segment: D:\CS2103 Proj\src\CustomDate.java





	/**
	 * origin: D:\CS2103 Proj\src\CustomDate.java
	 */

	/**
	 * This function is used to set the date from given info string
	 * This is the main function for conversion for CustomDate class.
	 * @param dateString
	 *            the given info of the date
	 * @return value indicating the conversion is successful or not
	 */
	public int convert(String dateString) {
		dateInfo = dateString.toLowerCase();
		String[] infos = dateInfo.split("\\s+");

		updateCurrentDate();

		boolean invalidLength = infos.length > MAXIMUM_LENGTH_OF_DATE_INFO || infos.length == EMPTY_DATE_INFO;
		if (invalidLength) {
			return INVALID;
		}
		
		// Start the process of conversion
		try {
			int numElements = infos.length; // get the current number of elements in the String array
			
			GregorianCalendar tempDate = new GregorianCalendar();
			tempDate.setLenient(false); // prevent Out of Bounds date
			
			// Date Processing
			numElements = processDate(infos, tempDate, numElements);
			if (numElements == INVALID) {
				return INVALID;
			}
			if (numElements != infos.length) { // check if the dateInfo did indicating the date
				hasIndicatedDate = true;
			} else {
				hasIndicatedDate = false;
			}
			
			// Time Processing
			numElements = processTime(infos, tempDate, numElements);
			if (numElements > 0 || numElements == INVALID) {
				return INVALID;
			}

			sourceDate = tempDate;
			return VALID;
		} catch (Exception e) {
			if (e.getMessage().equals("Out of bounds")) { // case when the date is out of bounds
				return OUT_OF_BOUNDS;
			}
			return INVALID;
		}
	}
	
	/**
	 * This function is used to process the date conversion
	 * 
	 * @param infos
	 *            the String array containing infos of target of conversion
	 * @param tempDate
	 *            the modified GregorianCalendar temporary object
	 * @param numElements
	 *            number of unprocessed elements left in the array
	 * @return the number of elements left unprocessed in the array
	 */
	private int processDate(String[] infos, GregorianCalendar tempDate, int numElements) {
		if (hasDateFormat()) { // has date format
			return updateDate(infos, tempDate, numElements);
		} else if (hasDayFormat()) { // has day format, i.e Monday
			return updateDay(infos, tempDate, numElements);
		} else if (infos.length > MAXIMUM_LENGTH_FOR_TIME_PART) { // no indication of date and exceed length for time part 
			return INVALID;
		}
		
		return numElements;
	}
	
	/**
	 * This function is used to update the date in date format
	 * 
	 * @param infos
	 *            the String array containing infos of target of conversion
	 * @param tempDate
	 *            the modified GregorianCalendar temporary object
	 * @param numElements
	 *            number of unprocessed elements left in the array
	 * @return the number of elements left unprocessed in the array
	 */
	private int updateDate(String[] infos, GregorianCalendar tempDate, int numElements) {
		int startIndex = getStartIndexOfDate(infos);

		if (hasMonthWord()) { // containing month String i.e Jan
			numElements = updateDateWithMonth(infos, tempDate, numElements, startIndex);
		} else if (hasSlashFormat(dateInfo)) { 
			numElements = updateDateWithSlash(infos, tempDate, numElements, startIndex);
		} else if(hasDashFormat(dateInfo)) {
			numElements = updateDateWithDash(infos, tempDate, numElements, startIndex);
		}

		return numElements;
	}
	
	private static boolean hasSlashFormat(String dateInfo){
		return dateInfo.contains("/");
	}
	
	private static boolean hasDashFormat(String dateInfo){
		return dateInfo.contains("-");
	}
	
	/**
	 * This function is used to update the date in date format with indicated
	 * month word
	 * 
	 * @param infos
	 *            the String array containing infos of target of conversion
	 * @param tempDate
	 *            the modified GregorianCalendar temporary object
	 * @param numElements
	 *            number of unprocessed elements left in the array
	 * @param startIndex
	 *             the start index of the date in the array
	 * @return the number of elements left unprocessed in the array
	 */
	private int updateDateWithMonth(String[] infos, GregorianCalendar tempDate, int numElements, int startIndex) {
		int date = Integer.parseInt(infos[startIndex]);
		int month = getMonth(infos[startIndex + 1]);

		tempDate.set(Calendar.MONTH, month);
		tempDate.set(Calendar.DATE, date);
		checkDateBound(tempDate); 

		return numElements - 2;
	}
	
	/**
	 * This function is used to update the date in date format with slash
	 * 
	 * @param infos
	 *            the String array containing infos of target of conversion
	 * @param tempDate
	 *            the modified GregorianCalendar temporary object
	 * @param numElements
	 *            number of unprocessed elements left in the array
	 * @param startIndex
	 *            the start index of the date in the array
	 * @return the number of elements left unprocessed in the array
	 */
	private int updateDateWithSlash(String[] infos,
			GregorianCalendar tempDate, int numElements, int startIndex) {
		String[] numbers = infos[startIndex].split("/");
		boolean invalidLength = numbers.length != 3 && numbers.length != 2;
		if (invalidLength) {
			throw new IllegalArgumentException("Invalid length in slash format");
		}

		int month = getMonth(numbers[1]);
		tempDate.set(Calendar.MONTH, month);
		int date = Integer.parseInt(numbers[0]);
		tempDate.set(Calendar.DATE, date);
		int year = (numbers.length == 3) ? Integer.parseInt(numbers[2]) : currentDate.get(Calendar.YEAR);
		tempDate.set(Calendar.YEAR, year);
		checkDateBound(tempDate); // check whether the date is out of bounds

		return numElements - 1;
	}
	
	/**
	 * This function is used to update the date in date format with dash
	 * 
	 * @param infos
	 *            the String array containing infos of target of conversion
	 * @param tempDate
	 *            the modified GregorianCalendar temporary object
	 * @param numElements
	 *            number of unprocessed elements left in the array
	 * @param startIndex
	 *            the start index of the date in the array
	 * @return the number of elements left unprocessed in the array
	 */
	private int updateDateWithDash(String[] infos,
			GregorianCalendar tempDate, int numElements, int startIndex) {
		String[] numbers = infos[startIndex].split("-");
		boolean invalidLength = numbers.length != 3 && numbers.length != 2;
		if (invalidLength)
			throw new IllegalArgumentException("Invalid length in dash format");

		int month = getMonth(numbers[1]);
		tempDate.set(Calendar.MONTH, month);
		int date = Integer.parseInt(numbers[0]);
		tempDate.set(Calendar.DATE, date);
		int year = (numbers.length == 3) ? Integer.parseInt(numbers[2]) : currentDate.get(Calendar.YEAR);
		tempDate.set(Calendar.YEAR, year);
		checkDateBound(tempDate); // check whether the date is out of bounds

		return numElements - 1;
	}
	
	/**
	 * This function is used to check whether the date is out of bounds
	 * If yes, it will throw an IllegalArgumentException with indicated message
	 */
	private void checkDateBound(GregorianCalendar tempDate) {
		try {
			tempDate.get(Calendar.DATE);
			tempDate.get(Calendar.MONTH);
		} catch (IllegalArgumentException e) {
			throw new IllegalArgumentException("Out of bounds");
		}
	}
	
	/**
	 * Get the starting index of the DATE part in the string array
	 */
	private int getStartIndexOfDate(String[] infos) {
		if (hasTimeFormat()) {
			int temp = getIndexOfTime(infos);
			if (temp != INVALID) {
				if (infos[temp].equals("am") || infos[temp].equals("pm")) {
					return (temp <= 1) ? temp + 1 : 0;
				} else {
					return (temp >= 1) ? 0 : temp + 1;
				}
			} else {
				temp = getIndexOfColon(infos);
				return (temp == 0) ? temp + 1 : 0;
			}
		}
		return 0;
	}
	
	/**
	 * This function is used to update the date in day format
	 * 
	 * @param infos
	 *            the String array containing infos of target of conversion
	 * @param tempDate
	 *            the modified GregorianCalendar temporary object
	 * @param numElements
	 *            number of unprocessed elements left in the array
	 * @return the number of elements left unprocessed in the array
	 */
	private int updateDay(String[] infos, GregorianCalendar tempDate,
			int numElements) {
		int startIndex = getStartIndexOfDate(infos);
		
		if (isTomorrowKeyWord(infos[startIndex])) {
			numElements = updateTomorrow(tempDate, numElements);
		} else if (isTodayKeyWord(infos[startIndex])) {
			numElements--; // no need to update
		} else if (isTonightKeyWord(infos[startIndex])) {
			numElements--; // no need to update
		} else if (hasDayWord()) {
			numElements = updateDateWithDay(infos, tempDate, numElements, startIndex);
		}
		
		return numElements;
	}
	
	// Update the target date as tomorrow
	private int updateTomorrow(GregorianCalendar tempDate, int numElements) {
		tempDate.setTimeInMillis(currentDate.getTimeInMillis() + DAY_IN_MILLIS);
		return numElements - 1;
	}
	
	/**
	 * This function is used to update the date in date format with day i.e Monday
	 * 
	 * @param infos
	 *            the String array containing infos of target of conversion
	 * @param tempDate
	 *            the modified GregorianCalendar temporary object
	 * @param numElements
	 *            number of unprocessed elements left in the array
	 * @param startIndex
	 *            the start index of the date in the array
	 * @return the number of elements left unprocessed in the array
	 */
	private int updateDateWithDay(String[] infos, GregorianCalendar tempDate,
			int numElements, int startIndex) {
		boolean hasNext = infos[startIndex].equals("next");
		int currentDay = currentDate.get(Calendar.DAY_OF_WEEK);
		int targetDay = (hasNext == true) ? getDay(infos[startIndex + 1]) : getDay(infos[startIndex]);
		if (targetDay == 1) { // value of Sunday in GregorianCalendar is 1
			targetDay = SUNDAY; // change to 8
		}
		if (currentDay == 1) {
			currentDay = SUNDAY;
		}

		long difference = targetDay - currentDay + ((hasNext || targetDay < currentDay) ? 7 : 0);
		tempDate.setTimeInMillis(currentDate.getTimeInMillis() + difference * DAY_IN_MILLIS);
		if (hasNext == true) {
			numElements -= 2;
		} else {
			numElements--;
		}
		
		return numElements;
	}
	
	// Check if the day String is tomorrow
	private boolean isTomorrowKeyWord(String day) {
		return day.equals("tomorrow") || day.equals("tmr");
	}
	
	// Check if the day String is today
	private boolean isTodayKeyWord(String day) {
		return day.equals("today");
	}

	// Check if the day String is tonight
	private boolean isTonightKeyWord(String day) {
		return day.equals("tonight");
	}
	
	// Check if the dateInfo String may have day format
	private boolean hasDayFormat() {
		boolean hasToday = dateInfo.contains("today");
		boolean hasTomorrow = dateInfo.contains("tomorrow") || dateInfo.contains("tmr");
		boolean hasTonight = dateInfo.contains("tonight");

		return hasToday || hasTomorrow || hasDayWord() || hasTonight;
	}
	
	// Check if the dateInfo String may contain days in a week
	private boolean hasDayWord() {
		return dateInfo.contains("mon") || dateInfo.contains("tue")
				|| dateInfo.contains("wed") || dateInfo.contains("thu")
				|| dateInfo.contains("fri") || dateInfo.contains("sat")
				|| dateInfo.contains("sun");
	}
	
	// Check if the dateInfo String may have date format
	private boolean hasDateFormat() {
		boolean hasSlash = dateInfo.contains("/");
		boolean hasDash = dateInfo.contains("-");

		return hasSlash || hasDash || hasMonthWord();
	}	

	// Check if the dateInfo String may contain month in a year
	private boolean hasMonthWord() {
		return dateInfo.contains("jan") || dateInfo.contains("feb")
				|| dateInfo.contains("mar") || dateInfo.contains("apr")
				|| dateInfo.contains("may") || dateInfo.contains("june")
				|| dateInfo.contains("jul") || dateInfo.contains("aug")
				|| dateInfo.contains("sep") || dateInfo.contains("oct")
				|| dateInfo.contains("nov") || dateInfo.contains("dec");
	}
	
	/**
	 * This function is used to get the corresponding Integer value of the day string 
	 */
	private int getDay(String day) {
		if (isMonday(day)) {
			return Calendar.MONDAY;
		} else if (isTuesday(day)) {
			return Calendar.TUESDAY;
		} else if (isWednesday(day)) {
			return Calendar.WEDNESDAY;
		} else if (isThursday(day)) {
			return Calendar.THURSDAY;
		} else if (isFriday(day)) {
			return Calendar.FRIDAY;
		} else if (isSaturday(day)) {
			return Calendar.SATURDAY;
		} else if (isSunday(day)) {
			return Calendar.SUNDAY;
		} else {
			throw new IllegalArgumentException("Invalid Day");
		}
	}
	
	/********************************************* Determine the day in the week  **************************************/
	private boolean isMonday(String day) {
		return day.equals("monday") || day.equals("mon");
	}

	private boolean isTuesday(String day) {
		return day.equals("tuesday") || day.equals("tue");
	}

	private boolean isWednesday(String day) {
		return day.equals("wednesday") || day.equals("wed");
	}

	private boolean isThursday(String day) {
		return day.equals("thursday") || day.equals("thu");
	}

	private boolean isFriday(String day) {
		return day.equals("friday") || day.equals("fri");
	}

	private boolean isSaturday(String day) {
		return day.equals("saturday") || day.equals("sat");
	}

	private boolean isSunday(String day) {
		return day.equals("sunday") || day.equals("sun");
	}
	
	/**
	 * This function is used to get the Integer value of the month String
	 */
	private int getMonth(String month) {
		if (isJanuary(month)) {
			return Calendar.JANUARY;
		} else if (isFebruary(month)) {
			return Calendar.FEBRUARY;
		} else if (isMarch(month)) {
			return Calendar.MARCH;
		} else if (isApril(month)) {
			return Calendar.APRIL;
		} else if (isMay(month)) {
			return Calendar.MAY;
		} else if (isJune(month)) {
			return Calendar.JUNE;
		} else if (isJuly(month)) {
			return Calendar.JULY;
		} else if (isAugust(month)) {
			return Calendar.AUGUST;
		} else if (isSeptember(month)) {
			return Calendar.SEPTEMBER;
		} else if (isOctober(month)) {
			return Calendar.OCTOBER;
		} else if (isNovember(month)) {
			return Calendar.NOVEMBER;
		} else if (isDecember(month)) {
			return Calendar.DECEMBER;
		} else if (isInteger(month)) {
			throw new IllegalArgumentException("Out of bounds");
		} else {
			throw new IllegalArgumentException("Invalid Month");
		}
	}
	
	/**
	 * This function is used to get the string of the month for display
	 */
	private String getMonthString(int month) {
		if (month == Calendar.JANUARY) {
			return "Jan";
		} else if (month == Calendar.FEBRUARY) {
			return "Feb";
		} else if (month == Calendar.MARCH) {
			return "Mar";
		} else if (month == Calendar.APRIL) {
			return "Apr";
		} else if (month == Calendar.MAY) {
			return "May";
		} else if (month == Calendar.JUNE) {
			return "June";
		} else if (month == Calendar.JULY) {
			return "July";
		} else if (month == Calendar.AUGUST) {
			return "Aug";
		} else if (month == Calendar.SEPTEMBER) {
			return "Sep";
		} else if (month == Calendar.OCTOBER) {
			return "Oct";
		} else if (month == Calendar.NOVEMBER) {
			return "Nov";
		} else if (month == Calendar.DECEMBER) {
			return "Dec";
		} else {
			return "Invalid";
		}
	}
	/********************************* Determine the month *********************************************/
	private boolean isJanuary(String month) {
		return month.equals("jan") || (isInteger(month) && String.valueOf(Integer.parseInt(month)).equals("1")) || month.equals("january");
	}

	private boolean isFebruary(String month) {
		return month.equals("feb") || (isInteger(month) && String.valueOf(Integer.parseInt(month)).equals("2") )|| month.equals("february");
	}

	private boolean isMarch(String month) {
		return month.equals("mar") ||  (isInteger(month) &&String.valueOf(Integer.parseInt(month)).equals("3") )|| month.equals("march");
	}

	private boolean isApril(String month) {
		return month.equals("apr") ||  (isInteger(month) &&String.valueOf(Integer.parseInt(month)).equals("4")) || month.equals("april");
	}

	private boolean isMay(String month) {
		return month.equals("may") || (isInteger(month) && String.valueOf(Integer.parseInt(month)).equals("5"));
	}

	private boolean isJune(String month) {
		return month.equals("june") ||  (isInteger(month) && String.valueOf(Integer.parseInt(month)).equals("6"));
	}

	private boolean isJuly(String month) {
		return month.equals("july") ||  (isInteger(month) && String.valueOf(Integer.parseInt(month)).equals("7"));
	}

	private boolean isAugust(String month) {
		return month.equals("aug") || (isInteger(month) && String.valueOf(Integer.parseInt(month)).equals("8"))|| month.equals("august");
	}

	private boolean isSeptember(String month) {
		return month.equals("sep") || (isInteger(month) && String.valueOf(Integer.parseInt(month)).equals("9")) || month.equals("september");
	}

	private boolean isOctober(String month) {
		return month.equals("oct") || (isInteger(month) && String.valueOf(Integer.parseInt(month)).equals("10")) || month.equals("october");
	}

	private boolean isNovember(String month) {
		return month.equals("nov") ||  (isInteger(month) && String.valueOf(Integer.parseInt(month)).equals("11")) || month.equals("november");
	}

	private boolean isDecember(String month) {
		return month.equals("dec") ||  (isInteger(month) && String.valueOf(Integer.parseInt(month)).equals("12")) || month.equals("december");
	}
	
	/**
	 * This function is used to process the time conversion
	 * 
	 * @param infos
	 *            the String array containing infos of target of conversion
	 * @param tempDate
	 *            the modified GregorianCalendar temporary object
	 * @param numElements
	 *            number of unprocessed elements left in the array
	 * @return the number of elements left unprocessed in the array
	 */
	private int processTime(String[] infos, GregorianCalendar tempDate, int numElements) {
		if (hasTimeFormat()) {
			return updateTime(infos, tempDate, numElements);
		} else {
			if (infos.length > MAXIMUM_LENGTH_FOR_DATE_PART) { // no indication of date and exceed length for DATE part 
				return INVALID;
			}
			resetTime(tempDate); 
		}
		
		return numElements;
	}
	
	// Get the start index of TIME with 'am' or 'pm' in the String array
	private int getIndexOfTime(String[] infos) {
		for (int i = 0; i < infos.length; i++) {
			if (infos[i].contains("am") || infos[i].contains("pm")) {
				return i;
			}
		}
		
		return INVALID;
	}
	
	// Get the start index of TIME with colon in the String array
	private int getIndexOfColon(String[] infos) {
		for (int i = 0; i < infos.length; i++) {
			if (infos[i].contains(":")) {
				return i;
			}
		}
		return INVALID;
	}

	/**
	 * This function is used to update the time
	 * 
	 * @param infos
	 *            the String array containing infos of target of conversion
	 * @param tempDate
	 *            the modified GregorianCalendar temporary object
	 * @param numElements
	 *            number of unprocessed elements left in the array
	 * @return the number of elements left unprocessed in the array
	 */
	private int updateTime(String[] infos, GregorianCalendar tempDate,
			int numElements) {
		int index = getIndexOfTime(infos);
		if (index != INVALID) { // has time with 12 Format
			numElements = updateTimeWith12Format(infos, tempDate, index, numElements);
		} else {
			numElements = updateTimeWith24Format(infos, tempDate, numElements);
		}
		
		// Conversion of time for 'tonight'
		if (dateInfo.contains("tonight")) {
			if (tempDate.get(Calendar.HOUR_OF_DAY) * HOUR_IN_MINUTES + tempDate.get(Calendar.MINUTE) < FIRST_TWELVE_HOURS) {
				tempDate.setTimeInMillis(tempDate.getTimeInMillis() + DAY_IN_MILLIS);
			}
		}
		
		tempDate.set(Calendar.SECOND, 0); // default second for time
		return numElements;
	}
	
	/**
	 * This function is used to update the time in 12-hour format
	 * 
	 * @param infos
	 *            the String array containing infos of target of conversion
	 * @param tempDate
	 *            the modified GregorianCalendar temporary object
	 * @param numElements
	 *            number of unprocessed elements left in the array
	 * @param startIndex
	 *            the start index of the time in the array
	 * @return the number of elements left unprocessed in the array
	 */
	private int updateTimeWith12Format(String[] infos,
			GregorianCalendar tempDate, int index, int numElements) {
		boolean isDay;
		String timeInfo;
		boolean hasSpace;
		
		// Check whether the 'am' or 'pm' is attached to the time info(i.e 6pm or 6 pm)
		if (infos[index].equals("am") || infos[index].equals("pm")) {
			isDay = infos[index].equals("am");
			timeInfo = infos[index - 1];
			hasSpace = true;
		} else {
			isDay = infos[index].substring(infos[index].length() - 2).equals("am");
			timeInfo = infos[index].substring(0, infos[index].length() - 2);
			hasSpace = false;
		}
		
		// Start updating
		boolean hasColon = timeInfo.contains(":");
		boolean hasDot = timeInfo.contains(".");
		if (hasColon) {
			updateTimeWithColon(timeInfo, isDay, tempDate);
		} else if (hasDot) {
			updateTimeWithDot(timeInfo, isDay, tempDate);
		} else { // no signs
			updateTimeWithoutSign(timeInfo, isDay, tempDate);
		}

		if (hasSpace) {
			return numElements - 2;
		} else {
			return numElements - 1;
		}
	}
	
	/**
	 * This function is used to update time in 12-hour format with colon
	 * 
	 * @param timeInfo
	 *            the time info String
	 * @param isDay
	 *            indicator whether it is 'am' or 'pm'
	 * @param modifiedDate
	 *            the modified GregorianCalendar temporary object
	 */
	private void updateTimeWithColon(String timeInfo, boolean isDay,
			GregorianCalendar modifiedDate) {
		String[] time = timeInfo.split(":");
		boolean invalidLength = time.length > 2;
		if (invalidLength) {
			throw new IllegalArgumentException("Invalid length in colon time format");
		}
		
		int hour = Integer.parseInt(time[0]) + (isDay ? 0 : 12);
		if (hour == 24 || hour == 12)
			hour -= 12;
		int minute = Integer.parseInt(time[1]);
		
		modifiedDate.set(Calendar.HOUR_OF_DAY, hour);
		modifiedDate.set(Calendar.MINUTE, minute);
		checkTimeBound(modifiedDate);
	}
	
	/**
	 * This function is used to update time in 12-hour format with dot
	 * 
	 * @param timeInfo
	 *            the time info String
	 * @param isDay
	 *            indicator whether it is 'am' or 'pm'
	 * @param modifiedDate
	 *            the modified GregorianCalendar temporary object
	 */
	private void updateTimeWithDot(String timeInfo, boolean isDay,
			GregorianCalendar tempDate) {
		String[] time = timeInfo.split("\\.");
		boolean invalidLength = time.length > 2;
		if (invalidLength) {
			throw new IllegalArgumentException("Invalid length in dot time format");
		}
		
		int hour = Integer.parseInt(time[0]) + (isDay ? 0 : 12);
		if (hour == 24 || hour == 12) {
			hour -= 12;
		}
		int minute = Integer.parseInt(time[1]);
		
		tempDate.set(Calendar.HOUR_OF_DAY, hour);
		tempDate.set(Calendar.MINUTE, minute);
		checkTimeBound(tempDate);
	}
	
	/**
	 * This function is used to update time in 12-hour format without any signs
	 * 
	 * @param timeInfo
	 *            the time info String
	 * @param isDay
	 *            indicator whether it is 'am' or 'pm'
	 * @param modifiedDate
	 *            the modified GregorianCalendar temporary object
	 */
	private void updateTimeWithoutSign(String timeInfo, boolean isDay,
			GregorianCalendar tempDate) {
		int timeInNumberFormat = Integer.parseInt(timeInfo);
		
		boolean hasOnlyHour = timeInfo.length() < 3;
		boolean hasHourAndMinute = timeInfo.length() == 3 || timeInfo.length() == 4;
		if (hasOnlyHour) {
			int hour = timeInNumberFormat + (isDay ? 0 : 12);
			if (hour == 24 || hour == 12){
				hour -= 12;
			}
			
			tempDate.set(Calendar.HOUR_OF_DAY, hour);
			tempDate.set(Calendar.MINUTE, 0);
			checkTimeBound(tempDate);
		} else if (hasHourAndMinute) {
			int hour = timeInNumberFormat / 100 + (isDay ? 0 : 12);
			if (hour == 24 || hour == 12){
				hour -= 12;
			}
			int minute = timeInNumberFormat % 100;
			
			tempDate.set(Calendar.HOUR_OF_DAY, hour);
			tempDate.set(Calendar.MINUTE, minute);
			checkTimeBound(tempDate);
		} else {
			throw new IllegalArgumentException("Invalid length in time without sign format");
		}
	}
	
	/**
	 * This function is used to update the time in 24-hour format
	 * 
	 * @param infos
	 *            the String array containing infos of target of conversion
	 * @param tempDate
	 *            the modified GregorianCalendar temporary object
	 * @param numElements
	 *            number of unprocessed elements left in the array
	 * @return the number of elements left unprocessed in the array
	 */
	private int updateTimeWith24Format(String[] infos,
			GregorianCalendar tempDate, int numElements) {
		int index = getIndexOfColon(infos);
		String[] time = infos[index].split(":");
		boolean invalidLength = time.length > 2;
		if (invalidLength){
			throw new IllegalArgumentException("Invalid in time with colon format");
		}
		
		int hour = Integer.parseInt(time[0]);
		int minute = Integer.parseInt(time[1]);

		tempDate.set(Calendar.HOUR_OF_DAY, hour);
		tempDate.set(Calendar.MINUTE, minute);
		checkTimeBound(tempDate);
		
		return numElements - 1;
	}
	
	/**
	 * This function is used to reset the hour, minute and second back to 0
	 * But if the time is 'tonight', hour and minute will be reseted back to 23 and 59 respectively
	 */
	private void resetTime(GregorianCalendar targetDate) {
		targetDate.set(Calendar.HOUR_OF_DAY, 0);
		targetDate.set(Calendar.MINUTE, 0);
		targetDate.set(Calendar.SECOND, 0);
		
		boolean isTonight = dateInfo.contains("tonight");
		if (isTonight) {
			targetDate.set(Calendar.HOUR_OF_DAY, 23);
			targetDate.set(Calendar.MINUTE, 59);
		}
	}

	/**
	 * This function is used to check whether the time is out of bounds
	 * If yes, it will throw an IllegalArgumentException with indicated message
	 */
	private void checkTimeBound(GregorianCalendar tempDate) {
		try {
			tempDate.get(Calendar.HOUR_OF_DAY);
			tempDate.get(Calendar.MINUTE);
		} catch (IllegalArgumentException e) {
			throw new IllegalArgumentException("Out of bounds");
		}
	}

	// Check whether the dateInfo may contain TIME format
	private boolean hasTimeFormat() {
		return dateInfo.contains(":") || dateInfo.contains("am")|| dateInfo.contains("pm");
	}
	
	// Check if the string can be converted into an integer
	private boolean isInteger(String s) {
		try {
			Integer.parseInt(s);
			return true;
		} catch (NumberFormatException e) {
			return false;
		}
	}
	
	// Check whether the time of sourceDate is just less than 6 hours before the current time
	private boolean lessThan6Hours() {
		return (sourceDate.getTimeInMillis() - currentDate.getTimeInMillis()) <= SIX_HOURS_IN_MILLIS;
	}
	
	/**
	 * This function is used to check whether the user did input the time
	 */
	private boolean hasTime(boolean isStartDate) {
		boolean isMidnight = sourceDate.get(Calendar.HOUR_OF_DAY) == 23
				&& sourceDate.get(Calendar.MINUTE) == 59;
		boolean isNewDay = sourceDate.get(Calendar.HOUR_OF_DAY) == 0
				&& sourceDate.get(Calendar.MINUTE) == 0;
		
		if (isStartDate && isNewDay) {
			return false;
		} else if (!isStartDate && isMidnight) {
			return false;
		}

		return true;
	}
	
	/**
	 * This function is used to check whether the date is today
	 */
	private boolean isToday() {
		boolean isCurrentYear = sourceDate.get(Calendar.YEAR) == currentDate.get(Calendar.YEAR);
		boolean isCurrentMonth = sourceDate.get(Calendar.MONTH) == currentDate.get(Calendar.MONTH);
		boolean isCurrentDate = sourceDate.get(Calendar.DATE) == currentDate.get(Calendar.DATE);
		
		return isCurrentYear && isCurrentMonth && isCurrentDate;
	}
	
	/**
	 * This function is used to check whether the time is tonight
	 */
	private boolean isTonight() {
		boolean isCurrentYear = sourceDate.get(Calendar.YEAR) == currentDate.get(Calendar.YEAR);
		boolean isCurrentMonth = sourceDate.get(Calendar.MONTH) == currentDate.get(Calendar.MONTH);
		boolean isCurrentDate = sourceDate.get(Calendar.DATE) == currentDate.get(Calendar.DATE);
		boolean isMidnight = (sourceDate.get(Calendar.HOUR_OF_DAY) == 23 && sourceDate.get(Calendar.MINUTE) == 59);
		
		return isCurrentYear && isCurrentMonth && isCurrentDate && isMidnight;
	}
}

	// End of segment: D:\CS2103 Proj\src\CustomDate.java





	/**
	 * origin: D:\CS2103 Proj\src\Parser.java
	 */

	/**
	 * This method is used to parse from a string of command input into a string
	 * array of necessary info for a specific command
	 * 
	 * @param userCommand
	 *            command input from the user
	 * @param commandType
	 *            command type of the command input
	 * @return the array of infos necessary for each command
	 */
	public static String[] parseCommand(String userCommand,
			Common.COMMAND_TYPES commandType, Model model, int tabIndex) {
		String content = Common.removeFirstWord(userCommand);
		content = Common.removeUnneededSpaces(content);
		
		if (isAddCommandType(commandType)) {
			return parseCommandWithInfo(content, Common.COMMAND_TYPES.ADD);
		} else if (isSearchCommandType(commandType)) {
			return parseCommandWithInfo(content, Common.COMMAND_TYPES.SEARCH);
		} else if (isEditCommandType(commandType)) {
			return parseEditCommand(content);
		} else if (isIndexCommandType(commandType)) {
			return parseIndexCommand(content, tabIndex, model);
		} else {
			return null;
		}
	}
	
	// Check if the command type is EDIT type
	private static boolean isEditCommandType(Common.COMMAND_TYPES commandType) {
		return commandType == Common.COMMAND_TYPES.EDIT;
	}
	
	// Check if the command type is SEARCH type
	private static boolean isSearchCommandType(Common.COMMAND_TYPES commandType) {
		return commandType == Common.COMMAND_TYPES.SEARCH;
	}
	
	// Check if the command type is ADD type
	private static boolean isAddCommandType(Common.COMMAND_TYPES commandType) {
		return commandType == Common.COMMAND_TYPES.ADD;
	}
	
	// Check if the command type is INDEX type
	private static boolean isIndexCommandType(Common.COMMAND_TYPES commandType) {
		return commandType == Common.COMMAND_TYPES.COMPLETE
				|| commandType == Common.COMMAND_TYPES.INCOMPLETE
				|| commandType == Common.COMMAND_TYPES.MARK
				|| commandType == Common.COMMAND_TYPES.UNMARK
				|| commandType == Common.COMMAND_TYPES.RECOVER
				|| commandType == Common.COMMAND_TYPES.REMOVE;
	}

	/**
	 * This method is used to parse from the content of the EDIT command to
	 * necessary infos
	 * 
	 * @param content
	 *            command string after removing the command type
	 * @return string array. First field is taskIndex. Second field is workInfo.
	 *         Third field is tag. Fourth field is startDateString. Fifth field
	 *         is endDateString. Sixth field is isImpt.
	 */
	private static String[] parseEditCommand(String content) {
		String[] splittedUserCommand = Common.splitBySpace(content);
		int modifiedIndex = -1;
		modifiedIndex = checkValidIndexForEditing(content, modifiedIndex);
		checkIfThereExistsTaskInfo(splittedUserCommand);

		String[] parsedCommand = mergeInfoWithIndex(content, modifiedIndex);
		return parsedCommand;
	}
	
	/**
	 * This method is used to merge the index info in EDIT command with the
	 * remaining infos
	 * 
	 * @param content
	 *            conttent of the command
	 * @param modifiedIndex
	 *            the index to be edited
	 * @return the array after merging
	 */
	private static String[] mergeInfoWithIndex(String content, int modifiedIndex) {
		String[] temp = parseCommandWithInfo(Common.removeFirstWord(content),
				Common.COMMAND_TYPES.EDIT);
		String[] parsedCommand = new String[7];
		parsedCommand[0] = String.valueOf(modifiedIndex);
		for (int i = 1; i < parsedCommand.length; i++) {
			parsedCommand[i] = temp[i - 1];
		}
		return parsedCommand;
	}
	
	// Check if the command contains info for task info
	private static void checkIfThereExistsTaskInfo(String[] splittedUserCommand) {
		if (splittedUserCommand.length < 2)
			throw new IllegalArgumentException(Common.NO_EDITING_INFO);
	}
	
	// Check if the first info in the EDIT command is a valid index
	private static int checkValidIndexForEditing(String content,
			int modifiedIndex) {
		try {
			modifiedIndex = Integer.parseInt(Common.getFirstWord(content));
		} catch (NumberFormatException e) {
			throw new IllegalArgumentException(Common.INVALID_INDEX);
		}
		return modifiedIndex;
	}
	
	// End of segment: D:\CS2103 Proj\src\Parser.java





	/**
	 * origin: D:\CS2103 Proj\src\Parser.java
	 */

	/**
	 * This method is used to parse content of commands filled with indexes to
	 * necessary infos
	 * 
	 * @param content
	 *            command string after removing the command type
	 * @return array of indexes in form of strings.
	 */
	private static String[] parseCommandWithIndex(String content) {
		String[] splittedUserCommand = Common.splitBySpace(content);
		Vector<String> indexList = new Vector<String>();
		checkIfThereExistsIndices(splittedUserCommand);
		parseIndex(splittedUserCommand, indexList);
		splittedUserCommand = indexList.toArray(new String[0]);
		return splittedUserCommand;
	}
	
	
	/**
	 * This function is the main function to parse the indices into the array
	 * 
	 * @param splittedUserCommand
	 *            the user command after splitted by spcaes
	 * @param indexList
	 *            the array vector of indices
	 */
	private static void parseIndex(String[] splittedUserCommand,
			Vector<String> indexList) {
			for (String s : splittedUserCommand) {
				boolean isRangeIndex = s.contains(Common.HYPHEN);
				if (isRangeIndex) {
					parseRange(indexList, s);
				} else {
					indexList.add(String.valueOf(Integer.parseInt(s)));
				}
			}
	}

	/**
	 * Check if there exists indices in the command or not
	 * 
	 * @param splittedUserCommand
	 *            the command after splitted by spaces
	 */
	private static void checkIfThereExistsIndices(String[] splittedUserCommand) {
		if (splittedUserCommand.length < 1)
			throw new IllegalArgumentException("No indexes");
	}
	
	/**
	 * This function is used to parse a range of indices
	 * @param indexList the vector list of indices
	 * @param range the range indicated from the command
	 */
	private static void parseRange(Vector<String> indexList, String range) {
		String[] limits = range.split(Common.HYPHEN);
		checkInvalidRangeFormat(limits);
		
		int startPoint, endPoint;
		startPoint = Integer.parseInt(limits[0]);
		endPoint = Integer.parseInt(limits[1]);
		checkInvalidRange(startPoint, endPoint);
		
		for (int i = startPoint; i <= endPoint; i++){
			indexList.add(String.valueOf(i));
		}
	}
	
	// Check if the content of the rang is valid or not
	private static void checkInvalidRange(int startPoint, int endPoint) {
		if (startPoint > endPoint){
			throw new IllegalArgumentException(Common.INVALID_RANGE_END_SMALLER);
		}
	}
	
	// Check if the format of the range is valid or not
	private static void checkInvalidRangeFormat(String[] limits) {
		if (limits.length > 2) {
			throw new IllegalArgumentException(Common.INVALID_RANGE);
		}
	}
	
	// End of segment: D:\CS2103 Proj\src\Parser.java





	/**
	 * origin: D:\CS2103 Proj\src\Settings.java
	 */

	// returns the settings stage
	public Stage getSettingsStage() {
		return settingsStage;
	}

	// End of segment: D:\CS2103 Proj\src\Settings.java





	/**
	 * origin: D:\CS2103 Proj\src\Settings.java
	 */

	// shows the selected Radiobutton based on current time display settings 
	private void showTimeDisplay(){
		if (model.doDisplayRemaining()){
			remaining.setSelected(true);
		} else { 
			exact.setSelected(true);
		}
	}
	
	// shows the theme mode and selected Radiobutton based on current theme mode 
	private void showThemeMode(){
		if (model.getThemeMode().equals(Common.DAY_MODE)) {
			dayMode.setSelected(true);
		} else {
			nightMode.setSelected(true);
		}
		
		settingsScene.getStylesheets().clear();
		if (model.getThemeMode().equals(Common.DAY_MODE)) {
			settingsScene.getStylesheets().addAll(
					getClass().getResource("dayCustomization.css").toExternalForm());
			bgImage.setImage(new Image(getClass().getResourceAsStream(
					"settings.png")));
		} else {
			settingsScene.getStylesheets().addAll(
					getClass().getResource("nightCustomization.css").toExternalForm());
			bgImage.setImage(new Image(getClass().getResourceAsStream(
					"settingsNight.png")));
		}
	}
	
	// shows the selected Combobox based on current colour scheme 
	private void showColourScheme(){
		if (model.getColourScheme() != null){
			colourSchemes.setValue(model.getColourScheme());
		}
	}
	
	// shows the selected Radiobutton and time period Textfield based on current sync settings
	private void showSyncMode(){
		if (model.hasAutoSync() == true) {
			autoSync.setSelected(true);
		} else {
			manualSync.setSelected(true);
		}
		syncPeriodTextfield.setText(String.valueOf(model.getSyncPeriod()));
	}
	
	// End of segment: D:\CS2103 Proj\src\Settings.java





	/**
	 * origin: D:\CS2103 Proj\src\Settings.java
	 */

	// set up the time format fields
	private void setupTimeFormat() {
		Label timeFormat = new Label("Time format:");
		grid.add(timeFormat, 0, 4);
		ToggleGroup toggleGroup = new ToggleGroup();
		remaining = RadioButtonBuilder.create().text("Show remaining time")
				.toggleGroup(toggleGroup).build();
		exact = RadioButtonBuilder.create().text("Show exact time")
				.toggleGroup(toggleGroup).build();
		if (model.doDisplayRemaining()){
			remaining.setSelected(true);
		} else {
			exact.setSelected(true);
		}
		grid.add(remaining, 1, 4);
		grid.add(exact, 2, 4);
	}

	// set up the theme mode fields
	private void setupThemeMode() {
		Label themeMode = new Label("Theme mode: ");
		grid.add(themeMode, 0, 5);
		ToggleGroup toggleGroup = new ToggleGroup();
		dayMode = RadioButtonBuilder.create().text(Common.DAY_MODE)
				.toggleGroup(toggleGroup).selected(true).build();
		nightMode = RadioButtonBuilder.create().text(Common.NIGHT_MODE)
				.toggleGroup(toggleGroup).build();
		if (model.getThemeMode().equals(Common.DAY_MODE)) {
			dayMode.setSelected(true);
		} else {
			nightMode.setSelected(true);
		}
		grid.add(dayMode, 1, 5);
		grid.add(nightMode, 2, 5);
	}
	
	// End of segment: D:\CS2103 Proj\src\Settings.java





	/**
	 * origin: D:\CS2103 Proj\src\Settings.java
	 */

	// set up the sync period field
	private void setupSyncPeriod(){
		Label syncPeriod = new Label("Sync period: ");
		grid.add(syncPeriod, 0, 8);
		syncPeriodTextfield = new TextField();
		syncPeriodTextfield.setId("input");
		syncPeriodTextfield.textProperty().addListener(new ChangeListener<String>() {
		    @Override
		    public void changed(ObservableValue<? extends String> observable,
		            String oldValue, String newValue) {
		        try {
		            // force numeric value by resetting to old value if exception is thrown
		            Integer.parseInt(newValue);
		            // force correct length by resetting to old value if longer than maxLength
		            if(newValue.length() > 4 || Integer.parseInt(newValue) == 0)
		                syncPeriodTextfield.setText(oldValue);
		        } catch (Exception e) {
		        	if(!newValue.equals(""))
		            syncPeriodTextfield.setText(oldValue);
		        }
		    }
		});
		
		syncPeriodTextfield.focusedProperty().addListener(new ChangeListener<Boolean>() {
			public void changed(ObservableValue<? extends Boolean> ov, Boolean oldVal, Boolean newVal){
				if(newVal == false){
					if(syncPeriodTextfield.getText().equals(""))
							syncPeriodTextfield.setText("1");
				}
			}
		});
		syncPeriodTextfield.setMaxWidth(50);
		syncPeriodTextfield.setText(String.valueOf(model.getSyncPeriod()));
		Label minutes = new Label("minute(s)");
		HBox hb = new HBox();
		hb.setAlignment(Pos.CENTER_LEFT);
		hb.setSpacing(10);
		hb.getChildren().addAll(syncPeriodTextfield, minutes);
		grid.add(hb, 1, 8);
	}

	// End of segment: D:\CS2103 Proj\src\Settings.java





	/**
	 * origin: D:\CS2103 Proj\src\SwingNode.java
	 */

/**
 * Swing "integration" on top of this JavaFX node
 * This is an original class from Arnaud Nouard with lots of modifications to be fit for the currently working project
 * The purpose of this class is to create a JavaFX node that can display a Swing node
 */
public class SwingNode extends Region {
	/*
     * Windows offset (Frame decoration bounds)
     * Should be dynamically determined
     */
    private static int STAGE_BORDER_X = 8;
    private static int STAGE_BORDER_Y = 30;
    // The dialog that wraps around the Swing component
    private JDialog jDialog;
    // The parent stage
    private Stage stage;
    private boolean isKeyEvent;
    // The listeners
    private ChangeListener<Number> changeListenerH;
    private ChangeListener<Bounds> changeListenerBIL;
    private ChangeListener<Number> changeListenerW;
    private ChangeListener<Number> changeListenerStageX;
    private ChangeListener<Number> changeListenerStageY;
    // The frame for the component
    private JFrame jFrameParent;
    
	/**
	 * Constructor of this class
	 * 
	 * @param orgStage
	 *            the original stage i.e main window
	 * @param jcomponent
	 *            the component in Swing
	 */
    public SwingNode(Stage orgStage, final Component jcomponent) {
    	this(orgStage, jcomponent, STAGE_BORDER_X, STAGE_BORDER_X);
    }
    
    /**
     * The main constructor of this class
     * @param orgStage the parent stage
     * @param jcomponent the Swing component
     * @param offsetX offset in X-direction
     * @param offsetY offset in Y-direction
     */
    public SwingNode(Stage orgStage, final Component jcomponent, int offsetX, int offsetY) {
        this.stage = orgStage;
        wrapSwingComponent(jcomponent);
        setupListeners();
    }
    
    /**
     * Setup listeners for the stage
     */
	private void setupListeners() {
		setupListenerToBounds();
        setupListenerToStageX();
        setupListenerToStageY();
        setupListenerToShowProperty();
        setupListenerToFocusProperty();
        setupListenerToVisibleProperty();
	}
	
	// Listener to the visible property
	private void setupListenerToVisibleProperty() {
		super.
        visibleProperty().addListener(new ChangeListener<Boolean>() {

            @Override
            public void changed(ObservableValue<? extends Boolean> ov, Boolean t, Boolean t1) {
                jDialog.setVisible(t1.booleanValue());
            }
        });
	}
	
	// Listener to the focus property 
	private void setupListenerToFocusProperty() {
		stage.focusedProperty()
                .addListener(new ChangeListener<Boolean>() {
            @Override
            public void changed(ObservableValue<? extends Boolean> ov, Boolean t, final Boolean newValue) {
                SwingUtilities.invokeLater(new Runnable() {
                    @Override
                    public void run() {
                        setSwingComponentAlwaysOnTop(newValue.booleanValue());
                       if(newValue.booleanValue() == false){
                    	   if(!isKeyEvent){
                    		   checkMousePosition();
                    	   }
                       }
                       isKeyEvent = false;
                    }

					private void checkMousePosition() {
						PointerInfo mouseInfo = MouseInfo.getPointerInfo();
						Point mousePosition = mouseInfo.getLocation();
						double x = mousePosition.getX();
						double y = mousePosition.getY();
						boolean check1 = x < stage.getX();
						boolean check2 = x > stage.getX() + stage.getWidth();
						boolean check3 = y < stage.getY();
						boolean check4 = y > stage.getY() + stage.getHeight();
						if (check1 || check2 || check3 || check4) {
							jDialog.toBack();
							stage.toBack();
						}
					}
                });
               
            }
        });
	}
	
	// Listener to the show property
	private void setupListenerToShowProperty() {
		stage.showingProperty()
                .addListener(new ChangeListener<Boolean>() {
            @Override
            public void changed(ObservableValue<? extends Boolean> ov, Boolean t, final Boolean t1) {
                SwingUtilities.invokeLater(new Runnable() {
                    @Override
                    public void run() {
                        jDialog.setVisible(t1.booleanValue());
                    }
                });
            }
        });
	}
	
	// Listener to the Stage Y-Position
	private void setupListenerToStageY() {
		changeListenerStageY = new ChangeListener<Number>() {
            @Override
            public void changed(ObservableValue<? extends Number> ov, Number t, final Number t1) {
                SwingUtilities.invokeLater(new Runnable() {
                    @Override
                    public void run() {
                        Rectangle bounds = jDialog.getBounds();
                        bounds.y = t1.intValue();
                        Point2D jCoord = new Point2D(bounds.y, bounds.y);
                        Point2D p = localToScene(jCoord);

                        bounds.y = (int)( p.getY() + stage.getHeight())+ STAGE_BORDER_Y;
                        jDialog.setBounds(bounds);
                    }
                });
            }
        };
        stage.yProperty().addListener(changeListenerStageY);
	}
	
	// Listener to the Stage X-Position
	private void setupListenerToStageX() {
		changeListenerStageX = new ChangeListener<Number>() {
            @Override
            public void changed(ObservableValue<? extends Number> ov, Number t, final Number t1) {

                SwingUtilities.invokeLater(new Runnable() {
                    @Override
                    public void run() {
                        Rectangle bounds = jDialog.getBounds();
                        bounds.x = t1.intValue();
                        Point2D jCoord = new Point2D(bounds.x, bounds.x);
                        Point2D p = localToScene(jCoord);

                        bounds.x = (int) p.getX() + STAGE_BORDER_X;
                        jDialog.setBounds(bounds);
                    }
                });
            }
        };
        stage.xProperty().addListener(changeListenerStageX);
	}
	
	// Listener to the bounds of the command line
	private void setupListenerToBounds() {
		changeListenerBIL = new ChangeListener<Bounds>() {
            @Override
            public void changed(ObservableValue<? extends Bounds> ov, Bounds t, Bounds bounds) {

                final Bounds boundsJFX = localToScene(bounds);
                SwingUtilities.invokeLater(new Runnable() {
                    @Override
                    public void run() {
                        Rectangle bounds = jDialog.getBounds();
                        bounds.x = (int) (boundsJFX.getMinX() + stage.getX()) + STAGE_BORDER_X;
                        bounds.y = (int) (boundsJFX.getMinY() + stage.getY() + stage.getHeight()) + STAGE_BORDER_Y;
                        bounds.width = (int) 634;
                        bounds.height = (int) 35;

                        jDialog.setBounds(bounds);
                    }
                });
            }
        };
        boundsInLocalProperty().addListener(changeListenerBIL);
	}
	
	// Wrap the Swing component in the JavaFX node
	private void wrapSwingComponent(final Component jcomponent) {
		try {
            /*
             * Wrap the Swing component with an invisible window
             */
            SwingUtilities.invokeAndWait(new Runnable() {
                @Override
                public void run() {
                    toDialog(jcomponent);
                }
            });
        } catch (InterruptedException | InvocationTargetException ex) {
            Logger.getLogger(SwingNode.class.getName()).log(Level.SEVERE, null, ex);
        }
	}
    
    // Set the key Event to notify the listener
    public void setKeyEvent(boolean isKeyEvent){
    	this.isKeyEvent = isKeyEvent;
    }
    
    // Set the command line be on top
    public void setCommandLineOnTop(){
    	SwingUtilities.invokeLater(new Runnable() {
			@Override
			public void run() {
			jDialog.toFront();
			}
		});
    }
    
    // Remove all listeners
    public void removeAllListeners() {
        boundsInLocalProperty().removeListener(changeListenerBIL);
        heightProperty().removeListener(changeListenerH);
        widthProperty().removeListener(changeListenerW);
        stage.xProperty().removeListener(changeListenerStageX);
        stage.yProperty().removeListener(changeListenerStageY);
    }

    public Container toDialog(Component comp) {
        jFrameParent = new JFrame();
        jDialog = new JDialog(jFrameParent);
       
        setSwingComponentAlwaysOnTop(false);
        setupJDialog(comp);
        jDialog.addWindowListener(new WindowListener() {
            @Override
            public void windowOpened(WindowEvent e) {
                // To ensure Stage to be set to front at the same time as Swing
            	setSwingComponentAlwaysOnTop(true);
            	Platform.runLater(new Runnable() {
                    @Override
                    public void run() {
                        stage.toFront(); 
                    }
                });
            }

            @Override
            public void windowClosing(WindowEvent e) {
            }

            @Override
            public void windowClosed(WindowEvent e) {
            }

            @Override
            public void windowIconified(WindowEvent e) {
            }

            @Override
            public void windowDeiconified(WindowEvent e) {
            }

            @Override
            public void windowActivated(WindowEvent e) {
            }

            @Override
            public void windowDeactivated(WindowEvent e) {
             
            }
        });
      
        /* Window Focus */
        jDialog.addWindowFocusListener(new WindowFocusListener() {
            @Override
            public void windowGainedFocus(WindowEvent e) {
                setSwingComponentAlwaysOnTop(true);
                Platform.runLater(new Runnable() {
                    @Override
                    public void run() {
                       stage.toFront();
                    }
                });
            }

            @Override
            public void windowLostFocus(WindowEvent e) {
            	setSwingComponentAlwaysOnTop(false);
            	jDialog.toBack();
                Platform.runLater(new Runnable() {
                    @Override
                    public void run() {
                    	if(stage.isFocused() == false)
                        stage.toBack();
                    }
                });
            }
        }); 
        return jDialog;
    }
    
    // Setup the settings for the JDialog that will wrap around the component
	private void setupJDialog(Component comp) {
		jDialog.setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE); // Avoid ALT+F4
        jDialog.setUndecorated(true);
        jDialog.getContentPane().add(comp);
        jDialog.setType(Window.Type.UTILITY);
        jDialog.setModalExclusionType(Dialog.ModalExclusionType.NO_EXCLUDE);
        jDialog.setResizable(false);
        jDialog.setFocusable(true);
        jDialog.setAutoRequestFocus(true);
	}
    
    // Set that the Swing component is always above all applications
    public void setSwingComponentAlwaysOnTop(boolean value) {
        jDialog.setAlwaysOnTop(value);
    }
    
    // Set stage to front most of the window
    public void setStageToFront() {
        stage.toFront();
    }
    
    // Dispose the SwingNode
    public void dispose() {
        removeAllListeners();
        SwingUtilities.invokeLater(new Runnable() {
            @Override
            public void run() {
                jFrameParent.dispose();
                jDialog.setAlwaysOnTop(false);
                jDialog.setVisible(false);
                jDialog.dispose();
            }
        });
    }
}
	// End of segment: D:\CS2103 Proj\src\SwingNode.java





	/**
	 * origin: D:\CS2103 Proj\src\Synchronization.java
	 */

	/**
	 * This function is used to update both the modified tasks on iDo and
	 * modified events on Google Calendar to be the same with each other
	 * 
	 * @param service
	 *            the currently connected service
	 * @param model
	 *            the model of the application
	 * @param entries
	 *            the entries in Google Calendar
	 * @param feedURL
	 *            the URL of the calendar
	 */
	private void updateModifiedTasks(CalendarService service, Model model,
			List<CalendarEventEntry> entries, URL feedURL)
			throws ServiceException, IOException {
		List<CalendarEventEntry> toBeUpdatedOnGCal = new ArrayList<CalendarEventEntry>();
		List<Task> pendingList = model.getPendingList();
		for (int i = 0; i < pendingList.size(); i++) {
			if (pendingList.get(i).getStatus() == Task.Status.UNCHANGED) {
				checkEntriesForUpdate(service, entries, feedURL,
						toBeUpdatedOnGCal, pendingList, i);
			}
		}
		updateEvents(service, toBeUpdatedOnGCal, feedURL);
	}
	
	/**
	 * This function find the correct entry from list of entries in Google
	 * Calendar with the same ID from the task on iDo It then compares the
	 * latest modified date between the event and the task to determine which
	 * latest version to update
	 * 
	 * @param service
	 *            the currently connected service
	 * @param entries
	 *            list of event entries on Google Calendar
	 * @param feedURL
	 *            the URL of the calendar
	 * @param toBeUpdatedOnGCal
	 *            list of events to be updated on Google Calendar
	 * @param pendingList
	 *            the list of pending tasks
	 * @param i
	 *            the index of the task
	 */
	private void checkEntriesForUpdate(CalendarService service,
			List<CalendarEventEntry> entries, URL feedURL,
			List<CalendarEventEntry> toBeUpdatedOnGCal, List<Task> pendingList,
			int i) throws IOException, ServiceException {
		for (int j = 0; j < entries.size(); j++) {
			boolean isSameId = pendingList.get(i).getIndexId().equals(entries.get(j).getId());
			if (isSameId) {
				DateTime updated = entries.get(j).getUpdated();
				updated.setTzShift(8 * 60);
				boolean hasLatestModificationFromiDo = CustomDate.compare(pendingList.get(i)
						.getLatestModifiedDate(), new CustomDate(
						updated)) > 0;
				if (hasLatestModificationFromiDo) {
					updateModifiedEventOnGCal(service, entries,feedURL, toBeUpdatedOnGCal, pendingList, i, j);
				} else {
					updateModifiedTaskOniDo(entries, pendingList, i, j);
				}
				break;
			}
		}
	}

	/**
	 * This function is used to update a task on iDo to be the same with an
	 * event entry on Google Calendar
	 * 
	 * @param entries
	 *            the list of entries on Google Calendar
	 * @param pendingList
	 *            the list of pending tasks
	 * @param i
	 *            the index of the task
	 * @param j
	 *            the index of the entry
	 */
	private void updateModifiedTaskOniDo(List<CalendarEventEntry> entries,
			List<Task> pendingList, int i, int j) {
		
		Task editedTask = pendingList.get(i);
		editedTask.setWorkInfo(
				entries.get(j).getTitle().getPlainText());
		try {
			setupDateForTimedTask(entries, j, editedTask);
		} catch (IndexOutOfBoundsException e) {
			String recurData = entries.get(j).getRecurrence().getValue();
			if (recurData.contains("VALUE=DATE:")) {
				setupDateForAllDayRecurringTask(editedTask, recurData);
			} else {// timed recurring event
				setupDateForTimedRecurringTask(editedTask, recurData);
			}

		}

		if (!entries.get(j).getReminder().isEmpty()) {
			editedTask.setIsImportant(true);
		} else {
			editedTask.setIsImportant(false);
		}
		editedTask.updateLatestModifiedDate();
	}
	
	/**
	 * This function is used to update an event on Google Calendar to be the
	 * same with a task on iDo
	 * 
	 * @param service
	 *            the currently connected service
	 * @param entries
	 *            the list of entries on Google Calendar
	 * @param feedURL
	 *            the URl of the calendar
	 * @param toBeUpdatedOnGCal
	 *            the list of events to be updated on Google Calendar
	 * @param pendingList
	 *            the list of pending tasks
	 * @param i
	 *            the index of the task
	 * @param j
	 *            the index of the event entry
	 */
	private void updateModifiedEventOnGCal(CalendarService service,
			List<CalendarEventEntry> entries, URL feedURL,
			List<CalendarEventEntry> toBeUpdatedOnGCal, List<Task> pendingList,
			int i, int j) throws IOException, ServiceException {
		entries.get(j).setTitle(
				new PlainTextConstruct(pendingList.get(i)
						.getWorkInfo()));
		
		if (isNormalTask(pendingList, i)) {
			updateToNormalEntry(service, entries, feedURL, toBeUpdatedOnGCal, pendingList, i, j);
		} else {
			updateToRecurrenceEntry(entries, toBeUpdatedOnGCal, pendingList, i, j);
		}
		
		if (pendingList.get(i).isImportantTask() == true) {
			setReminder(entries.get(j));
		} else {
			entries.get(j).getReminder().clear();
		}
	}
	
	/**
	 * This function is used to update an event entry to a normal entry
	 * 
	 * @param service
	 *            the currently connected service
	 * @param entries
	 *            the list of entries on Google Calendar
	 * @param feedURL
	 *            the URL of the calendar
	 * @param toBeUpdatedOnGCal
	 *            the list of entries to be updated on Google Calendar
	 * @param pendingList
	 *            the list of pending tasks in iDo
	 * @param i
	 *            the index of task
	 * @param j
	 *            the index of entry
	 */
	private void updateToNormalEntry(CalendarService service,
			List<CalendarEventEntry> entries, URL feedURL,
			List<CalendarEventEntry> toBeUpdatedOnGCal, List<Task> pendingList,
			int i, int j) throws IOException, ServiceException {
		if (isNormalEntry(entries, j)) {
			entries.get(j).getTimes().get(0).setStartTime(
							pendingList.get(i).getStartDate().returnInDateTimeFormat());
			entries.get(j).getTimes().get(0).setEndTime(
							pendingList.get(i).getEndDate().returnInDateTimeFormat());
			toBeUpdatedOnGCal.add(entries.get(j));
		} else {
			convertFromRecurringToNormalEntry(service, entries, feedURL, pendingList, i, j);
		}
	}
	
	/**
	 * This function is used to update an event entry to a recurrence entry
	 * 
	 * @param entries
	 *            the list of entries in Google Calendar
	 * @param toBeUpdatedOnGCal
	 *            the list of entries to be updated on Google Calendar
	 * @param pendingList
	 *            the list of pending tasks in iDo
	 * @param i
	 *            the index of the task
	 * @param j
	 *            the index of the entry
	 */
	private void updateToRecurrenceEntry(List<CalendarEventEntry> entries,
			List<CalendarEventEntry> toBeUpdatedOnGCal, List<Task> pendingList,
			int i, int j) {
		entries.get(j).getTimes().clear();
		if (!pendingList.get(i).isFloatingTask()) {
			String startDate = pendingList.get(i)
					.getStartDate()
					.returnInRecurringFormat();
			String endDate = pendingList.get(i)
					.getEndDate()
					.returnInRecurringFormat();
			String freq = pendingList.get(i).getTag()
					.getRepetition();
			int interval = pendingList.get(i).getTag()
					.getInterval();
			int count = pendingList.get(i)
					.getNumOccurrences();
			
			String recurData = setRecurrenceData(startDate, endDate, freq, null, count, interval);
			Recurrence rec = new Recurrence();
			rec.setValue(recurData);
			entries.get(j).setRecurrence(rec);
		}
		toBeUpdatedOnGCal.add(entries.get(j));
	}
	
	// End of segment: D:\CS2103 Proj\src\Synchronization.java





	/**
	 * origin: D:\CS2103 Proj\src\Task.java
	 */

	// Default constructor
	public Task() {
		checkProperty();
		defaultInitialization();
	}
	
	/*
	 * Default initialization for all properties 
	 */
	private void defaultInitialization() {
		setRowStatus(new RowStatus(false, false));
		setStartDate(null);
		setStartDateString(EMPTY);
		setEndDate(null);
		setEndDateString(EMPTY);
		setWorkInfo("");
		setTag(new Tag(EMPTY, "null"));
		indexId = "";
		indexInList = 0;
		if(Control.syncThread!=null && Control.syncThread.isRunning()){
			setStatus(Status.ADDED_WHEN_SYNC);
		}else{
			setStatus(Status.NEWLY_ADDED);
		}
		updateLatestModifiedDate();
		initOccurrence(1);
	}

	/**
	 * This function is used to check whether any property has not been
	 * initialized. If there are, it will initialize these properties.
	 */
	private void checkProperty() {
		rowStatusProperty();
		workInfoProperty();
		tagProperty();
		startDateProperty();
		startDateStringProperty();
		endDateStringProperty();
		endDateProperty();
		occurrenceProperty();
	}

	/**
	 * This function is the implemented method for interface Comparable. It is
	 * used to compare this task with another task. The order of comparison is
	 * first end date, start date and work info respectively.
	 */
	public int compareTo(Task other) {
		int compareEndDates = CustomDate.compare(getEndDate(),
				other.getEndDate());
		int compareStartDates = CustomDate.compare(getStartDate(),
				other.getStartDate());

		boolean equalEndDate = (compareEndDates == 0);
		boolean equalStartAndEndDate = (compareEndDates == 0)
				&& (compareStartDates == 0);

		if (equalStartAndEndDate) {
			return getWorkInfo().compareToIgnoreCase(other.getWorkInfo());
		} else if (equalEndDate) {
			return compareStartDates;
		} else {
			return compareEndDates;
		}
	}

	/**
	 * Update the string representing the date for display
	 */
	public void updateDateString() {
		boolean hasStartDate = getStartDate() != null;
		boolean hasEndDate = getEndDate() != null;
		if (hasStartDate) {
			setStartDateString(getStartDate().toString(IS_START_DATE));
		}

		if (hasEndDate) {
			setEndDateString(getEndDate().toString(IS_END_DATE));
		}
	}
	
	// End of segment: D:\CS2103 Proj\src\Task.java





	/**
	 * origin: D:\CS2103 Proj\src\Task.java
	 */

	/**
	 * Update the start date to new date with given difference in milliseconds
	 * between the new and the old ones
	 * 
	 * @param difference
	 *            time between 2 dates
	 */
	private void updateStartDate(long difference) {
		CustomDate startDate = getStartDate();
		startDate.setTimeInMillis(startDate.getTimeInMillis() + difference);
		setStartDate(startDate);
		setStartDateString(getStartDate().toString(IS_START_DATE));
	}

	/**
	 * Update the end date to new date with given difference in milliseconds
	 * between the new and the old ones
	 * 
	 * @param difference
	 *            time between 2 dates
	 */
	private void updateEndDate(long difference) {
		CustomDate endDate = getEndDate();
		endDate.setTimeInMillis(endDate.getTimeInMillis() + difference);
		setEndDate(endDate);
		setEndDateString(getEndDate().toString(IS_END_DATE));
	}

	/**
	 * This function is used to check whether this task is a repetitive task
	 * 
	 * @return true if this is indeed a recurring task, vice versa
	 */
	public boolean isRecurringTask() {
		return !tag.get().getRepetition().equals(Common.NULL);
	}
	
	/**
	 * This function is used to check whether this task is an overdue task
	 * @return true if this is indeed an overdue task, vice versa
	 */
	public boolean isOverdueTask() {
		if (getEndDate() != null){
			return getEndDate().beforeCurrentTime();
		}
		return false;
	}
	
	// End of segment: D:\CS2103 Proj\src\Task.java





	/**
	 * origin: D:\CS2103 Proj\src\Task.java
	 */

	/************************ GET Property Functions **********************************/
	public ObjectProperty<RowStatus> rowStatusProperty() {
		if (rowStatus == null) {
			rowStatus = new SimpleObjectProperty<RowStatus>(this, ROWSTATUS_PROPERTY_ID);
		}
		return rowStatus;
	}

	public StringProperty workInfoProperty() {
		if (workInfo == null) {
			workInfo = new SimpleStringProperty(this, WORKINFO_PROPERTY_ID);
		}
		return workInfo;
	}

	public ObjectProperty<Tag> tagProperty() {
		if (tag == null) {
			tag = new SimpleObjectProperty<Tag>(this, TAG_PROPERTY_ID);
		}
		return tag;
	}

	public ObjectProperty<CustomDate> startDateProperty() {
		if (startDate == null) {
			startDate = new SimpleObjectProperty<CustomDate>(this, STARTDATE_PROPERTY_ID);
		}
		return startDate;
	}

	public ObjectProperty<CustomDate> endDateProperty() {
		if (endDate == null) {
			endDate = new SimpleObjectProperty<CustomDate>(this, ENDDATE_PROPERTY_ID);
		}
		return endDate;
	}

	public StringProperty startDateStringProperty() {
		if (startDateString == null) {
			startDateString = new SimpleStringProperty(this, START_STRING_PROPERTY_ID);
		}
		return startDateString;
	}

	public StringProperty endDateStringProperty() {
		if (endDateString == null) {
			endDateString = new SimpleStringProperty(this, END_STRING_PROPERTY_ID);
		}
		return endDateString;
	}

	public StringProperty occurrenceProperty() {
		if (occurrenceString == null) {
			occurrenceString = new SimpleStringProperty(this, OCCURRENCE_PROPERTY_ID);
		}
		return occurrenceString;
	}

	/********************************* GET Value Functions ***********************************/
	public boolean isLastOverdueTask() {
		return rowStatus.get().getIsLastOverdue();
	}

	public boolean isImportantTask() {
		return rowStatus.get().getIsImportant();
	}
	
	public boolean isFloatingTask(){
		return getStartDate() == null && getEndDate() == null;
	}
	
	public RowStatus getRowStatus(){
		return rowStatus.get();
	}

	public String getStartDateString() {
		return startDateString.get();
	}

	public String getEndDateString() {
		return endDateString.get();
	}

	public CustomDate getStartDate() {
		return startDate.get();
	}

	public CustomDate getEndDate() {
		return endDate.get();
	}

	public String getWorkInfo() {
		return workInfo.get();
	}

	public Tag getTag() {
		return tag.get();
	}

	public String getIndexId() {
		return indexId;
	}

	public int getIndexInList() {
		return indexInList;
	}

	public Status getStatus() {
		return status;
	}

	public CustomDate getLatestModifiedDate() {
		return latestModifiedDate;
	}

	public boolean hasNewlyAddedStatus() {
		return status == Status.NEWLY_ADDED || status == Status.ADDED_WHEN_SYNC;
	}

	public boolean hasDeletedStatus() {
		return status == Status.DELETED || status == Status.DELETED_WHEN_SYNC;
	}

	public boolean hasUnchangedStatus() {
		return status == Status.UNCHANGED;
	}
	
	// End of segment: D:\CS2103 Proj\src\Task.java





	/**
	 * origin: D:\CS2103 Proj\src\Task.java
	 */

	/*************************************** SET Value Functions ****************************************/
	public void setIsLastOverdue(boolean isLastOverdue) {
		rowStatus.set(new RowStatus(rowStatus.get().getIsImportant(), isLastOverdue));
	}

	public void setIsImportant(boolean isImportant) {
		rowStatus.set(new RowStatus(isImportant, rowStatus.get().getIsLastOverdue()));
	}
	
	public void setRowStatus(RowStatus rowStatus){
		this.rowStatus.set(rowStatus);
	}

	public void setStatus(Status status) {
		this.status = status;
	}

	public void setStartDate(CustomDate startDate) {
		this.startDate.set(startDate);
		if (startDate != null) {
			setStartDateString(startDate.toString(true));
		} else {
			setStartDateString(EMPTY);
		}
	}

	public void setEndDate(CustomDate endDate) {
		this.endDate.set(endDate);
		if (endDate != null) {
			setEndDateString(endDate.toString(false));
		} else {
			setEndDateString(EMPTY);
		}
	}

	public void setStartDateString(String dateString) {
		startDateString.set(dateString);
	}

	public void setEndDateString(String dateString) {
		endDateString.set(dateString);
	}

	public void setWorkInfo(String workInfo) {
		this.workInfo.set(workInfo);
	}

	public void setTag(Tag tag) {
		this.tag.set(tag);
	}

	public void setIndexId(String indexId) {
		this.indexId = indexId;
	}

	public void setIndexInList(int index) {
		indexInList = index;
	}

	public void setLatestModifiedDate(CustomDate modifiedDate) {
		latestModifiedDate = modifiedDate;
	}

	public void updateLatestModifiedDate() {
		latestModifiedDate = new CustomDate();
	}
	
	// End of segment: D:\CS2103 Proj\src\Task.java





	/**
	 * origin: D:\CS2103 Proj\src\Task.java
	 */

/**
 * 
 * This class is used to stored the information of tag of a task
 * A tag comprises the information of the recurring and category tags.
 *
 */
class Tag {
	// The default category tag
	private String tag;
	// The recurring tag
	private String repetition;
	
	
	/*
	 * Constructor
	 */
	public Tag(String tag, String repetition) {
		setTag(tag);
		setRepetition(repetition);
	}
	
	/********************************************** SET functions ******************************************/
	public void setTag(String tag) {
		this.tag = tag;
	}

	public void setRepetition(String repetition) {
		this.repetition = repetition;
	}
	
	/************************************************ GET functions ******************************************/
	public String getTag() {
		return this.tag;
	}

	public String getRepetition() {
		return this.repetition;
	}

	/**
	 * This function is used to get the interval in the recurrence tag For
	 * example, "every 3 weeks" will return 3 while "every day" will return -1
	 * as there is no intervals.
	 * 
	 * @return the required interval
	 */
	public int getInterval() {
		int startIndex = repetition.indexOf("every");
		if(startIndex != -1){
			int endIndex;
			if(repetition.contains("day")){
				endIndex = repetition.indexOf("day");
			} else if(repetition.contains("week")){
				endIndex = repetition.indexOf("week");				
			} else if(repetition.contains("month")){
				endIndex = repetition.indexOf("month");
			} else{
				endIndex = repetition.indexOf("year");				
			}
			int interval = Integer.parseInt(repetition.substring(startIndex+5, endIndex).trim());
			return interval;
		}
		return -1;
	}
}

	// End of segment: D:\CS2103 Proj\src\Task.java





	/**
	 * origin: D:\CS2103 Proj\src\Task.java
	 */

/**
 * 
 * This class is used to store the current status of a task whether it is
 * important or the last overdue task in the list
 * 
 */
class RowStatus{
	// Important indicator
	private boolean isImportant;
	// Last overdue indicator
	private boolean isLastOverdue;
	
	/*
	 * Constructor
	 */
	public RowStatus(boolean isImportant, boolean isLastOverdue){
		this.isImportant = isImportant;
		this.isLastOverdue = isLastOverdue;
	}
	
	/**************************************** SET functions ******************************************/
	public void setIsImportant(boolean isImportant){
		this.isImportant = isImportant;
	}
	
	public void setIsLastOverdue(boolean isLastOverdue){
		this.isLastOverdue = isLastOverdue;
	}
	
	/****************************************** GET functions *********************************************/
	public boolean getIsImportant(){
		return this.isImportant;
	}
	
	public boolean getIsLastOverdue(){
		return this.isLastOverdue;
	}
}
	// End of segment: D:\CS2103 Proj\src\Task.java





	/**
	 * origin: D:\CS2103 Proj\src\TestCommand.java
	 */

public class TestCommand {
	Model testModel = new Model();
	Command testCommand;
	String[] parsedInfo;

	@Test
	public void test() {
		// ADD command
		testAddCommand();
		// MARK command
		testMarkCommand();
		// UNMARK command
		testUnmarkCommand();
		// EDIT command
		testEditCommand();
		// REMOVE command
		testRemoveCommand();
		// RECOVER command
		testRecoverCommand();
		// COMPLETE command
		testCompleteCommand();
		// INCOMPLETE command
		testIncompleteCommand();
	}

	private void testIncompleteCommand() {
		parsedInfo = Parser.parseCommand("incomplete 1", Common.COMMAND_TYPES.INCOMPLETE, testModel, 1);
		testCommand = new IncompleteCommand(parsedInfo, testModel, 1);
		assertEquals("Test INCOMPLETE command", "Indicated task(s) has/have been marked as incomplete.",testCommand.execute());
		
		try{
			parsedInfo = Parser.parseCommand("incomplete 1", Common.COMMAND_TYPES.COMPLETE, testModel, 0);
			testCommand = new IncompleteCommand(parsedInfo, testModel, 0);
			testCommand.execute();
		} catch(IllegalArgumentException e){
			assertEquals("Test INCOMPLETE command","Cannot incomplete the tasks in this current tab.", e.getMessage());
		}
	}

	private void testCompleteCommand() {
		parsedInfo = Parser.parseCommand("complete 1", Common.COMMAND_TYPES.COMPLETE, testModel, 0);
		testCommand = new CompleteCommand(parsedInfo, testModel, 0);
		assertEquals("Test COMPLETE command", "Indicated task(s) has/have been marked as complete.",testCommand.execute());
		
		try{
			parsedInfo = Parser.parseCommand("complete 1", Common.COMMAND_TYPES.COMPLETE, testModel, 1);
			testCommand = new CompleteCommand(parsedInfo, testModel, 1);
			testCommand.execute();
		} catch(IllegalArgumentException e){
			assertEquals("Test COMPLETE command","Cannot complete the tasks in this current tab.", e.getMessage());
		}
	}

	private void testRecoverCommand() {
		parsedInfo = Parser.parseCommand("recover 1", Common.COMMAND_TYPES.RECOVER, testModel, 2);
		testCommand = new RecoverCommand(parsedInfo, testModel, 2);
		assertEquals("Test RECOVER command", "Indicated task(s) has/have been recovered successfully.",testCommand.execute());
		
		try{
			parsedInfo = Parser.parseCommand("recover 1", Common.COMMAND_TYPES.RECOVER, testModel, 1);
			testCommand = new RecoverCommand(parsedInfo, testModel, 1);
			testCommand.execute();
		} catch(IllegalArgumentException e){
			assertEquals("Test REMOVE command","Cannot recover the tasks in this current tab.", e.getMessage());
		}
	}

	private void testRemoveCommand() {
		parsedInfo = Parser.parseCommand("remove 1", Common.COMMAND_TYPES.REMOVE, testModel, 0);
		testCommand = new RemoveCommand(parsedInfo, testModel, 0);
		assertEquals("Test REMOVE command", "Indicated tasks has/have been removed.",testCommand.execute());
		
		try{
			parsedInfo = Parser.parseCommand("remove 1-5", Common.COMMAND_TYPES.REMOVE, testModel, 1);
			testCommand = new RemoveCommand(parsedInfo, testModel, 1);
			testCommand.execute();
		} catch(IllegalArgumentException e){
			assertEquals("Test REMOVE command","There is an index outside the range of the list.", e.getMessage());
		}
	}

	public void testAddCommand() {
		parsedInfo = Parser.parseCommand("add JUnit Test from 6pm to 8pm", Common.COMMAND_TYPES.ADD, testModel, 0);
		testCommand = new AddCommand(parsedInfo, testModel, 0);
		assertEquals("Test ADD command", "One task has been added successfully.",testCommand.execute());
		
		parsedInfo = Parser.parseCommand("add CS2103 demo from 13/11 1:30pm to 2pm", Common.COMMAND_TYPES.ADD, testModel, 0);
		testCommand = new AddCommand(parsedInfo, testModel, 0);
		assertEquals("Test ADD command", "One task has been added successfully.",testCommand.execute());
		
		parsedInfo = Parser.parseCommand("add CS2105 last lecture from 11/11 2pm to 4pm", Common.COMMAND_TYPES.ADD, testModel, 0);
		testCommand = new AddCommand(parsedInfo, testModel, 0);
		assertEquals("Test ADD command", "One task has been added successfully.",testCommand.execute());
		
		parsedInfo = Parser.parseCommand("add CS2101 Written Test from 11/11 10am to 12pm", Common.COMMAND_TYPES.ADD, testModel, 0);
		testCommand = new AddCommand(parsedInfo, testModel, 0);
		assertEquals("Test ADD command", "One task has been added successfully.",testCommand.execute());
		
		try{
			parsedInfo = Parser.parseCommand("add from 6pm to 8pm", Common.COMMAND_TYPES.ADD, testModel, 0);
			testCommand = new AddCommand(parsedInfo, testModel, 0);
			testCommand.execute();
		} catch(IllegalArgumentException e){
			assertEquals("Test ADD command", "Invalid command: work information cannot be empty.", e.getMessage());
		}
		
		try{
			parsedInfo = Parser.parseCommand("add from 6pm from 7pm", Common.COMMAND_TYPES.ADD, testModel, 0);
			testCommand = new AddCommand(parsedInfo, testModel, 0);
			testCommand.execute();
		} catch(IllegalArgumentException e){
			assertEquals("Test ADD command", "Invalid Command: Multiple Dates", e.getMessage());
		}
		
		try{
			parsedInfo = Parser.parseCommand("add from 6pm from 7pm", Common.COMMAND_TYPES.ADD, testModel, 0);
			testCommand = new AddCommand(parsedInfo, testModel, 0);
			testCommand.execute();
		} catch(IllegalArgumentException e){
			assertEquals("Test ADD command", "Invalid Command: Multiple Dates", e.getMessage());
		}
		
		try{
			parsedInfo = Parser.parseCommand("add multiple asterisks * *", Common.COMMAND_TYPES.ADD, testModel, 0);
			testCommand = new AddCommand(parsedInfo, testModel, 0);
			testCommand.execute();
		} catch(IllegalArgumentException e){
			assertEquals("Test ADD command", "Invalid Command: multiple important marks(*).", e.getMessage());
		}
		
		try{
			parsedInfo = Parser.parseCommand("add multiple hastags # #", Common.COMMAND_TYPES.ADD, testModel, 0);
			testCommand = new AddCommand(parsedInfo, testModel, 0);
			testCommand.execute();
		} catch(IllegalArgumentException e){
			assertEquals("Test ADD command", "Invalid Command: multiple hash tags(#).", e.getMessage());
		}
		
		try{
			parsedInfo = Parser.parseCommand("add end time before start time from 6pm to 5pm", Common.COMMAND_TYPES.ADD, testModel, 0);
			testCommand = new AddCommand(parsedInfo, testModel, 0);
			testCommand.execute();
		} catch(IllegalArgumentException e){
			assertEquals("Test ADD command", "Invalid date range as start date is after end date.", e.getMessage());
		}
		
		try{
			parsedInfo = Parser.parseCommand("add end time before current time by 9/11", Common.COMMAND_TYPES.ADD, testModel, 0);
			testCommand = new AddCommand(parsedInfo, testModel, 0);
			testCommand.execute();
		} catch(IllegalArgumentException e){
			assertEquals("Test ADD command", "Invalid date as end time is before the current time", e.getMessage());
		}
		
		try{
			parsedInfo = Parser.parseCommand("add recurring task from 2/11 weekly", Common.COMMAND_TYPES.ADD, testModel, 0);
			testCommand = new AddCommand(parsedInfo, testModel, 0);
			testCommand.execute();
		} catch(IllegalArgumentException e){
			assertEquals("Test ADD command", "There must be both start and end dates for repetitive task.", e.getMessage());
		}
		
		try{
			parsedInfo = Parser.parseCommand("add recurring task from 2/11 to 13/11 weekly", Common.COMMAND_TYPES.ADD, testModel, 0);
			testCommand = new AddCommand(parsedInfo, testModel, 0);
			testCommand.execute();
		} catch(IllegalArgumentException e){
			assertEquals("Test ADD command","The difference is larger than the limit of repetitive period.", e.getMessage());
		}
	}
	
	
	public void testMarkCommand(){
		parsedInfo = Parser.parseCommand("mark 1 2", Common.COMMAND_TYPES.MARK, testModel, 0);
		testCommand = new MarkCommand(parsedInfo, testModel, 0);
		assertEquals("Test MARK command", "Indicated task(s) has/have been marked successfully.",testCommand.execute());
		
		try{
			parsedInfo = Parser.parseCommand("mark 1 6", Common.COMMAND_TYPES.MARK, testModel, 0);
			testCommand = new MarkCommand(parsedInfo, testModel, 0);
			testCommand.execute();
		} catch(IllegalArgumentException e){
			assertEquals("Test MARK command","There is an index outside the range of the list.", e.getMessage());
		}
		
		try{
			parsedInfo = Parser.parseCommand("mark 3-1", Common.COMMAND_TYPES.MARK, testModel, 0);
			testCommand = new MarkCommand(parsedInfo, testModel, 0);
			testCommand.execute();
		} catch(IllegalArgumentException e){
			assertEquals("Test MARK command","Invalid range as end point is smaller than start point", e.getMessage());
		}
	}
	
	public void testUnmarkCommand(){
		parsedInfo = Parser.parseCommand("unmark 1", Common.COMMAND_TYPES.UNMARK, testModel, 0);
		testCommand = new UnmarkCommand(parsedInfo, testModel, 0);
		assertEquals("Test UNMARK command", "Indicated task(s) has/have been unmarked successfully.",testCommand.execute());
		
		try{
			parsedInfo = Parser.parseCommand("unmark 3 3", Common.COMMAND_TYPES.UNMARK, testModel, 0);
			testCommand = new UnmarkCommand(parsedInfo, testModel, 0);
			testCommand.execute();
		} catch(IllegalArgumentException e){
			assertEquals("Test UNMARK command","There are duplicate indexes!", e.getMessage());
		}
	}
	
	public void testEditCommand() {
		try{
			parsedInfo = Parser.parseCommand("edit 1 from 7pm to 9pm", Common.COMMAND_TYPES.EDIT, testModel, 0);
			testCommand = new EditCommand(parsedInfo, testModel, 0);
			testCommand.execute();
		} catch(IllegalArgumentException e){
			assertEquals("Test EDIT command", "Indicated task has been edited successfully.", e.getMessage());
		}
		
		try{
			parsedInfo = Parser.parseCommand("edit 3 #cs2103 weekly", Common.COMMAND_TYPES.EDIT, testModel, 0);
			testCommand = new EditCommand(parsedInfo, testModel, 0);
			testCommand.execute();
		} catch(IllegalArgumentException e){
			assertEquals("Test EDIT command", "Indicated task has been edited successfully.", e.getMessage());
		}
		
		try{
			parsedInfo = Parser.parseCommand("edit no index", Common.COMMAND_TYPES.EDIT, testModel, 0);
			testCommand = new EditCommand(parsedInfo, testModel, 0);
			testCommand.execute();
		} catch(IllegalArgumentException e){
			assertEquals("Test EDIT command", "Invalid index", e.getMessage());
		}
	}
}

	// End of segment: D:\CS2103 Proj\src\TestCommand.java





	/**
	 * origin: D:\CS2103 Proj\src\TestCustomDate.java
	 */

// This class contains test cases for class CustomDate
public class TestCustomDate {
	CustomDate currentTime;
	CustomDate testTime;
	
	@Test
	public void test() {
		currentTime = new CustomDate();
		
		testTime = new CustomDate();
		testTime.convert("21 Oct 12:30");
		assertEquals("CustomDate with normal valid date info", "21/10/2013 12:30", CustomDate.convertString(testTime));
		
		testTime = new CustomDate();
		testTime.convert("21/12 13:29");
		assertEquals("CustomDate with date in slash format", "21/12/2013 13:29", CustomDate.convertString(testTime));
		
		testTime = new CustomDate();
		testTime.convert("3/1/2014 6:47");
		assertEquals("CustomDate with date in next year", "3/1/2014 6:47", CustomDate.convertString(testTime));

		testTime = new CustomDate();
		testTime.convert("8-6-2013");
		assertEquals("CustomDate with date in dash format without indicating time","8/6/2013 0:0", CustomDate.convertString(testTime));
		
		testTime = new CustomDate();
		testTime.convert("15/10/2013 630am");
		assertEquals("CustomDate with date in slash format and time in integer format", "15/10/2013 6:30", CustomDate.convertString(testTime));
		
		testTime = new CustomDate();
		testTime.convert("32 October");
		assertEquals("CustomDate with invalid date", CustomDate.convertString(currentTime), CustomDate.convertString(testTime));
		
		testTime = new CustomDate();
		testTime.convert("21/13");
		assertEquals("CustomDate with invalid month", CustomDate.convertString(currentTime), CustomDate.convertString(testTime));
		
		testTime = new CustomDate();
		testTime.convert("21/-1");
		assertEquals("CustomDate with invalid negative month", CustomDate.convertString(currentTime), CustomDate.convertString(testTime));
		
		testTime = new CustomDate();
		testTime.convert("-32 October");
		assertEquals("CustomDate with invalid negative date", CustomDate.convertString(currentTime), CustomDate.convertString(testTime));
		
		testTime = new CustomDate();
		testTime.convert("21 October 25:30");
		assertEquals("CustomDate with invalid hour", CustomDate.convertString(currentTime), CustomDate.convertString(testTime));
		
		testTime = new CustomDate();
		testTime.convert("32 October 4:80");
		assertEquals("CustomDate with invalid minute", CustomDate.convertString(currentTime), CustomDate.convertString(testTime));
		
		testTime = new CustomDate();
		testTime.convert("21/12/2013/5");
		assertEquals("CustomDate with excessive slashses", CustomDate.convertString(currentTime), CustomDate.convertString(testTime));
		
		testTime = new CustomDate();
		testTime.convert("32 October 12305");
		assertEquals("CustomDate with invalid hour in integer format", CustomDate.convertString(currentTime), CustomDate.convertString(testTime));
		
		testTime = new CustomDate();
		testTime.convert("32 October -1:59");
		assertEquals("CustomDate with invalid negative hour", CustomDate.convertString(currentTime), CustomDate.convertString(testTime));
		
		testTime = new CustomDate();
		testTime.convert("21/5/-2013 4:80");
		assertEquals("CustomDate with invalid negative year", CustomDate.convertString(currentTime), CustomDate.convertString(testTime));
		
		testTime = new CustomDate();
		testTime.convert("25 Feb 4:-34");
		assertEquals("CustomDate with invalid negative minute", CustomDate.convertString(currentTime), CustomDate.convertString(testTime));
		
		testTime = new CustomDate();
		testTime.convert("3 Maru 4:50");
		assertEquals("CustomDate with invalid month due to typo", CustomDate.convertString(currentTime), CustomDate.convertString(testTime));
		
		testTime = new CustomDate();
		testTime.convert("35/15 34:80");
		assertEquals("CustomDate with more than 1 invalid fields", CustomDate.convertString(currentTime), CustomDate.convertString(testTime));
	}

}

	// End of segment: D:\CS2103 Proj\src\TestCustomDate.java





	/**
	 * origin: D:\CS2103 Proj\src\TestMain.java
	 */

public class TestMain {
	TestHistory historyTest = new TestHistory();
	TestTask taskTest = new TestTask();
	TestCustomDate customDateTest = new TestCustomDate();
	TestParser parserTest = new TestParser();
	TestCommand commandTest = new TestCommand();
	TestTaskStorage taskStorageTest = new TestTaskStorage();
	TestSettingsStorage settingsStorageTest = new TestSettingsStorage();
	TestEncryptor encryptorTest = new TestEncryptor();
	TestIntegrated integratedTest = new TestIntegrated();
	TestSynchronization synchronizationTest = new TestSynchronization();
		
	@Test
	public void test() {
		// Logic test
		historyTest.test();
		taskTest.test();
		customDateTest.test();
		parserTest.test();
		commandTest.test();
		
		// Storage test
		TestTaskStorage.testSetup();
		taskStorageTest.test();
		TestSettingsStorage.testSetup();
		settingsStorageTest.test();
		TestEncryptor.testSetup();
		encryptorTest.test();
		
		// Integrated testing
		TestIntegrated.testSetup();
		integratedTest.test();
		
		synchronizationTest.test();
	}

}

	// End of segment: D:\CS2103 Proj\src\TestMain.java





	/**
	 * origin: D:\CS2103 Proj\src\TestParser.java
	 */

public class TestParser {
	String[] parsedInfo;
	
	@Test
	public void test() {
		// Check empty command
		assertTrue("Check empty command", Parser.checkEmptyCommand("         "));
		assertFalse("Check non empty command", Parser.checkEmptyCommand("non empty command"));
		
		// Check ADD command type
		testParsingAdd();
		
		// Check REMOVE command type
		testParsingRemove();
		
		// Check SEARCH command type
		testParsingSearch();
		
		// Check RECOVER command type
		testParsingRecover();
		
		// Check EDIT command type
		testParsingEdit();
		
		// Check COMPLETE command type
		testParsingComplete();
		
		// Check INCOMPLETE command type
		testParsingIncomplete();
			
		// Check MARK command type 
		testParsingMark();
		
		// Check UNMARK command type
		testParsingUnmark();
		
		// Check SHOW_ALL command type
		testParsingShow();
		
		// Check EXIT command type
		testParsingExit();
		
		// Check HELP command type
		testParsingHelp();
		
		// Check SETTINGS command type
		testParsingSettings();
		
		// Check SYNC command type
		testParsingSync();
		
		// Check TODAY command type
		testParsingToday();
		
		// Check UNDO command type
		testParsingUndo();
		
		// Check REDO command type
		testParsingRedo();
		
		// Check CLEAR command type
		testParsingClear();
		
	}
	
	public void testParsingClear() {
		assertEquals("Check CLEAR command type", Common.COMMAND_TYPES.CLEAR_ALL, Parser.determineCommandType("clear JUnit Test"));
		assertEquals("Check CLEAR command type", Common.COMMAND_TYPES.CLEAR_ALL, Parser.determineCommandType("clr JUnit Test"));
		assertNull(Parser.parseCommand("clear JUnit Test", Common.COMMAND_TYPES.CLEAR_ALL, null, 0));
		assertNull(Parser.parseCommand("clr", Common.COMMAND_TYPES.CLEAR_ALL, null, 0));
	}
	
	
	public void testParsingRedo() {
		assertEquals("Check REDO command type", Common.COMMAND_TYPES.REDO, Parser.determineCommandType("redo JUnit Test"));
		assertNull(Parser.parseCommand("redo JUnit Test", Common.COMMAND_TYPES.REDO, null, 0));
	}
	
	
	public void testParsingUndo() {
		assertEquals("Check UNDO command type", Common.COMMAND_TYPES.UNDO, Parser.determineCommandType("undo JUnit Test"));
		assertNull(Parser.parseCommand("undo", Common.COMMAND_TYPES.UNDO, null, 0));
	}
	
	
	public void testParsingToday() {
		assertEquals("Check TODAY command type", Common.COMMAND_TYPES.TODAY, Parser.determineCommandType("today JUnit Test"));
		assertNull(Parser.parseCommand("today", Common.COMMAND_TYPES.TODAY, null, 0));
	}
	
	
	public void testParsingSync() {
		assertEquals("Check SYNC command type", Common.COMMAND_TYPES.SYNC, Parser.determineCommandType("sYnc JUnit Test"));
		assertNull(Parser.parseCommand("sync JUnit Test", Common.COMMAND_TYPES.SYNC, null, 0));
	}
	

	public void testParsingSettings() {
		assertEquals("Check SETTINGS command type", Common.COMMAND_TYPES.SETTINGS, Parser.determineCommandType("settings JUnit Test"));
		assertNull(Parser.parseCommand("settings", Common.COMMAND_TYPES.SETTINGS, null, 0));
	}


	public void testParsingHelp() {
		assertEquals("Check HELP command type", Common.COMMAND_TYPES.HELP, Parser.determineCommandType("help JUnit Test"));
		assertNull(Parser.parseCommand("help JUnit Test", Common.COMMAND_TYPES.HELP, null, 0));
	}
	
	
	public void testParsingExit() {
		assertEquals("Check EXIT command type", Common.COMMAND_TYPES.EXIT, Parser.determineCommandType("eXit JUnit Test"));
		assertEquals("Check EXIT command type", Common.COMMAND_TYPES.EXIT, Parser.determineCommandType("end JUnit Test"));
		assertNull(Parser.parseCommand("exit", Common.COMMAND_TYPES.EXIT, null, 0));
		assertNull(Parser.parseCommand("End JUnit Test", Common.COMMAND_TYPES.EXIT, null, 0));
	}

	
	public void testParsingShow() {
		assertEquals("Check SHOW_ALL command type", Common.COMMAND_TYPES.SHOW_ALL, Parser.determineCommandType("show JUnit Test"));
		assertEquals("Check SHOW_ALL command type", Common.COMMAND_TYPES.SHOW_ALL, Parser.determineCommandType("aLL JUnit Test"));
		assertEquals("Check SHOW_ALL command type", Common.COMMAND_TYPES.SHOW_ALL, Parser.determineCommandType("diSplay JUnit Test"));
		assertEquals("Check SHOW_ALL command type", Common.COMMAND_TYPES.SHOW_ALL, Parser.determineCommandType("liSt JUnit Test"));
		assertEquals("Check SHOW_ALL command type", Common.COMMAND_TYPES.SHOW_ALL, Parser.determineCommandType("ls JUnit Test"));
		assertNull(Parser.parseCommand("show", Common.COMMAND_TYPES.SHOW_ALL, null, 0));
		assertNull(Parser.parseCommand("all JUnit Test", Common.COMMAND_TYPES.SHOW_ALL, null, 0));
	}
	
	
	public void testParsingUnmark() throws ArrayComparisonFailure {
		assertEquals("Check UNMARK command type", Common.COMMAND_TYPES.UNMARK, Parser.determineCommandType("unmaRk JUnit Test"));
		assertEquals("Check UNMARK command type", Common.COMMAND_TYPES.UNMARK, Parser.determineCommandType("unhiGhLight JUnit Test"));
		parsedInfo = new String[] {"2", "8"};
		assertArrayEquals("Compare UNMARK command parsed result", parsedInfo, Parser.parseCommand("unmark 2 8", Common.COMMAND_TYPES.UNMARK, null, 0));
		parsedInfo = new String[] {"1", "2", "3", "4", "8", "9"};
		assertArrayEquals("Compare MARK command parsed result", parsedInfo, Parser.parseCommand("unmark 1-4 8 9", Common.COMMAND_TYPES.UNMARK, null, 0));
	}
	
	
	public void testParsingMark() throws ArrayComparisonFailure {
		assertEquals("Check MARK command type", Common.COMMAND_TYPES.MARK, Parser.determineCommandType("mark JUnit Test"));
		assertEquals("Check MARK command type", Common.COMMAND_TYPES.MARK, Parser.determineCommandType("highLight JUnit Test"));
		parsedInfo = new String[] {"3", "9"};
		assertArrayEquals("Compare MARK command parsed result", parsedInfo, Parser.parseCommand("mark 3 9", Common.COMMAND_TYPES.MARK, null, 0));
		parsedInfo = new String[] {"2", "3", "4", "5", "6"};
		assertArrayEquals("Compare MARK command parsed result", parsedInfo, Parser.parseCommand("mark 2-6", Common.COMMAND_TYPES.MARK, null, 0));
	}
	
	
	public void testParsingIncomplete() throws ArrayComparisonFailure {
		assertEquals("Check INCOMPLETE command type", Common.COMMAND_TYPES.INCOMPLETE, Parser.determineCommandType("Incomplete JUnit Test"));
		assertEquals("Check INCOMPLETE command type", Common.COMMAND_TYPES.INCOMPLETE, Parser.determineCommandType("uNdone JUnit Test"));
		parsedInfo = new String[] {"12", "4"};
		assertArrayEquals("Compare INCOMPLETE command parsed result", parsedInfo, Parser.parseCommand("incomplete 12 4", Common.COMMAND_TYPES.INCOMPLETE, null, 0));
		parsedInfo = new String[] {"2", "3", "4", "5", "1", "2", "3", "4"};
		assertArrayEquals("Compare INCOMPLETE command parsed result", parsedInfo, Parser.parseCommand("incomplete 2-5 1-4", Common.COMMAND_TYPES.INCOMPLETE, null, 0));
	}
	
	
	public void testParsingComplete() throws ArrayComparisonFailure {
		assertEquals("Check COMPLETE command type", Common.COMMAND_TYPES.COMPLETE, Parser.determineCommandType("complete JUnit Test"));
		assertEquals("Check COMPLETE command type", Common.COMMAND_TYPES.COMPLETE, Parser.determineCommandType("doNe JUnit Test"));
		parsedInfo = new String[] {"1", "3"};
		assertArrayEquals("Compare COMPLETE command parsed result", parsedInfo, Parser.parseCommand("complete 1 3", Common.COMMAND_TYPES.COMPLETE, null, 0));
		parsedInfo = new String[] {"2", "3", "6", "7"};
		assertArrayEquals("Compare COMPLETE command parsed result", parsedInfo, Parser.parseCommand("complete 2-3 6-7", Common.COMMAND_TYPES.COMPLETE, null, 0));
	}
	
	
	public void testParsingEdit() throws ArrayComparisonFailure {
		assertEquals("Check EDIT command type", Common.COMMAND_TYPES.EDIT, Parser.determineCommandType("Edit JUnit Test"));
		assertEquals("Check EDIT command type", Common.COMMAND_TYPES.EDIT, Parser.determineCommandType("mod JUnit Test"));
		assertEquals("Check EDIT command type", Common.COMMAND_TYPES.EDIT, Parser.determineCommandType("mOdify JUnit Test"));
		assertEquals("Check EDIT command type", Common.COMMAND_TYPES.EDIT, Parser.determineCommandType("set JUnit Test"));
		parsedInfo = new String[] {"2", "null", "#cs2103", "5 Aug", "28 Dec",
				"true", "null"};
		assertArrayEquals("Compare EDIT command parsed result", parsedInfo,
				Parser.parseCommand(
						"edit 2 from 5 Aug to 28 Dec #cs2103 *",
						Common.COMMAND_TYPES.EDIT, null, 0));
		parsedInfo = new String[] {"5", "JUnit Test", "null", "null", "null",
				"false", "weekly 3 times"};
		assertArrayEquals("Compare EDIT command parsed result", parsedInfo,
				Parser.parseCommand(
						"edit 5 JUnit Test weekly 3 times",
						Common.COMMAND_TYPES.EDIT, null, 0));
	}
	
	
	public void testParsingRecover() throws ArrayComparisonFailure {
		assertEquals("Check RECOVER command type", Common.COMMAND_TYPES.RECOVER, Parser.determineCommandType("recover JUnit Test"));
		assertEquals("Check RECOVER command type", Common.COMMAND_TYPES.RECOVER, Parser.determineCommandType("rEc JUnit Test"));
		parsedInfo = new String[] {"2", "1", "7"};
		assertArrayEquals("Compare RECOVER command parsed result", parsedInfo, Parser.parseCommand("recover 2 1 7", Common.COMMAND_TYPES.RECOVER, null, 0));
		parsedInfo = new String[] {"5", "6", "7", "8"};
		assertArrayEquals("Compare RECOVER command parsed result", parsedInfo, Parser.parseCommand("recover 5-8", Common.COMMAND_TYPES.RECOVER, null, 0));
	}
	

	public void testParsingSearch() throws ArrayComparisonFailure {
		assertEquals("Check SEARCH command type", Common.COMMAND_TYPES.SEARCH, Parser.determineCommandType("search JUnit Test"));
		assertEquals("Check SEARCH command type", Common.COMMAND_TYPES.SEARCH, Parser.determineCommandType("finD JUnit Test"));
		parsedInfo = new String[] { "null", "#cs2103", "21/12", "23 Dec",
				"true", "null" };
		assertArrayEquals("Compare SEARCH command parsed result", parsedInfo,
				Parser.parseCommand(
						"search from 21/12 to 23 Dec #cs2103 *",
						Common.COMMAND_TYPES.SEARCH, null, 0));
		parsedInfo = new String[] { "JUnit test", "null", "3 Sep 1230am", "null",
				"false", "null" };
		assertArrayEquals("Compare SEARCH command parsed result", parsedInfo,
				Parser.parseCommand(
						"search JUnit test from 3 Sep 1230am",
						Common.COMMAND_TYPES.SEARCH, null, 0));
		parsedInfo = new String[] { "null", "#cs2103t", "null", "2 Nov",
				"true", "null" };
		assertArrayEquals("Compare SEARCH command parsed result", parsedInfo,
				Parser.parseCommand(
						"search * by 2 Nov #cs2103t",
						Common.COMMAND_TYPES.SEARCH, null, 0));
	}
	
	
	public void testParsingRemove() throws ArrayComparisonFailure {
		assertEquals("Check REMOVE command type", Common.COMMAND_TYPES.REMOVE, Parser.determineCommandType("remove JUnit test"));
		assertEquals("Check REMOVE command type", Common.COMMAND_TYPES.REMOVE, Parser.determineCommandType("Delete JUnit test"));
		assertEquals("Check REMOVE command type", Common.COMMAND_TYPES.REMOVE, Parser.determineCommandType("rM JUnit test"));
		assertEquals("Check REMOVE command type", Common.COMMAND_TYPES.REMOVE, Parser.determineCommandType("del JUnit test"));
		parsedInfo = new String[] {"2", "4", "8"};
		assertArrayEquals("Compare REMOVE command parsed result", parsedInfo, Parser.parseCommand("remove 2 4 8", Common.COMMAND_TYPES.REMOVE, null, 0));
	}
	
	
	public void testParsingAdd() throws ArrayComparisonFailure {
		assertEquals("Check ADD command type", Common.COMMAND_TYPES.ADD, Parser.determineCommandType("add JUnit test"));
		assertEquals("Check ADD command type", Common.COMMAND_TYPES.ADD, Parser.determineCommandType("inserT JUnit test"));
		parsedInfo = new String[] { "JUnit test", "#cs2103", "21/12", "23 Dec",
				"true", "null" };
		assertArrayEquals("Compare ADD command parsed result", parsedInfo,
				Parser.parseCommand(
						"add JUnit test from 21/12 to 23 Dec #cs2103 *",
						Common.COMMAND_TYPES.ADD, null, 0));
		parsedInfo = new String[] { "JUnit test", "#cs2101", "11-9 3:30",
				"21/10 6:30am", "false", "null" };
		assertArrayEquals(
				"Compare ADD command parsed result",
				parsedInfo,
				Parser.parseCommand(
						"insert JUnit test from 11-9 3:30 by 21/10 6:30am #cs2101",
						Common.COMMAND_TYPES.ADD, null, 0));
		try{
			Parser.parseCommand("add # #", Common.COMMAND_TYPES.ADD, null, 0);
			Parser.parseCommand("add from 21/10 to 23/12", Common.COMMAND_TYPES.ADD, null, 0);
			Parser.parseCommand("add * *", Common.COMMAND_TYPES.ADD, null, 0);
			assertTrue(false);
		} catch(IllegalArgumentException e){
			assertTrue(true);
		}
	}
}

	// End of segment: D:\CS2103 Proj\src\TestParser.java





	/**
	 * origin: D:\CS2103 Proj\src\TestTask.java
	 */

public class TestTask {
	Task testTask;
	
	@Test
	public void test() {
		testTask = new Task();
		// Check number of occurrences
		assertEquals("Compare initial occurrence", 1, testTask.getNumOccurrences());
		
		// Check the current occurrence
		assertEquals("Compare the current occurrence", 1, testTask.getCurrentOccurrence());
		
		// Compare the initial task info
		assertEquals("Compare the initial task info", "", testTask.getWorkInfo());
		
		// Update the task info
		testTask.setWorkInfo("Using JUnit test");
		assertEquals("Compare the updated task info", "Using JUnit test", testTask.getWorkInfo());
		
		// Update the start date
		assertNull("Check the initial start date", testTask.getStartDate());
		testTask.setStartDate(new CustomDate("21/10/2013"));
		assertEquals("Compare the updated start date", "21/10/2013 0:0", CustomDate.convertString(testTask.getStartDate()));
		
		// Update the end date
		assertNull("Check the initial end date", testTask.getEndDate());
		testTask.setEndDate(new CustomDate("5/12/2013 12:30"));
		assertEquals("Compare the updated end date", "5/12/2013 12:30" , CustomDate.convertString(testTask.getEndDate()));
		
		// Compare the start date string
		assertEquals("Compare the string of start date", "21 Oct", testTask.getStartDateString());
		// Compare the end date string
		assertEquals("Compare the string of end date", "5 Dec\n 12:30", testTask.getEndDateString());
		
		// Update the tag
		assertEquals("Compare the tag", "-", testTask.getTag().getTag());
		testTask.setTag(new Tag("JUnitTest", "null"));
		assertEquals("Compare the updated tag", "JUnitTest", testTask.getTag().getTag());
		
		// Update the tag and the type of repetition
		testTask.setTag(new Tag("iDo", "weekly"));
		assertEquals("Compare the updated tag", "iDo", testTask.getTag().getTag());
		assertEquals("Compare the updated type of repetition","weekly", testTask.getTag().getRepetition());
		
		// Update only the type of repetition
		testTask.getTag().setRepetition("every3weeks");
		assertEquals("Compare the updated tag", "iDo", testTask.getTag().getTag());
		assertEquals("Compare the updated type of repetition","every3weeks", testTask.getTag().getRepetition());
		
		// Compare the interval
		assertEquals("Compare the interval from the updated type of repetition", 3, testTask.getTag().getInterval());
		
		// Check indicator for overdue task
		assertFalse("Check if it is pending task", testTask.isOverdueTask());
		testTask.setEndDate(new CustomDate("5/11/2013 13:10"));
		assertEquals("Compare the updated end date", "5/11/2013 13:10", CustomDate.convertString(testTask.getEndDate()));
		assertTrue("Check if it becomes overdue task", testTask.isOverdueTask());
		
		// Check indicator for floating task
		assertFalse("Check if it is a timed task", testTask.isFloatingTask());
		testTask.setStartDate(null);
		testTask.setEndDate(null);
		assertTrue("Check if it is a floating task", testTask.isFloatingTask());
		
		// Check indicator for important task
		assertFalse("Check if it is a normal task", testTask.isImportantTask());
		testTask.setIsImportant(true);
		assertTrue("Check if it is an important task", testTask.isImportantTask());
		
		// Check indicator for recurring task
		assertTrue("Check if it is a recurring task", testTask.isRecurringTask());
		testTask.getTag().setRepetition("null");
		assertFalse("Check if it is a timed task", testTask.isRecurringTask());
		
		// Compare status
		assertEquals("Check the initial status", Task.Status.NEWLY_ADDED, testTask.getStatus());
		testTask.setStatus(Task.Status.DELETED);
		assertEquals("Check the updated status", Task.Status.DELETED, testTask.getStatus());
		testTask.setStatus(Task.Status.UNCHANGED);
		assertEquals("Check the updated status", Task.Status.UNCHANGED, testTask.getStatus());
	}	
}

	// End of segment: D:\CS2103 Proj\src\TestTask.java





	/**
	 * origin: D:\CS2103 Proj\src\View.java
	 */

	/**
	 * This is the constructor for class View. It will create the content in the
	 * GUI and setup the scene for the stage in Control class.
	 * 
	 * @param model
	 *            model of lists of tasks
	 * @param primaryStage
	 *            main stage of the GUI
	 */
	public View(final Model model, final Stage primaryStage) {
		initializeKeyVariables(model, primaryStage);
		setupGlobalHotkey();
		setupMainGUI();
		showLoginPage();
		setupScene();
		setupPopupWindows();
		showInitialMessage();
	}

	public Stage getStage(){
		return stage;
	}

	public StackPane getMainRoot(){
		return mainRoot;
	}

	// Get the reference to the command line of the application
	public JTextPane getCommandLine() {
		return commandLine;
	}

	// Get the reference to tray icon of the application
	public TrayIcon getTrayIcon() {
		return trayIcon;
	}

	public TableView<Task> getPendingTable(){
		return taskPendingList;
	}

	public TableView<Task> getCompleteTable(){
		return taskCompleteList;
	}

	public TableView<Task> getTrashTable(){
		return taskTrashList;
	}

	/**
	 * Initialize the key variables in the View class
	 * 
	 * @param model
	 *            the infos of task and setting that will be shown to the user
	 * @param primaryStage
	 *            the main window of the application
	 */
	private void initializeKeyVariables(Model model, Stage primaryStage) {
		stage = primaryStage;
		this.model = model;
	}

	/**
	 * Setup the main window of the application
	 */
	private void setupStage() {
		stage.setWidth(760);
		stage.setHeight(540);
		setInitialPosition();
		stage.initStyle(StageStyle.UNDECORATED);
		stage.setTitle("iDo");
		setIcon();
	}

	/**
	 * Setup the scene to be shown in the main stage i.e main window
	 */
	private void setupScene() {
		stage.setHeight(70.0);
		scene = new Scene(mainRoot);
		customizeGUI();
		stage.setScene(scene);
		stage.show();
		setInitialState();
		setupScrollBar();
	}

	/**
	 * This function is the main function to setup all the important nodes in
	 * the interface
	 */
	private void setupMainGUI() {
		setupStage();
		setupSystemTray();
		Platform.setImplicitExit(false);
		createContent();
		setupDraggable();
		setupShortcuts();
	}
	
	// End of segment: D:\CS2103 Proj\src\View.java





	/**
	 * origin: D:\CS2103 Proj\src\View.java
	 */

	/**
	 * Look up for the reference to the vertical scroll bar from the given
	 * TableView object
	 */
	private ScrollBar lookUpVerticalScrollBar(TableView<Task> list) {
		for (Node n : list.lookupAll(".scroll-bar")) {
			if (n instanceof ScrollBar) {
				ScrollBar temp = (ScrollBar) n;
				if (temp.getOrientation() == Orientation.VERTICAL){
					return temp;
				}
			}
		}
		return null;
	}

	// Get the corresponding scroll bar from the given tab index
	private ScrollBar getScrollBar(int tab) {
		assert tab >= 0 && tab <= 2;
		if (tab == Common.PENDING_TAB) {
			return pendingBar;
		} else if (tab == Common.COMPLETE_TAB) {
			return completeBar;
		} else if (tab == Common.TRASH_TAB) {
			return trashBar;
		}
		return null;
	}

	/**
	 * This function is used to setup the scroll bars for all tables in the
	 * application
	 */
	private void setupScrollBar() {
		pendingBar = lookUpVerticalScrollBar(taskPendingList);
		completeBar = lookUpVerticalScrollBar(taskCompleteList);
		trashBar = lookUpVerticalScrollBar(taskTrashList);

		InputMap map = commandLine.getInputMap();
		assert map != null;
		
		setupScrollUpKeyForCommandLine(map);
		setupScrollDownKeyForCommandLine(map);
	}

	// Setup scroll up key
	@SuppressWarnings("serial")
	private void setupScrollUpKeyForCommandLine(InputMap map) {
		KeyStroke scrollUpKey = KeyStroke.getKeyStroke(
				com.sun.glass.events.KeyEvent.VK_UP, 0);
		Action scrollUpAction = new AbstractAction() {
			@Override
			public void actionPerformed(java.awt.event.ActionEvent e) {
				Platform.runLater(new Runnable() {
					@Override
					public void run() {
						processScrollingUp();
					}
				});
			}
		};
		map.put(scrollUpKey, scrollUpAction);
	}

	// Setup scroll down key
	@SuppressWarnings("serial")
	private void setupScrollDownKeyForCommandLine(InputMap map) {
		KeyStroke scrollDownKey = KeyStroke.getKeyStroke(
				com.sun.glass.events.KeyEvent.VK_DOWN, 0);
		Action scrollDownAction = new AbstractAction() {
			@Override
			public void actionPerformed(java.awt.event.ActionEvent e) {
				Platform.runLater(new Runnable() {
					@Override
					public void run() {
						processScrollingDown();
					}
				});
			}
		};
		map.put(scrollDownKey, scrollDownAction);
	}

	/**
	 * Process scrolling down the table
	 */
	private void processScrollingDown() {
		ScrollBar modifiedScrollBar = getScrollBar(getTabIndex());
		boolean isAtMaxHeight = modifiedScrollBar.getValue() >= modifiedScrollBar
				.getMax();
		if (!isAtMaxHeight) {
			modifiedScrollBar.setValue(modifiedScrollBar.getValue() + 0.2);
		}
	}
	
	/**
	 * Process scrolling up the table
	 */
	private void processScrollingUp() {
		ScrollBar modifiedScrollBar = getScrollBar(getTabIndex());
		boolean isAtMinHeight = modifiedScrollBar.getValue() <= modifiedScrollBar
				.getMin();
		if (!isAtMinHeight) {
			modifiedScrollBar.setValue(modifiedScrollBar.getValue() - 0.2);
		}
	}
	
	/**
	 * Setup the shorcuts in the application
	 */
	private void setupShortcuts() {
		setupStageFocusProperty();
		setupShortcutForJavaFXNodes();
		setupShortcutsForCommandLine();
	}
	
	/**
	 * Setup the stage focus listener for the main window. When the main window is focused, it will automatically focus on the subRoot node.
	 */
	private void setupStageFocusProperty() {
		stage.focusedProperty().addListener(new ChangeListener<Boolean>() {
			public void changed(ObservableValue<? extends Boolean> ov,
					Boolean oldVal, Boolean newVal) {
				boolean isFocused = newVal.booleanValue() == true;
				if (isFocused) {
					subRoot.requestFocus();
				}
			}
		});
	}
	
	// Setup shortcut for the command line
	private void setupShortcutsForCommandLine() {
		InputMap map = commandLine.getInputMap();
		commandLine.setFocusTraversalKeysEnabled(false);
		setupChangeTabShortcutForCommandLine(map);
		setupOtherKeyShortcutsForCommandLine();
	}
	
	// Setup all shortcuts apart from the change tab shortcuts for the command line
	private void setupOtherKeyShortcutsForCommandLine() {
		commandLine.addKeyListener(new KeyListener() {
			@Override
			public void keyTyped(java.awt.event.KeyEvent e) {
			}

			@Override
			public void keyReleased(java.awt.event.KeyEvent e) {
			}
			
			/**
			 * Setup the event handling when certain keys are pressed
			 */
			@Override
			public void keyPressed(java.awt.event.KeyEvent e) {
				boolean isCollapseShortcut = (e.getKeyCode() == java.awt.event.KeyEvent.VK_UP)
						&& e.isControlDown();
				boolean isExpandShortcut = (e.getKeyCode() == java.awt.event.KeyEvent.VK_DOWN)
						&& e.isControlDown();
				boolean isHideShortcut = (e.getKeyCode() == java.awt.event.KeyEvent.VK_H
						&& e.isControlDown() && e.isShiftDown());
				boolean isTraditionalCloseShortcut = (e.getKeyCode() == java.awt.event.KeyEvent.VK_F4 && e
						.isAltDown());
				
				if (isCollapseShortcut) {
					setupCollapseShortuctForCommandLine();
				} else if (isExpandShortcut) {
					setupExpandShortcutForCommandLine();
				} else if (isHideShortcut || isTraditionalCloseShortcut) {
					setupHideShortcutForCommandLine();
				}
			}
			
			// Setup hide shortcut for command line
			private void setupHideShortcutForCommandLine() {
				Platform.runLater(new Runnable() {
					@Override
					public void run() {
						hide();
					}
				});
			}
			
			// Setup the expand shortcut for command line
			private void setupExpandShortcutForCommandLine() {
				Platform.runLater(new Runnable() {
					@Override
					public void run() {
						expandAnimation();
					}
				});
			}
			
			// Setup the collapse shortcut for command line
			private void setupCollapseShortuctForCommandLine() {
				Platform.runLater(new Runnable() {
					@Override
					public void run() {
						collapseAnimation();
					}
				});
			}
		});
	}
	
	/**
	 * Set change tab shortcut for the command line
	 * @param map the input map of key bindings for command line
	 */
	@SuppressWarnings("serial")
	private void setupChangeTabShortcutForCommandLine(InputMap map) {
		KeyStroke changeTabKey = KeyStroke.getKeyStroke(
				com.sun.glass.events.KeyEvent.VK_TAB,
				java.awt.event.InputEvent.CTRL_DOWN_MASK);
		Action changeTabAction = new AbstractAction() {
			@Override
			public void actionPerformed(java.awt.event.ActionEvent e) {
				Platform.runLater(new Runnable() {
					@Override
					public void run() {
						processChangingTab();
					}
				});
			}
		};

		map.put(changeTabKey, changeTabAction);
	}
	
	// Set up the shortcuts for all JavaFX nodes apart from the Swing command line
	private void setupShortcutForJavaFXNodes() {
		subRoot.setOnKeyPressed(new EventHandler<KeyEvent>() {
			public void handle(KeyEvent keyEvent) {
				setupChangeTabShortcut(keyEvent);
				if (Common.collapseWindow.match(keyEvent)) {
					collapseAnimation();
				} else if (Common.expandWindow.match(keyEvent)) {
					expandAnimation();
				} else if (Common.hideWindow.match(keyEvent) || Common.traditionalCloseWindow.match(keyEvent)) {
					hide();
				} else if (keyEvent.getCode() == KeyCode.BACK_SPACE) {
					setupBackspaceShortcut();
				} else if (keyEvent.getCode() == KeyCode.UP) {
					setupUpShortcut();
				} else if (keyEvent.getCode() == KeyCode.DOWN) {
					setupDownShortcut();
				} else if (keyEvent.getCode() == KeyCode.RIGHT) {
					setupRightShortcut();
				} else if (keyEvent.getCode() == KeyCode.LEFT) {
					setupLeftShortuct();
				} else {
					setupOtherKeyCharactersShortcut(keyEvent);
				}
			}
			
			// Set focus on command line
			private void setFocusOnCommandLine() {
				textField.setKeyEvent(true);
				textField.setCommandLineOnTop();
				commandLine.requestFocus();
			}
			
			// Set LEFT ARROW shortcut. Focus on the command line and move the caret to the left by 1 character
			private void setupLeftShortuct() {
				setFocusOnCommandLine();
				int pos = commandLine.getCaretPosition();
				boolean isAtTheStart = pos == 0;
				if (!isAtTheStart) {
					commandLine.setCaretPosition(pos - 1);
				}
			}
			
			// Set RIGHT ARROW shortcut. Focus on the commandline and move the caret to the right by 1 character
			private void setupRightShortcut() {
				setFocusOnCommandLine();
				int pos = commandLine.getCaretPosition();
				boolean isAtTheEnd = pos == commandLine.getText().length();
				if (!isAtTheEnd) {
					commandLine.setCaretPosition(pos + 1);
				}
			}
			
			// Set DOWN ARROW shortcut. Scroll down the table
			private void setupDownShortcut() {
				processScrollingDown();
			}
			
			// Set UP ARROW shortcut. Scroll up the table
			private void setupUpShortcut() {
				processScrollingUp();
			}
			
			// Set backspace shortcut. Focus on the command line and delete the latest character
			private void setupBackspaceShortcut() {
				setFocusOnCommandLine();
				int pos = commandLine.getCaretPosition();
				boolean isAtTheStart = pos == 0;
				if (!isAtTheStart) {
					commandLine.setText(commandLine.getText().substring(0, pos - 1)
							+ commandLine.getText().substring(pos));
					commandLine.setCaretPosition(pos - 1);
				}
			}
			
			// Set change tab shortcut
			private void setupChangeTabShortcut(KeyEvent e) {
				if (Common.changeTab.match(e)) {
					processChangingTab();
				}
			}
			
			// Set other key characters shortcut apart from all listed keys
			private void setupOtherKeyCharactersShortcut(KeyEvent e) {
				setFocusOnCommandLine();
				if (e.getCode() != KeyCode.ENTER) {
					int pos = commandLine.getCaretPosition();
					commandLine.setText(commandLine.getText().substring(0, pos) + e.getText()
							+ commandLine.getText().substring(pos));
					if (pos != commandLine.getText().length()){
						commandLine.setCaretPosition(pos + 1);
					}
				}
			}
		});
	}
	
	/**
	 * Process the action of changing tab in the tab pane
	 */
	private void processChangingTab() {
		int tabIndex = getTabIndex();
		assert tabIndex >= 0 && tabIndex <= 2;
		if (tabIndex != Common.TRASH_TAB) {
			tabPane.getSelectionModel().selectNext();
		} else {
			tabPane.getSelectionModel().selectFirst();
		}
	}
	
	/**
	 * Create the command line for the application with multi color text
	 */
	private void createCommandLine() {
		commandLine = new JTextPane();
		commandLine.setAutoscrolls(false);
		setFont();
		// Create panel
		JPanel noWrapPanel = new JPanel(new BorderLayout());
		noWrapPanel.add(commandLine);
		// Create scroll pane
		JScrollPane scrollPane = new JScrollPane(noWrapPanel);
		scrollPane
				.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
		scrollPane
				.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_NEVER);
		scrollPane.setBorder(null);
		// Create the SwingNode custom class to represent a Swing node in JavaFX
		textField = new SwingNode(stage, scrollPane);
		textField.setTranslateX(36);
		textField.setTranslateY(-93);
	}

	/**
	 * Setup font for the command line
	 */
	private void setFont() {
		MutableAttributeSet attrs = commandLine.getInputAttributes();
		java.awt.Font customFont = getDefaultFont();
		try {
			customFont = loadCustomFont();
			registerFont(customFont);
		} catch (Exception e) {
			logger.log(Level.INFO, "Cannot read font");
		}
		updateCustomFont(attrs, customFont);
	}

	// Update the new custom font for the application
	private void updateCustomFont(MutableAttributeSet attrs,
			java.awt.Font customFont) {
		StyleConstants.setFontFamily(attrs, customFont.getFamily());
		StyleConstants.setFontSize(attrs, customFont.getSize());
		StyledDocument doc = commandLine.getStyledDocument();
		doc.setCharacterAttributes(0, doc.getLength() + 1, attrs, false);
	}

	// Register the font to the system
	private void registerFont(java.awt.Font customFont) {
		GraphicsEnvironment ge = GraphicsEnvironment
				.getLocalGraphicsEnvironment();
		ge.registerFont(customFont);
	}

	// Load the custom font
	private java.awt.Font loadCustomFont() throws FileNotFoundException,
			FontFormatException, IOException {
		java.awt.Font temp;
		InputStream myFont = new BufferedInputStream(new FileInputStream(
				"resources/fonts/ubuntub.ttf"));
		temp = java.awt.Font.createFont(java.awt.Font.TRUETYPE_FONT, myFont);
		temp = temp.deriveFont(java.awt.Font.PLAIN, 16);
		return temp;
	}

	/**
	 * Get the default font in the application
	 * @return the default font
	 */
	private java.awt.Font getDefaultFont() {
		return new java.awt.Font("Calibri", java.awt.Font.PLAIN, 17);
	}

	/**
	 * Create the whole content to be displayed in the interface
	 */
	private void createContent() {
		createSubRoot();
		createCommandLine();

		mainRoot = new StackPane();
		mainRoot.getChildren().addAll(textField, subRoot);
	}
	
	/**
	 * Create the group containing all display nodes in the application except for the command line
	 */
	private void createSubRoot() {
		createTopSection();
		createCenterSection();
		createBottomSection();
		subRoot = BorderPaneBuilder.create().top(top).center(center)
				.bottom(bottom).build();
	}
	
	/**
	 * Set the icon for the application
	 */
	private void setIcon() {	
		stage.getIcons().add(
				new Image(getClass().getResource("iDo_traybar.png")
						.toExternalForm()));
	}
	
	/**
	 * Set the initial position of the stage when the user first opens the application
	 */
	private void setInitialPosition() {
		Rectangle2D primaryScreenBounds = Screen.getPrimary().getVisualBounds();
		stage.setX((primaryScreenBounds.getWidth() - stage.getWidth()) / 2);
		stage.setY((primaryScreenBounds.getHeight() - stage.getHeight()) / 2);
	}
	
	/**
	 * Set the initial state of the application as collapsed state
	 */
	private void setInitialState() {
		removeTopAndCenter();
		expandOrCollapse.setId("larger");
		commandLine.requestFocus();
		commandLine.setCaretPosition(commandLine.getText().length());
	}
	
	// Customize the interface of the application
	public void customizeGUI() {
		clearPreviousCustomization();
		setupNewCustomization();
	}
	
	/**
	 * Setup new customization for the application depending on the chosen mode
	 */
	private void setupNewCustomization() {
		if (model.getThemeMode().equals(Common.DAY_MODE)) {
			setStyleSheetForDayMode();
			setCaretColourListenerForDayMode();
			setTitleForDayMode();
			setColourSchemeForDayMode();
		} else {
			setStyleSheetForNightMode();
			setCaretColourListenerForNightMode();
			setTitleForNightMode();
			setColourSchemeForNightMode();

		}
	}
	
	/**
	 * Set title for night mode
	 */
	private void setTitleForNightMode() {
		title.setImage(new Image(getClass().getResourceAsStream("iDoNight.png")));
	}
	
	/**
	 * Set title for day mode
	 */
	private void setTitleForDayMode() {
		title.setImage(new Image(getClass().getResourceAsStream("iDo.png")));
	}
	
	/**
	 * Set caret colour listener for night mode
	 */
	private void setCaretColourListenerForNightMode() {
		caretColourListenerForCommandLine = new ChangeListener<Boolean>() {
			public void changed(ObservableValue<? extends Boolean> ov,
					Boolean oldValue, Boolean newValue) {
				boolean isFocused = newValue;
				if (!isFocused) {
					commandLine.setCaretColor(ColourPalette.WHITE);
				} else {
					commandLine.setCaretColor(ColourPalette.caretColour);
				}
			}
		};
		stage.focusedProperty().addListener(caretColourListenerForCommandLine);
	}
	
	/**
	 * Set caret colour listener for day mode
	 */
	private void setCaretColourListenerForDayMode() {
		caretColourListenerForCommandLine = new ChangeListener<Boolean>() {
			public void changed(ObservableValue<? extends Boolean> ov,
					Boolean oldValue, Boolean newValue) {
				boolean isFocused = newValue;
				if (!isFocused) {
					commandLine.setCaretColor(ColourPalette.BLACK);
				} else {
					commandLine.setCaretColor(ColourPalette.caretColour);
				}
			}
		};
		stage.focusedProperty().addListener(caretColourListenerForCommandLine);
	}
	
	/** 
	 * Set style sheet for night mode
	 */
	private void setStyleSheetForNightMode() {
		scene.getStylesheets().addAll(getClass().getResource("nightCustomization.css")
						.toExternalForm());
	}
	
	/**
	 * Set style sheet for day mode
	 */
	private void setStyleSheetForDayMode() {
		scene.getStylesheets().addAll(getClass().getResource("dayCustomization.css")
						.toExternalForm());
	}
	
	/**
	 * Change the colour scheme for night mode
	 */
	private void setColourSchemeForNightMode() {
		commandLine.setBackground(ColourPalette.cmdBackgroundColour);
		commandLine.setStyledDocument(new CustomStyledDocument());
		defaultColor = ColourPalette.fxNEAR_WHITE;
		if (model.getColourScheme().equals(Common.DAY_MODE)) {
			model.setColourScheme(Common.NIGHT_MODE);
		}
		setColourScheme(model.getColourScheme());
	}
	
	/**
	 * Change the colour scheme for day mode
	 */
	private void setColourSchemeForDayMode() {
		commandLine.setBackground(ColourPalette.WHITE);
		commandLine.setStyledDocument(new CustomStyledDocument());
		defaultColor = ColourPalette.fxWHITE;
		if (model.getColourScheme().equals(Common.NIGHT_MODE)) {
			model.setColourScheme(Common.DAY_MODE);
		}
		setColourScheme(model.getColourScheme());
	}
	
	/**
	 * Clear previous customization of the application to prepare for new customization
	 */
	private void clearPreviousCustomization() {
		if (caretColourListenerForCommandLine != null) {
			stage.focusedProperty().removeListener(
					caretColourListenerForCommandLine);
		}
		scene.getStylesheets().clear();
	}
	
	// Get the default color in the application
	public Color getDefaultColor() {
		return defaultColor;
	}
	
	/**
	 * Create the BOTTOM section
	 */
	private void createBottomSection() {
		bottom = new VBox();
		bottom.setSpacing(5);
		bottom.setPadding(new Insets(0, 0, 5, 44));

		HBox upperPart = createUpperPartInBottomSection();
		HBox lowerPart = createLowerPartInBottomSection();

		bottom.getChildren().addAll(upperPart, lowerPart);
	}
	
	// Create the lower part in BOTTOM section comprising the list of feedback elements
	private HBox createLowerPartInBottomSection() {
		HBox feedbacks = new HBox();
		feedbacks.setSpacing(10);
		feedbackList.clear();
		for (int i = 0; i < 10; i++) {
			Text feedbackPiece = TextBuilder.create().styleClass("feedback")
					.fill(defaultColor).text("").build();
			feedbackList.add(feedbackPiece);
			feedbacks.getChildren().add(feedbackList.get(i));
		}
		return feedbacks;
	}
	
	// Create the upper part in BOTTOM section
	private HBox createUpperPartInBottomSection() {
		HBox temp = new HBox();
		temp.setSpacing(10);
		TextField invisibleCommandLine = createOverlayTextfield();
		setupExpandOrCollapseButton();
		temp.getChildren().addAll(invisibleCommandLine, expandOrCollapse);

		return temp;
	}

	/**
	 * Create the expand or collapse button
	 */
	private void setupExpandOrCollapseButton() {
		expandOrCollapse = new Button();
		expandOrCollapse.setPrefSize(30, 30);
		expandOrCollapse.setId("smaller");
		hookUpEventForExpandOrCollapse();
	}

	// Create the overlay text field behind the actual text field
	private TextField createOverlayTextfield() {
		TextField invisibleCommandLine = new TextField();
		invisibleCommandLine.setPrefWidth(630);
		invisibleCommandLine.opacityProperty().set(0.0);
		return invisibleCommandLine;
	}

	/**
	 * Create the CENTER section
	 */
	private void createCenterSection() {
		createTabPane();
		center = HBoxBuilder.create().padding(new Insets(0, 44, 0, 44))
				.children(tabPane).build();
	}

	/**
	 * Create the tab pane where content in the tabs will reside in
	 */
	private void createTabPane() {
		createPendingTable();
		createCompleteTable();
		createTrashTable();
		createTabs();
		setTabChangeListener();
	}

	// Create the tabs containing the 3 tables
	private void createTabs() {
		tabPane = new TabPane();
		Tab pending = TabBuilder.create().content(taskPendingList)
				.text("PENDING").closable(false).build();
		Tab complete = TabBuilder.create().content(taskCompleteList)
				.text("COMPLETE").closable(false).build();
		Tab trash = TabBuilder.create().content(taskTrashList).text("TRASH")
				.closable(false).build();
		tabPane.getTabs().addAll(pending, complete, trash);
	}

	// Create the table showing trash tasks
	private void createTrashTable() {
		taskTrashList = new TableView<Task>();
		createTable(taskTrashList, model.getTrashList());
	}

	// Create the table showing completed tasks
	private void createCompleteTable() {
		taskCompleteList = new TableView<Task>();
		createTable(taskCompleteList, model.getCompleteList());
	}

	// Create the table showing pending tasks
	private void createPendingTable() {
		taskPendingList = new TableView<Task>();
		createTable(taskPendingList, model.getPendingList());
	}

	/**
	 * Create the TOP section in the application
	 */
	private void createTopSection() {
		top = new AnchorPane();
		top.setPadding(new Insets(-15, 15, -30, 44));

		title = createTitle();
		createSyncProgressIndicator();
		createInternetAccessIndicator();
		HBox systemButtons = createSystemButtons();

		setupTopLayout(netAccessIndicator, systemButtons);
	}

	// Create the indicator whether there is currently internet connection or
	// not
	private void createInternetAccessIndicator() {
		Image netAcess = new Image(getClass().getResourceAsStream(
				"redCross.png"), 25, 25, true, true);
		netAccessIndicator = new ImageView(netAcess);
		netAccessIndicator.setVisible(false);
	}
	
	// End of segment: D:\CS2103 Proj\src\View.java





	/**
	 * origin: D:\CS2103 Proj\src\View.java
	 */

	/**
	 * Show the signal that there is currently no internet connection The signal
	 * will start to fade out after 2 seconds
	 */
	public void showNoInternetConnection() {
		netAccessIndicator.setVisible(true);
		Platform.runLater(new Runnable() {
			@Override
			public void run() {
				FadeTransition fadeIn = new FadeTransition(
						Duration.millis(100), netAccessIndicator);
				fadeIn.setFromValue(1.0);
				fadeIn.setToValue(1.0);
				FadeTransition fadeOut = new FadeTransition(Duration
						.millis(2000), netAccessIndicator);
				fadeOut.setFromValue(1.0);
				fadeOut.setToValue(0.0);
				SequentialTransition seq = new SequentialTransition(fadeIn,
						new PauseTransition(Duration.millis(4000)), fadeOut);
				seq.play();
			}
		});
	}

	/**
	 * Setup the functionality to drag the window
	 */
	private void setupDraggable() {
		// Get the position of the mouse in the stage
		subRoot.setOnMousePressed(new EventHandler<MouseEvent>() {
			@Override
			public void handle(MouseEvent me) {
				dragAnchorX = me.getScreenX() - stage.getX();
				dragAnchorY = me.getScreenY() - stage.getY();
			}
		});

		// Moving with the stage with the mouse at constant position relative to
		// the stage
		subRoot.setOnMouseDragged(new EventHandler<MouseEvent>() {
			@Override
			public void handle(MouseEvent me) {
				stage.setX(me.getScreenX() - dragAnchorX);
				stage.setY(me.getScreenY() - dragAnchorY);
			}
		});
	}

	/**
	 * Setup the layout in the top section
	 * 
	 * @param netAcessIndicator
	 *            the indicator whether there is internect access or not
	 * @param systemButtons
	 *            the buttons functioning the application
	 */
	private void setupTopLayout(ImageView netAcessIndicator, HBox systemButtons) {
		syncProgress.setMinSize(25, 25);
		syncProgress.setMaxSize(25, 25);

		StackPane indicatorPane = new StackPane();
		indicatorPane.getChildren().addAll(netAcessIndicator, syncProgress);

		top.getChildren().addAll(title, indicatorPane, systemButtons);
		setAnchor(systemButtons, indicatorPane);
	}

	// Set the anchor of the nodes in the top section
	private void setAnchor(HBox buttons, StackPane indicatorPane) {
		AnchorPane.setLeftAnchor(title, 10.0);
		AnchorPane.setTopAnchor(buttons, 25.0);
		AnchorPane.setTopAnchor(title, 30.0);
		AnchorPane.setRightAnchor(buttons, 5.0);
		AnchorPane.setRightAnchor(indicatorPane, 305.0);
		AnchorPane.setBottomAnchor(indicatorPane, -28.0);
	}

	/**
	 * Create the image title to be shown in the application
	 * 
	 * @return the created title image
	 */
	private ImageView createTitle() {
		ImageView title = new ImageView();
		title.setFitWidth(110);
		title.setPreserveRatio(true);
		title.setSmooth(true);
		title.setCache(true);
		return title;
	}

	/**
	 * This function is used to create the system buttons in the application
	 * including the exit and minimize ones.
	 * 
	 * @return the horizontal box containing these 2 buttons
	 */
	private HBox createSystemButtons() {
		Button minimizeButton = createMinimizeButton();
		Button closeButton = createExitButton();

		HBox hb = new HBox();
		hb.getChildren().add(minimizeButton);
		hb.getChildren().add(closeButton);
		hb.setSpacing(10);
		hb.setAlignment(Pos.BOTTOM_CENTER);
		return hb;
	}

	/**
	 * Create the minimize button in the application
	 * 
	 * @return the created button
	 */
	private Button createMinimizeButton() {
		Button targetButton = new Button("");
		targetButton.setPrefSize(20, 20);
		targetButton.setId("minimize");
		targetButton.setOnMouseClicked(new EventHandler<MouseEvent>() {
			public void handle(MouseEvent e) {
				hide();
			}
		});
		return targetButton;
	}

	/**
	 * Create the exit button in the application
	 * 
	 * @return the created button
	 */
	private Button createExitButton() {
		Button targetButton = new Button("");
		targetButton.setPrefSize(20, 20);
		targetButton.setId("close");
		targetButton.setOnMouseClicked(new EventHandler<MouseEvent>() {
			public void handle(MouseEvent e) {
				JIntellitype.getInstance().cleanUp();
				System.exit(0);
			}
		});
		return targetButton;
	}

	/**
	 * This function is used to create the table in the center section.
	 * 
	 * @param taskList
	 *            the table to be created
	 * @param list
	 *            the list of tasks for the table to view
	 */
	public void createTable(TableView<Task> taskList, ObservableList<Task> list) {
		taskList.setItems(list);
		taskList.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);
		setEmptyTableMessage(taskList);

		final ObservableList<TableColumn<Task, ?>> columns = taskList
				.getColumns();
		final TableColumn<Task, String> indexColumn = addIndexColumn(columns);
		final TableColumn<Task, String> occurrenceColumn = addOccurrenceColumn(columns);
		final TableColumn<Task, String> taskInfoColumn = addTaskInfoColumn(columns);
		final TableColumn<Task, String> startDateColumn = addStartDateColumn(columns);
		final TableColumn<Task, String> endDateColumn = addEndDateColumn(columns);
		final TableColumn<Task, Tag> tagColumn = addTagColumn(columns);
		final TableColumn<Task, RowStatus> rowStatusColumn = addRowStatusColumn(columns);
		columns.addListener(new ListChangeListener<TableColumn<Task, ?>>() {
			@Override
			public void onChanged(Change<? extends TableColumn<Task, ?>> change) {
				change.next();
				if (change.wasReplaced()) {
					columns.clear();
					columns.add(indexColumn);
					columns.add(occurrenceColumn);
					columns.add(taskInfoColumn);
					columns.add(startDateColumn);
					columns.add(endDateColumn);
					columns.add(tagColumn);
					columns.add(rowStatusColumn);
				}
			}
		});
	}

	// Set the text display when the table is empty
	private void setEmptyTableMessage(TableView<Task> taskList) {
		final Text emptyTableSign = new Text(
				"There is currently no task in this tab");
		emptyTableSign.getStyleClass().add("text");
		taskList.setPlaceholder(emptyTableSign);
	}

	// Add task info column
	private TableColumn<Task, String> addTaskInfoColumn(
			final ObservableList<TableColumn<Task, ?>> columns) {
		final TableColumn<Task, String> taskInfoColumn = createTaskInfoColumn();
		columns.add(taskInfoColumn);
		return taskInfoColumn;
	}

	/**
	 * Create the column displaying task info
	 * 
	 * @return the created column
	 */
	private TableColumn<Task, String> createTaskInfoColumn() {
		TableColumn<Task, String> taskInfoColumn = TableColumnBuilder
				.<Task, String> create().resizable(false).text("Task")
				.sortable(false).prefWidth(330).build();
	
		setupTaskInfoProperty(taskInfoColumn);
		setupTaskInfoUpdateFormat(taskInfoColumn);
	
		return taskInfoColumn;
	}

	/**
	 * Link up the content of each cell with the task info property in Task
	 * class
	 * 
	 * @param taskInfoColumn
	 *            the linked column
	 */
	private void setupTaskInfoProperty(TableColumn<Task, String> taskInfoColumn) {
		taskInfoColumn
				.setCellValueFactory(new PropertyValueFactory<Task, String>(
						"workInfo"));
	}

	/**
	 * Setup how to display the content of the property
	 * 
	 * @param taskInfoColumn
	 *            the modified column
	 */
	private void setupTaskInfoUpdateFormat(
			final TableColumn<Task, String> taskInfoColumn) {
		taskInfoColumn
				.setCellFactory(new Callback<TableColumn<Task, String>, TableCell<Task, String>>() {
	
					@Override
					public TableCell<Task, String> call(
							TableColumn<Task, String> arg0) {
						TableCell<Task, String> tc = new TableCell<Task, String>() {
							Text text;
	
							@Override
							public void updateItem(String item, boolean empty) {
								if (item != null) {
									text = new Text(item);
									text.getStyleClass().add("text");
									text.wrappingWidthProperty().bind(
											taskInfoColumn.widthProperty());
									setGraphic(text);
								}
							}
						};
						tc.setAlignment(Pos.TOP_LEFT);
						return tc;
					}
				});
	}

	// Add index column
	private TableColumn<Task, String> addIndexColumn(
			final ObservableList<TableColumn<Task, ?>> columns) {
		final TableColumn<Task, String> indexColumn = createIndexColumn();
		columns.add(indexColumn);
		return indexColumn;
	}

	/**
	 * Create the index column
	 * 
	 * @return the created column
	 */
	private TableColumn<Task, String> createIndexColumn() {
		TableColumn<Task, String> indexColumn = TableColumnBuilder
				.<Task, String> create().resizable(false).visible(true)
				.text("").prefWidth(28).sortable(false).resizable(false)
				.build();
		setupEndDateProperty(indexColumn); // no specific property as index
											// column does not depend on Task
		setupIndexUpdateFormat(indexColumn);
		return indexColumn;
	}

	/**
	 * Setup how to display the content in the column
	 * 
	 * @param indexColumn
	 *            the modified column
	 */
	private void setupIndexUpdateFormat(TableColumn<Task, String> indexColumn) {
		indexColumn
				.setCellFactory(new Callback<TableColumn<Task, String>, TableCell<Task, String>>() {
	
					@Override
					public TableCell<Task, String> call(
							TableColumn<Task, String> param) {
						TableCell<Task, String> tc = new TableCell<Task, String>() {
							@Override
							public void updateItem(String item, boolean empty) {
								if (item != null) {
									setText(getTableRow().getIndex() + 1 + ".");
								}
							}
						};
						tc.setAlignment(Pos.TOP_LEFT);
						return tc;
					}
				});
	}

	// Add tag column
	private TableColumn<Task, Tag> addTagColumn(
			final ObservableList<TableColumn<Task, ?>> columns) {
		final TableColumn<Task, Tag> tagColumn = createTagColumn();
		columns.add(tagColumn);
		return tagColumn;
	}

	/**
	 * Create the tag column containing the info of recurring period and
	 * category tag
	 * 
	 * @return the created column
	 */
	private TableColumn<Task, Tag> createTagColumn() {
		TableColumn<Task, Tag> tagColumn = TableColumnBuilder
				.<Task, Tag> create().resizable(false).text("Tag")
				.sortable(false).resizable(false).prefWidth(110).build();
	
		setupTagProperty(tagColumn);
		setupTagUpdateFormat(tagColumn);
	
		return tagColumn;
	}

	/**
	 * Link up the content of each cell with the tag property in Task class
	 * 
	 * @param tagColumn
	 *            the linked column
	 */
	private void setupTagProperty(TableColumn<Task, Tag> tagColumn) {
		tagColumn.setCellValueFactory(new PropertyValueFactory<Task, Tag>("tag"));
	}

	/**
	 * Setup how to display the content of the property
	 * 
	 * @param tagColumn
	 *            the modifed column
	 */
	private void setupTagUpdateFormat(final TableColumn<Task, Tag> tagColumn) {
		tagColumn.setCellFactory(new Callback<TableColumn<Task, Tag>, TableCell<Task, Tag>>() {
					@Override
					public TableCell<Task, Tag> call(
							TableColumn<Task, Tag> param) {
						TableCell<Task, Tag> tc = new TableCell<Task, Tag>() {
							Text text;
	
							public void updateItem(Tag item, boolean empty) {
								if (item != null) {
									boolean isRepetitiveTask = !item
											.getRepetition()
											.equals(Common.NULL);
									boolean hasTag = !item.getTag().equals("-");
									checkRepetitiveTag(item, isRepetitiveTask,
											hasTag);
									text.getStyleClass().add("text");
									text.wrappingWidthProperty().bind(
											tagColumn.widthProperty());
									setGraphic(text);
								}
							}
	
							// Check for repetitive tag
							private void checkRepetitiveTag(Tag item,
									boolean isRepetitiveTask, boolean hasTag) {
								if (!isRepetitiveTask) {
									checkCategoryTagForNormalTask(item, hasTag);
								} else {
									checkCategoryTagForRecurringTask(item,
											hasTag);
								}
							}
	
							// Check for category tag of recurring task
							private void checkCategoryTagForRecurringTask(
									Tag item, boolean hasTag) {
								if (!hasTag) {
									text = new Text(appendSpaceForAlignment("#"+ item.getRepetition()));
								} else {
									text = new Text(appendSpaceForAlignment(item.getTag()) + "\n"
													+ appendSpaceForAlignment("#" + item.getRepetition()));
								}
							}
	
							// Check for category tag of normal task
							private void checkCategoryTagForNormalTask(
									Tag item, boolean hasTag) {
								if (!hasTag) {
									text = new Text(appendSpaceForAlignment("-"));
								} else {
									text = new Text(appendSpaceForAlignment(item.getTag()));
								}
							}
	
							// Append space for alignment according to the
							// content of the info
							private String appendSpaceForAlignment(String info) {
								if (info.equals("-")) {
									return "             " + info;
								}
	
								if (info.length() < 10) {
									return "\t" + info;
								} else if (info.length() < 12) {
									return "    " + info;
								} else {
									return info;
								}
							}
						};
						tc.setAlignment(Pos.TOP_CENTER);
						return tc;
					}
				});
	}

	// Add row status column
	private TableColumn<Task, RowStatus> addRowStatusColumn(
			final ObservableList<TableColumn<Task, ?>> columns) {
		final TableColumn<Task, RowStatus> rowStatusColumn = createRowStatusColumn();
		columns.add(rowStatusColumn);
		return rowStatusColumn;
	}

	/**
	 * Create the row status column
	 * 
	 * @return the created column
	 */
	private TableColumn<Task, RowStatus> createRowStatusColumn() {
		TableColumn<Task, RowStatus> rowStatusColumn = TableColumnBuilder
				.<Task, RowStatus> create().resizable(false).visible(true)
				.text("").prefWidth(1).build();
		setupRowStatusProperty(rowStatusColumn);
		setupRowStatusUpdateFormat(rowStatusColumn);
		return rowStatusColumn;
	}

	/**
	 * Link up the content of each cell with the rowStatus property in Task
	 * class
	 * 
	 * @param rowStatusColumn
	 *            the linked column
	 */
	private void setupRowStatusProperty(
			TableColumn<Task, RowStatus> rowStatusColumn) {
		rowStatusColumn.setCellValueFactory(new PropertyValueFactory<Task, RowStatus>("rowStatus"));
	}

	/**
	 * Setup how to display the content in the column
	 * 
	 * @param rowStatusColumn
	 *            the modified column
	 */
	private void setupRowStatusUpdateFormat(
			TableColumn<Task, RowStatus> rowStatusColumn) {
		rowStatusColumn.setCellFactory(new Callback<TableColumn<Task, RowStatus>, TableCell<Task, RowStatus>>() {
	
					@Override
					public TableCell<Task, RowStatus> call(
							TableColumn<Task, RowStatus> param) {
						TableCell<Task, RowStatus> tc = new TableCell<Task, RowStatus>() {
							@Override
							public void updateItem(RowStatus item, boolean empty) {
								super.updateItem(item, empty);
								if (item != null) {
									clearStyle();
									setStyle(item);
								}
							}
	
							// Clear the style of the row status
							private void clearStyle() {
								getTableRow().getStyleClass().removeAll(
										"table-row-cell", "unimportant",
										"important", "unimportant-odd",
										"unimportant-last", "important-last",
										"unimportant-odd-last");
	
							}
	
							// Set the style for the row status
							private void setStyle(RowStatus rowStatus) {
								boolean isLastOverdue = rowStatus
										.getIsLastOverdue();
								boolean isOdd = getTableRow().getIndex() % 2 != 0;
								boolean isImportant = rowStatus
										.getIsImportant();
								checkIsLastOverdue(isLastOverdue, isOdd,
										isImportant);
							}
	
							// Check for last overdue task
							private void checkIsLastOverdue(
									boolean isLastOverdue, boolean isOdd,
									boolean isImportant) {
								if (isLastOverdue) {
									checkIsImportantForLastOverdueTask(isOdd,
											isImportant);
								} else {
									checkIsImportantForNormalTask(isOdd,
											isImportant);
								}
							}
	
							// Check for important task of non last overdue task
							private void checkIsImportantForNormalTask(
									boolean isOdd, boolean isImportant) {
								if (isImportant) {
									getTableRow().getStyleClass().add("important");
								} else {
									checkIsOddForLastOverdueTask(isOdd);
								}
							}
	
							// Check for odd task of last overdue task
							private void checkIsOddForLastOverdueTask(
									boolean isOdd) {
								if (isOdd) {
									getTableRow().getStyleClass().add("unimportant-odd");
								} else {
									getTableRow().getStyleClass().add("unimportant");
								}
							}
	
							// Check for important task of last overdue task
							private void checkIsImportantForLastOverdueTask(
									boolean isOdd, boolean isImportant) {
								if (isImportant) {
									getTableRow().getStyleClass().add("important-last");
								} else {
									checkIsOddForNormalTask(isOdd);
								}
							}
	
							// Check for odd task of non last overdue task
							private void checkIsOddForNormalTask(boolean isOdd) {
								if (isOdd) {
									getTableRow().getStyleClass().add("unimportant-odd-last");
								} else {
									getTableRow().getStyleClass().add("unimportant-last");
								}
							}
						};
						return tc;
					}
				});
	}

	// Add start date column
	private TableColumn<Task, String> addStartDateColumn(
			final ObservableList<TableColumn<Task, ?>> columns) {
		final TableColumn<Task, String> startDateColumn = createStartDateColumn();
		columns.add(startDateColumn);
		return startDateColumn;
	}

	/**
	 * Create the start date column
	 * 
	 * @return the created column
	 */
	private TableColumn<Task, String> createStartDateColumn() {
		TableColumn<Task, String> startDateColumn = TableColumnBuilder
				.<Task, String> create().resizable(false).text("Start")
				.prefWidth(90).resizable(false).sortable(false).build();
	
		setupStartDateProperty(startDateColumn);
		setupStartDateUpdateFormat(startDateColumn);
	
		return startDateColumn;
	}

	/**
	 * Link up the content of each cell with the startDateString property in
	 * Task class
	 * 
	 * @param startDateColumn
	 *            the linked column
	 */
	private void setupStartDateProperty(
			TableColumn<Task, String> startDateColumn) {
		startDateColumn.setCellValueFactory(new PropertyValueFactory<Task, String>("startDateString"));
	}

	/**
	 * Setup how to display the content of the property
	 * 
	 * @param startDateColumn
	 *            the modified column
	 */
	private void setupStartDateUpdateFormat(
			TableColumn<Task, String> startDateColumn) {
		startDateColumn
				.setCellFactory(new Callback<TableColumn<Task, String>, TableCell<Task, String>>() {
	
					@Override
					public TableCell<Task, String> call(
							TableColumn<Task, String> param) {
						TableCell<Task, String> tc = new TableCell<Task, String>() {
							public void updateItem(String item, boolean empty) {
								if (item != null)
									setText(item);
							}
						};
						tc.setAlignment(Pos.TOP_CENTER);
						return tc;
					}
				});
	}

	// Add end date column
	private TableColumn<Task, String> addEndDateColumn(
			final ObservableList<TableColumn<Task, ?>> columns) {
		final TableColumn<Task, String> endDateColumn = createEndDateColumn();
		columns.add(endDateColumn);
		return endDateColumn;
	}

	/**
	 * Create the end date column
	 * 
	 * @return the created column
	 */
	private TableColumn<Task, String> createEndDateColumn() {
		TableColumn<Task, String> endDateColumn = TableColumnBuilder
				.<Task, String> create().resizable(false).text("End")
				.sortable(false).resizable(false).prefWidth(90).build();
	
		setupEndDateProperty(endDateColumn);
		setupEndDateUpdateFormat(endDateColumn);
	
		return endDateColumn;
	}

	/**
	 * Link up the content of each cell with the endDateString property in Task
	 * class
	 * 
	 * @param endDateColumn
	 */
	private void setupEndDateProperty(TableColumn<Task, String> endDateColumn) {
		endDateColumn.setCellValueFactory(new PropertyValueFactory<Task, String>("endDateString"));
	}

	/**
	 * Setup how to display the content of the property
	 * 
	 * @param endDateColumn
	 *            the modified column
	 */
	private void setupEndDateUpdateFormat(
			TableColumn<Task, String> endDateColumn) {
		endDateColumn
				.setCellFactory(new Callback<TableColumn<Task, String>, TableCell<Task, String>>() {
	
					@Override
					public TableCell<Task, String> call(
							TableColumn<Task, String> param) {
						TableCell<Task, String> tc = new TableCell<Task, String>() {
							@Override
							public void updateItem(String item, boolean empty) {
								if (item != null) {
									setText(item);
								}
							}
						};
						tc.setAlignment(Pos.TOP_CENTER);
						return tc;
					}
				});
	}
	
	// End of segment: D:\CS2103 Proj\src\View.java





	/**
	 * origin: D:\CS2103 Proj\src\View.java
	 */

	/**
	 * Setup the event for the expandOrCollapse button
	 */
	private void hookUpEventForExpandOrCollapse() {
		expandOrCollapse.setOnAction(new EventHandler<ActionEvent>() {
			public void handle(ActionEvent e) {
				if (stage.getHeight() == MAX_HEIGHT) {
					collapseAnimation();
				} else if (stage.getHeight() == MIN_HEIGHT) {
					expandAnimation();
				}
			}
		});
	}

	// Remove the top and center section when the user collapses the window
	private void removeTopAndCenter() {
		subRoot.setTop(null);
		subRoot.setCenter(null);
	}

	/**
	 * Process the collapse animation of the window
	 */
	private void collapseAnimation() {
		removeTopAndCenter();
		expandOrCollapse.setId("larger");

		stage.setMinHeight(MIN_HEIGHT);
		Timer animTimer = new Timer();
		animTimer.schedule(new TimerTask() {
			@Override
			public void run() {
				if (stage.getHeight() > MIN_HEIGHT) {
					decrementHeight();
				} else {
					this.cancel();
				}
			}

			// Decrement the height of the window in each phase of the timer
			private void decrementHeight() {
				double i = stage.getHeight() - 10.0;
				stage.setMaxHeight(i);
				stage.setHeight(i);
			}
		}, 0, 5);
	}

	/**
	 * Process the expand animation of the window
	 */
	private void expandAnimation() {
		Timer animTimer = new Timer();
		subRoot.setTop(top);
		expandOrCollapse.setId("smaller");
		stage.setMaxHeight(MAX_HEIGHT);
		animTimer.schedule(new TimerTask() {
			@Override
			public void run() {
				if (stage.getHeight() > 530) {
					setCenterWithFadeTransition();
				}

				if (stage.getHeight() < MAX_HEIGHT) {
					incrementHeight();
				} else {
					this.cancel();
				}
			}

			// Increment the height of the window in each phase of the timer
			private void incrementHeight() {
				double i = stage.getHeight() + 10.0;
				stage.setMinHeight(i);
				stage.setHeight(i);
			}
		}, 0, 5);
	}

	/**
	 * Set the transition of fade in for the center section when user expands
	 * the application
	 */
	private void setCenterWithFadeTransition() {
		Platform.runLater(new Runnable() {
			public void run() {
				subRoot.setCenter(center);
				FadeTransition fadeIn = new FadeTransition(
						Duration.millis(500), center);
				fadeIn.setFromValue(0.0);
				fadeIn.setToValue(1.0);
				fadeIn.play();
			}
		});
	}

	/**
	 * Setup the functionality of hiding in system tray for application
	 */
	private void setupSystemTray() {
		if (SystemTray.isSupported()) {
			java.awt.Image iconImage = getIconImage();
			popupMenu = createPopupMenu();
			createTrayIcon(iconImage, popupMenu);
			createSystemTray();
		}
	}

	/**
	 * Register the tray icon in system tray
	 */
	private void createSystemTray() {
		SystemTray tray = SystemTray.getSystemTray();
		try {
			tray.add(trayIcon);
		} catch (AWTException e) {
			logger.log(Level.INFO, e.getMessage());
		}
	}

	/**
	 * Create the tray icon in the system tray
	 * 
	 * @param iconImage
	 *            the image icon
	 * @param popupMenu
	 *            the pop up menu showing up when right click on the icon
	 */
	private void createTrayIcon(java.awt.Image iconImage, PopupMenu popupMenu) {
		trayIcon = new TrayIcon(iconImage, "iDo", popupMenu);
		trayIcon.setImageAutoSize(true);
		trayIcon.addActionListener(createShowListener());
	}

	/**
	 * Create the pop up menu in the system tray
	 * 
	 * @return the created pop up menu
	 */
	private PopupMenu createPopupMenu() {
		final PopupMenu popup = new PopupMenu();
		
		// Create Show Item
		MenuItem showItem = new MenuItem("Show the main window");
		showItem.addActionListener(createShowListener());
		popup.add(showItem);

		popup.addSeparator();
		
		// Create Setting Item
		MenuItem settingsItem = new MenuItem("Preferences");

		popup.add(settingsItem);
		
		// Create Close Item
		MenuItem closeItem = new MenuItem("Exit");
		closeItem.addActionListener(createExitListener());
		popup.add(closeItem);

		return popup;
	}

	/**
	 * This function is used to setup the global hotkey for the application User
	 * can use the assigned hot key to open the application any time while it is
	 * hidden in the system tray
	 */
	private void setupGlobalHotkey() {
		loadLibrary();
		checkIntellitype();
		initGlobalHotKey();
	}

	/**
	 * Get the Settings MenuItem in the pop up menu
	 * 
	 * @return the requested menu item
	 */
	public MenuItem getSettingsItemInPopupMenu() {
		return popupMenu.getItem(2);
	}

	/**
	 * Setup the ActionListener when the user chooses "Show" in the pop up menu
	 * 
	 * @return the requested ActionListener object
	 */
	private ActionListener createShowListener() {
		return new ActionListener() {
			@Override
			public void actionPerformed(java.awt.event.ActionEvent e) {
				Platform.runLater(new Runnable() {
					@Override
					public void run() {
						stage.toFront();
						stage.show();
					}
				});
			}
		};
	}

	/**
	 * Setup the ActionListener when the user chooses "Exit" in the pop up menu
	 * 
	 * @return the request ActionListner object
	 */
	private ActionListener createExitListener() {
		return new ActionListener() {
			@Override
			public void actionPerformed(java.awt.event.ActionEvent e) {
				JIntellitype.getInstance().cleanUp();
				System.exit(0);
			}
		};
	}

	/**
	 * Load the icon image for system tray
	 */
	private java.awt.Image getIconImage() {
		try {
			java.awt.Image image = ImageIO.read(getClass().getResource(
					"iDo_traybar.png"));
			java.awt.Image rescaled = image.getScaledInstance(15, 15,
					java.awt.Image.SCALE_SMOOTH);
			return rescaled;
		} catch (IOException e) {
			return null;
		}
	}

	/**
	 * Hide the application. If system tray is not supported, the application
	 * will terminate instead.
	 */
	public void hide() {
		Platform.runLater(new Runnable() {
			@Override
			public void run() {
				if (SystemTray.isSupported()) {
					stage.hide();
				} else {
					JIntellitype.getInstance().cleanUp();
					System.exit(0);
				}
			}
		});
	}

	// Load the native library
	private void loadLibrary() {
		System.loadLibrary("JIntellitype");
	}

	/**
	 * Process of checking existing instance before initialization
	 */
	private void checkIntellitype() {
		// first check to see if an instance of this application is already
		// running, use the name of the window title of this JFrame for checking
		if (JIntellitype.checkInstanceAlreadyRunning("iDo")) {
			System.exit(1);
		}

		// next check to make sure JIntellitype DLL can be found and we are on
		// a Windows operating System
		if (!JIntellitype.isJIntellitypeSupported()) {
			System.exit(1);
		}
	}

	/**
	 * Initialize the Global Hot key feature
	 */
	private void initGlobalHotKey() {
		try {
			// initialize JIntellitype with the frame so all windows commands
			// can
			// be attached to this window
			JIntellitype.getInstance().addHotKeyListener(this);
			JIntellitype.getInstance().registerHotKey(90,
					JIntellitype.MOD_CONTROL + JIntellitype.MOD_SHIFT, 'D');
		} catch (RuntimeException ex) {
			logger.log(
					Level.INFO,
					"Either you are not on Windows, or there is a problem with the JIntellitype library!");
		}
	}

	/**
	 * Setup the processed action when press the global hot key
	 */
	@Override
	public void onHotKey(int keyIdentifier) {
		Platform.runLater(new Runnable() {
			@Override
			public void run() {
				stage.toFront();
				stage.show();
			}
		});
	}

	/**
	 * Setup the listener when user changes tab. It will clear all search
	 * results back to the original list
	 */
	private void setTabChangeListener() {
		tabPane.getSelectionModel().selectedIndexProperty()
				.addListener(new ChangeListener<Number>() {
					public void changed(ObservableValue<? extends Number> ov,
							Number oldValue, Number newValue) {
						clearSearchLists();
					}
					
					// Clear the search results back to original list
					private void clearSearchLists() {
						TwoWayCommand.setIndexType(TwoWayCommand.SHOWN);
						taskPendingList.setItems(model.getPendingList());
						taskCompleteList.setItems(model.getCompleteList());
						taskTrashList.setItems(model.getTrashList());
					}
				});
	}

	// Set the view to a specific tab
	public void setTab(int tabIndex) {
		tabPane.getSelectionModel().select(tabIndex);
	}

	// Get the current tab index that the user is viewing
	public int getTabIndex() {
		return tabPane.getSelectionModel().getSelectedIndex();
	}
	
	// End of segment: D:\CS2103 Proj\src\View.java





	/**
	 * origin: D:\CS2103 Proj\src\View.java
	 */

/**
 * 
 * This class defines the style in the command line How the command line has
 * multi color depends on this class
 * 
 */
@SuppressWarnings("serial")
class CustomStyledDocument extends DefaultStyledDocument {
	@Override
	public void insertString(int offset, String str, AttributeSet a)
			throws BadLocationException {
		super.insertString(offset, str, a);
		setColor();
	}

	@Override
	public void remove(int offs, int len) throws BadLocationException {
		super.remove(offs, len);
		setColor();
	}

	private void setColor() throws BadLocationException {
		String text = getText(0, getLength());
		ArrayList<InfoWithIndex> infoList = Parser.parseForView(text.toLowerCase());
		for (int i = 0; i < infoList.size(); i++) {
			InfoWithIndex info = infoList.get(i);
			switch (info.getInfoType()) {
			case Common.INDEX_REDUNDANT_INFO:
				setCharacterAttributes(info.getStartIndex(), info.getInfo()
						.length(), View.colourSchemeCommandLine[0], false);
				break;
			case Common.INDEX_COMMAND_TYPE:
				setCharacterAttributes(info.getStartIndex(), info.getInfo()
						.length(), View.colourSchemeCommandLine[1], false);
				break;
			case Common.INDEX_WORK_INFO:
				setCharacterAttributes(info.getStartIndex(), info.getInfo()
						.length(), View.colourSchemeCommandLine[2], false);
				break;
			case Common.INDEX_TAG:
				setCharacterAttributes(info.getStartIndex(), info.getInfo()
						.length(), View.colourSchemeCommandLine[3], false);
				break;
			case Common.INDEX_START_DATE:
				setCharacterAttributes(info.getStartIndex(), info.getInfo()
						.length(), View.colourSchemeCommandLine[4], false);
				break;
			case Common.INDEX_END_DATE:
				setCharacterAttributes(info.getStartIndex(), info.getInfo()
						.length(), View.colourSchemeCommandLine[5], false);
				break;
			case Common.INDEX_IS_IMPT:
				setCharacterAttributes(info.getStartIndex(), info.getInfo()
						.length(), View.colourSchemeCommandLine[6], false);
				break;
			case Common.INDEX_REPEATING:
				setCharacterAttributes(info.getStartIndex(), info.getInfo()
						.length(), View.colourSchemeCommandLine[7], false);
				break;
			case Common.INDEX_INDEX_INFO:
				setCharacterAttributes(info.getStartIndex(), info.getInfo()
						.length(), View.colourSchemeCommandLine[8], false);
				break;
			}
		}
	}
};

	// End of segment: D:\CS2103 Proj\src\View.java





