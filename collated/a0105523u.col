//@author: a0105523u



	/**
	 * origin: D:\CS2103 Proj\src\Command.java
	 */

/********************************subclass of TwoWayCommand*************************************************/
/**
 * 
 * Class AddCommand. This command create a new task for the user, the new task will be created in the pending list
 * 
 */
class AddCommand extends TwoWayCommand {
	// Work info
	private String workInfo;
	// Tag
	private String tag;
	// Start date
	private String startDateString;
	// End date
	private String endDateString;
	// Indicator whether this is an important task
	private boolean isImptTask;
	// Type of repetition
	private String repeatingType;
	// The newly created task
	private Task createdTask;
	
	/**
	 * The constructor of this class
	 * 
	 * @param parsedUserCommand
	 *            the array of info from the command parsed by Parser class
	 * @param model
	 *            the model in the application
	 * @param tabIndex
	 *            the current tab index
	 *
	 */
	public AddCommand(String[] parsedUserCommand, Model model, int tabIndex) throws IllegalArgumentException {
		super(model, tabIndex);
		assert parsedUserCommand != null;

		workInfo = parsedUserCommand[0];
		tag = parsedUserCommand[1];
		startDateString = parsedUserCommand[2];
		endDateString = parsedUserCommand[3];
		isImptTask =  parsedUserCommand[4].equals(Common.TRUE);
		repeatingType = parsedUserCommand[5];
	}
	
	/**
	 * Execute the ADD command
	 */
	public String execute() {
		createdTask = new Task();
		updateTask();
		// Add the task to the pending list
		model.addTaskToPending(createdTask);
		Common.sortList(model.getPendingList());
		return Common.MESSAGE_SUCCESSFUL_ADD;
	}
	
	/**
	 * This function is used to update all the information for the created task basing on the command input
	 */
	private void updateTask() {
		createdTask.setWorkInfo(workInfo);
		
		boolean isRepetitive = !repeatingType.equals(Common.NULL);
		boolean hasStartDate = !startDateString.equals(Common.NULL);
		boolean hasEndDate = !endDateString.equals(Common.NULL);
		
		setDates(hasStartDate, hasEndDate); 
		
		if(isRepetitive) {
			splitRepeatingInfo();
		}
		checkInvalidDates(isRepetitive, hasStartDate, hasEndDate, 
				createdTask.getStartDate(), createdTask.getEndDate(), repeatingType);
		
		setTag();
		if (isRepetitive) {
			createdTask.updateDateForRepetitiveTask();
		}
		
		createdTask.setIsImportant(isImptTask);
	}
	
	/**
	 * Set dates for the added task
	 * @param hasStartDate indicator if the input command has start date
	 * @param hasEndDate indicator if the input command has end date
	 */
	private void setDates(boolean hasStartDate, boolean hasEndDate) {
		if (hasStartDate && hasEndDate) {
			setDateForTaskWithBothDates();
		} else if(hasStartDate){
			setDateForTaskWithStartDate();
		} else if(hasEndDate){
			setDateForTaskWithEndDate();
		}
	}
	
	/**
	 * Set dates when the input command has only end date
	 */
	private void setDateForTaskWithEndDate() {
		CustomDate endDate = new CustomDate(endDateString);
		CustomDate cur = new CustomDate();
		cur.setHour(0);
		cur.setMinute(0);
		if(endDate.beforeCurrentTime()){
			cur.setYear(endDate.getYear());
			cur.setMonth(endDate.getMonth());
			cur.setDate(endDate.getDate());
			createdTask.setStartDate(cur);
			createdTask.setEndDate(endDate);
			updateTimeForEndDate(createdTask.getStartDate(), endDate);
		} else {
			createdTask.setStartDate(cur);
			createdTask.setEndDate(endDate);
			updateTimeForEndDate(createdTask.getStartDate(), endDate);
		}
	}
	
	/**
	 * Set dates when the input command has only start date
	 */
	private void setDateForTaskWithStartDate() {
		CustomDate startDate = new CustomDate(startDateString);
		createdTask.setStartDate(startDate);
		CustomDate cd = new CustomDate();
		cd.setYear(createdTask.getStartDate().getYear());
		cd.setMonth(createdTask.getStartDate().getMonth());
		cd.setDate(createdTask.getStartDate().getDate());
		cd.setHour(23);
		cd.setMinute(59);
		createdTask.setEndDate(cd);
	}

	/**
	 * Set dates when the input command has both start and end dates
	 */
	private void setDateForTaskWithBothDates() {
		CustomDate startDate = new CustomDate(startDateString);
		createdTask.setStartDate(startDate);
		CustomDate endDate = new CustomDate(endDateString);
		updateTimeForEndDate(createdTask.getStartDate(), endDate);
		createdTask.setEndDate(endDate);
	}
	
	// End of segment: D:\CS2103 Proj\src\Command.java





	/**
	 * origin: D:\CS2103 Proj\src\Command.java
	 */

/**
 * 
 * Class SyncCommand. This class executes command to sync with the Google Calendar in a concurrent thread.
 * 
 */
class SyncCommand extends Command implements Runnable {
	// Username of Google Account
	private String username = null;
	// Password of Google Account
	private String password = null;
	// Feedback from the sync
	private String feedback = null;
	// Indicator whether it is under syncing process
	private boolean isRunning = false;
	// The sync class
	private Synchronization sync;
	// Main interface
	private View view;
	// The storage file of tasks
	private Storage taskFile;
	// The thread that will run the syncing process
	private Thread syncingThread;
	
	/**
	 * Constructor of this class
	 * @param model model of tasks in the application
	 * @param sync the sync object
	 * @param view the main interface
	 * @param taskFile the task file to store
	 */
	public SyncCommand(Model model, Synchronization sync, View view, Storage taskFile) {
		super(model);
		this.sync = sync;
		this.view = view;
		this.taskFile = taskFile;
		
		loadAccount(model);
		processSyncing(sync, view);
	}

	/**
	 * This function is the main function for syncing process
	 * 
	 * @param sync
	 *            sync object
	 * @param view
	 *            the main interface
	 */
	private void processSyncing(Synchronization sync, View view) {
		if(checkInternetAccess()){
			try {
				checkAccount(sync);
				sync.isValid = true;
				startSyncing(); 
			} catch (AuthenticationException e) {
				feedback = Common.MESSAGE_SYNC_INVALID_USERNAME_PASSWORD;
				sync.isValid = false;
			}
		} else {
			view.showNoInternetConnection();
		}
	}
	
	// Begin the syncing phase
	private void startSyncing() {
		syncingThread = new Thread(this, "Sync Thread");
		syncingThread.start();
	}
	
	// Check if this google account is valid or not
	private void checkAccount(Synchronization sync)
			throws AuthenticationException {
		if(!sync.isValid || !username.equals(sync.username) || !password.equals(sync.password)){
			sync.setUsernameAndPassword(username, password);
			sync.initService();
		}
	}
	
	// Load the account user input in the application
	private void loadAccount(Model model) {
		username = model.getUsername();
		password = model.getPassword();
	}
	
	/**
	 * This function is used to check whether there is currently internet access in the system or not
	 * @return true if there is indeed internet access, or vice versa
	 */
	private boolean checkInternetAccess(){
            try {
                //URL of Google
                URL url = new URL("http://www.google.com");
                //Open a connection to Google
                HttpURLConnection urlConnect = (HttpURLConnection)url.openConnection();
                // Test connection
                urlConnect.getContent();
            } catch (UnknownHostException e) {
                return false;
            } catch (IOException e) {
                return false;
            }
            return true;
    }
	
	/**
	 * The syncing thread running content
	 */
	@Override
	public void run() {
			isRunning = true;
			view.setSyncProgressVisible(true);
			execute();
			view.setSyncProgressVisible(false);
			isRunning = false;
			model.clearSyncInfo();
			storeSyncData();
	}
	
	/**
	 * Store data after finishing synchronization
	 */
	private void storeSyncData() {
		try {
			taskFile.storeToFile();
		} catch (IOException io) {
			System.out.println(io.getMessage());
		}
	}
	
	/**
	 * Execute SYNC command
	 */
	@Override
	public String execute() {
		try{
			sync.execute();
			Common.sortList(model.getPendingList());
		} catch(Exception e){
			if(e instanceof AuthenticationException){
				showSettingsPage();
			}
		}
		return null;
	}
	
	// Show settings window to require reinput google account from the user as it is invalid
	private void showSettingsPage() {
		Platform.runLater(new Runnable() {
			@Override
			public void run() {
				view.showSettingsPage(Common.MESSAGE_SYNC_INVALID_USERNAME_PASSWORD);
			}
		});
	}
	
	// Check whether it is currently under syncing process or not
	public boolean isRunning() {
		return isRunning;
	}
	
	public String getFeedback() {
		return feedback;
	}
}

	// End of segment: D:\CS2103 Proj\src\Command.java





	/**
	 * origin: D:\CS2103 Proj\src\Common.java
	 */

	/****************** string operation *********************************/
	/**
	 * This function removes all unneeded spaces between words in a string,
	 * which means there will be only 1 space between words
	 * 
	 * @param content
	 *            content of the String
	 * @return the after-processed string
	 */
	static String removeUnneededSpaces(String content) {
		String[] words = Common.splitBySpace(content);
		String result = "";
		for (int i = 0; i < words.length; i++){
			result += words[i] + " ";
		}

		return result.trim();
	}
	
	static String getLastWord(String commandString) {
		String[] stringArray = commandString.trim().split("\\s+");
		return stringArray[stringArray.length - 1];
	}

	static String removeLastWord(String commandString) {
		String lastWord = getLastWord(commandString);
		return commandString.substring(0,
				commandString.length() - lastWord.length()).trim();
	}

	static String getFirstWord(String commandString) {
		String[] stringArray = splitBySpace(commandString);
		return stringArray[0];
	}

	static String removeFirstWord(String commandString) {
		return commandString.replaceFirst(getFirstWord(commandString), "")
				.trim();
	}

	static String[] splitBySpace(String content) {
		return content.trim().split("\\s+");
	}
}

	// End of segment: D:\CS2103 Proj\src\Common.java





	/**
	 * origin: D:\CS2103 Proj\src\Control.java
	 */

	/******************************************************* EXECUTION SECTION *************************************************************/
	/**
	 * This function is the main function for executing all command inputs from
	 * users
	 * 
	 * @param userCommand
	 *            the command input from the user
	 * @return the corresponding feedback according to the command
	 */
	public String executeCommand(String userCommand) {
		boolean isEmptyCommand = Parser.checkEmptyCommand(userCommand);
		if (isEmptyCommand) {
			return Common.MESSAGE_EMPTY_COMMAND;
		}
		
		try {
			Common.COMMAND_TYPES commandType = Parser.determineCommandType(userCommand);
			int tabIndex = getTabIndex();
			assert tabIndex >= 0 && tabIndex <= 2;
			String[] parsedUserCommand = Parser.parseCommand(userCommand, commandType, model, tabIndex);
			return executeCommandCorrespondingType(parsedUserCommand, commandType);
		} catch (Exception e) {
			return e.getMessage(); // the corresponding error message
		}
	}
	
	// End of segment: D:\CS2103 Proj\src\Control.java





	/**
	 * origin: D:\CS2103 Proj\src\Control.java
	 */

	/**
	 * This function is used to execute according to each specific command
	 * 
	 * @param parsedUserCommand
	 *            the parsed command array
	 * @param commandType
	 *            type of command
	 * @return the corresponding feedback
	 */
	private String executeCommandCorrespondingType(String[] parsedUserCommand,
			Common.COMMAND_TYPES commandType) throws IllegalArgumentException,
			IOException {
		switch (commandType) {
		case ADD:
			return executeAddCommand(parsedUserCommand);
		case EDIT:
			return executeEditCommand(parsedUserCommand);
		case REMOVE:
			return executeRemoveCommand(parsedUserCommand);
		case RECOVER:
			return executeRecoverCommand(parsedUserCommand);
		case UNDO:
			return executeUndoCommand();
		case REDO:
			return executeRedoCommand();
		case SEARCH:
			return executeSearchCommand(parsedUserCommand, isRealTimeSearch);
		case TODAY:
			return executeTodayCommand(isRealTimeSearch);
		case SHOW_ALL:
			return executeShowCommand();
		case CLEAR_ALL:
			return executeClearCommand();
		case COMPLETE:
			return executeCompleteCommand(parsedUserCommand);
		case INCOMPLETE:
			return executeIncompleteCommand(parsedUserCommand);
		case MARK:
			return executeMarkCommand(parsedUserCommand);
		case UNMARK:
			return executeUnmarkCommand(parsedUserCommand);
		case SETTINGS:
			return executeSettingsCommand(CALL_NORMAL_SETTINGS);
		case HELP:
			return executeHelpCommand();
		case SYNC:
			return executeSyncCommand();
		case EXIT:
			return executeExitCommand();
		case INVALID:
			return Common.MESSAGE_INVALID_COMMAND_TYPE;
		default:
			throw new Error("Unrecognised command type.");
		}
	}
	
	// End of segment: D:\CS2103 Proj\src\Control.java





	/**
	 * origin: D:\CS2103 Proj\src\Control.java
	 */

	/**
	 * ADD command execution
	 */
	private String executeAddCommand(String[] parsedUserCommand)
			throws IOException {
		int tabIndex = getTabIndex();
		assert tabIndex >= 0 && tabIndex <= 2;
		Command addCommand = new AddCommand(parsedUserCommand, model, tabIndex);
		String feedback = addCommand.execute();
		
		if (feedback.equals(Common.MESSAGE_SUCCESSFUL_ADD)) {
			commandHistory.updateCommand((TwoWayCommand) addCommand);
			storeTask();
			if(view != null) {
				view.setTab(Common.PENDING_TAB);
				executeShowCommand();
			}
		}
		return feedback;
	}
	
	// End of segment: D:\CS2103 Proj\src\Control.java





	/**
	 * origin: D:\CS2103 Proj\src\Control.java
	 */

	/**
	 * SYNC command execution
	 */
	private String executeSyncCommand() throws IOException {
		// Check whether there is already a sync thread
		if (!isUnderSyncingProcess()){
			syncThread = new SyncCommand(model, sync, view,
					taskFile);
			if(syncThread.getFeedback() != null && syncThread.getFeedback().equals(Common.MESSAGE_SYNC_INVALID_USERNAME_PASSWORD)){
				executeSettingsCommand(CALL_SETTINGS_FROM_SYNC);
			}
		}
		
		clearCommandLine();
		return Common.MESSAGE_REQUEST_COMMAND;
	}
	
	// End of segment: D:\CS2103 Proj\src\Control.java





	/**
	 * origin: D:\CS2103 Proj\src\Model.java
	 */

	/*
	 * Default constructor
	 */
	public Model() {
		pending = FXCollections.observableArrayList();
		complete = FXCollections.observableArrayList();
		trash = FXCollections.observableArrayList();
		searchPending = FXCollections.observableArrayList();
		searchComplete = FXCollections.observableArrayList();
		searchTrash = FXCollections.observableArrayList();
		removedIdDuringSync = FXCollections.observableArrayList();
		displayRemaining = true;
		themeMode = Common.DAY_MODE;
		colourScheme = Common.DAY_MODE;
		syncPeriod = 1;
	}
	
	/**************************************** TASK Section **********************************/
	
	/************************** GET a task from given index ************************************/
	public Task getTaskFromPending(int index) {
		try{
			Task temp = pending.get(index);
			return temp;
		} catch (IndexOutOfBoundsException e){
			logger.log(Level.WARNING, MESSAGE_OUT_OF_BOUNDS_INDEX);
			return null;
		}
	}

	public Task getTaskFromComplete(int index) {
		try{
			Task temp = complete.get(index);
			return temp;
		} catch (IndexOutOfBoundsException e){
			logger.log(Level.WARNING, MESSAGE_OUT_OF_BOUNDS_INDEX);
			return null;
		}
	}

	public Task getTaskFromTrash(int index) {
		try{
			Task temp = trash.get(index);
			return temp;
		} catch (IndexOutOfBoundsException e){
			logger.log(Level.WARNING, MESSAGE_OUT_OF_BOUNDS_INDEX);
			return null;
		}
	}

	/****************************** GET the required list of tasks *****************************/
	public ObservableList<Task> getPendingList() {
		return pending;
	}

	public ObservableList<Task> getCompleteList() {
		return complete;
	}

	public ObservableList<Task> getTrashList() {
		return trash;
	}

	public ObservableList<Task> getSearchPendingList() {
		return searchPending;
	}

	public ObservableList<Task> getSearchCompleteList() {
		return searchComplete;
	}

	public ObservableList<Task> getSearchTrashList() {
		return searchTrash;
	}
	
	// End of segment: D:\CS2103 Proj\src\Model.java





	/**
	 * origin: D:\CS2103 Proj\src\Parser.java
	 */

	/**
	 * This function is used to determine the command type of the command input
	 * from the user
	 * 
	 * @param userCommand
	 *            - the command input read from the user
	 * @return the corresponding command type
	 */
	public static Common.COMMAND_TYPES determineCommandType(String userCommand) {
		String commandTypeString = Common.getFirstWord(userCommand);

		if (commandTypeString == null)
			throw new IllegalArgumentException("Command type string cannot be null!");

		if (isAddCommand(commandTypeString)) {
			return Common.COMMAND_TYPES.ADD;
		} else if (isEditCommand(commandTypeString)) {
			return Common.COMMAND_TYPES.EDIT;
		} else if (isRemoveCommand(commandTypeString)) {
			return Common.COMMAND_TYPES.REMOVE;
		} else if(isRecoverCommand(commandTypeString)){ 
			return Common.COMMAND_TYPES.RECOVER;
		}	else if (isUndoCommand(commandTypeString)) {
			return Common.COMMAND_TYPES.UNDO;
		} else if (isRedoCommand(commandTypeString)) {
			return Common.COMMAND_TYPES.REDO;
		} else if (isSearchCommand(commandTypeString)) {
			return Common.COMMAND_TYPES.SEARCH;
		} else if (isTodayCommand(commandTypeString)) {
			return Common.COMMAND_TYPES.TODAY;
		} else if (isShowAllCommand(commandTypeString)) {
			return Common.COMMAND_TYPES.SHOW_ALL;
		} else if (isClearAllCommand(commandTypeString)) {
			return Common.COMMAND_TYPES.CLEAR_ALL;
		} else if (isCompleteCommand(commandTypeString)) {
			return Common.COMMAND_TYPES.COMPLETE;
		} else if (isIncompleteCommand(commandTypeString)) {
			return Common.COMMAND_TYPES.INCOMPLETE;
		} else if (isMarkCommand(commandTypeString)) {
			return Common.COMMAND_TYPES.MARK;
		} else if (isUnmarkCommand(commandTypeString)) {
			return Common.COMMAND_TYPES.UNMARK;
		} else if (isSettingsCommand(commandTypeString)) {
			return Common.COMMAND_TYPES.SETTINGS;
		} else if (isHelpCommand(commandTypeString)) {
			return Common.COMMAND_TYPES.HELP;
		} else if (isSyncCommand(commandTypeString)) {
			return Common.COMMAND_TYPES.SYNC;
		} else if (isExitCommand(commandTypeString)) {
			return Common.COMMAND_TYPES.EXIT;
		} else {
			return Common.COMMAND_TYPES.INVALID;
		}
	}

	/**
	 * This method is used to check whether a command is empty or not
	 */
	public static boolean checkEmptyCommand(String userCommand) {
		return userCommand.trim().equals("");
	}
	
	// End of segment: D:\CS2103 Proj\src\Parser.java





	/**
	 * origin: D:\CS2103 Proj\src\Parser.java
	 */

	/*******************************************************************************************************************/
	/**
	 * This method is used to parse from content of an ADD or SEARCH command to
	 * necessary infos
	 * 
	 * @param content
	 *            command string after removing the command type
	 * @return an array of strings where the first field contains workInfo, Common.NULL
	 *         if it is empty; the second field contains tag, Common.NULL if it is
	 *         empty; the third field contains startDateString, Common.NULL if it is
	 *         empty; the fourth field contains endDateString, Common.NULL if it is
	 *         empty; the fifth field contains isImpt (Common.TRUE or Common.FALSE).
	 */
	private static String[] parseCommandWithInfo(String content,
			Common.COMMAND_TYPES commandType) {
		String commandString = content.trim();
		String workInfo = Common.NULL;
		String startDateString = Common.NULL;
		String endDateString = Common.NULL;
		String tag = Common.NULL;
		String isImpt = Common.FALSE;
		String repeatingType = Common.NULL;
		
		// Process recurring info
		String[] result = getRepeatingType(commandString);
		commandString = result[0];
		repeatingType = result[1];
		
		// Process tag info
		if (hasMultipleTags(commandString)) {// multiple hash tags
			throw new IllegalArgumentException("Invalid Command: multiple hash tags(#).");
		} else {
			tag = getTagName(commandString);
			commandString = parseTag(commandString, tag);
		}
		
		// Process importance info
		if (hasMultipleImptMarks(commandString)) {//multiple important marks
			throw new IllegalArgumentException("Invalid Command: multiple important marks(*).");
		} else {
			isImpt = isImptTask(commandString);
			commandString = parseImportance(commandString, isImpt);
		}
		
		// Process start date
		result = checkDate(commandString, Common.startDateKeys, START_KEY);
		commandString = result[0];
		startDateString = result[1];
		
		// Process end date
		result = checkDate(commandString, Common.endDateKeys, END_KEY);
		commandString = result[0];
		endDateString = result[1];
		
		// Process work info
		workInfo = parseWorkInfo(commandType, commandString);

		String[] parsedCommand = assignParsedInfos(workInfo, startDateString,
				endDateString, tag, isImpt, repeatingType);

		return parsedCommand;
	}
	
	/**
	 * This function is used to assign the parsed info to the corresponding
	 * array elements to return to its caller
	 * 
	 * @param workInfo
	 *            the info of the task
	 * @param startDateString
	 *            the String format of start date
	 * @param endDateString
	 *            the String format of end date
	 * @param tag
	 *            the tag
	 * @param isImpt
	 *            the indicator whether this task is an important task or not
	 * @param repeatingType
	 *            the type of repetition including also the number of
	 *            occurrences
	 * @return the required array
	 */
	private static String[] assignParsedInfos(String workInfo,
			String startDateString, String endDateString, String tag,
			String isImpt, String repeatingType) {
		String[] parsedCommand = new String[] { Common.NULL, Common.NULL, Common.NULL, Common.NULL, Common.FALSE,
				Common.NULL };
		
		parsedCommand[Common.INDEX_WORK_INFO] = workInfo;
		parsedCommand[Common.INDEX_START_DATE] = startDateString;
		parsedCommand[Common.INDEX_END_DATE] = endDateString;
		parsedCommand[Common.INDEX_TAG] = tag;
		parsedCommand[Common.INDEX_IS_IMPT] = isImpt;
		parsedCommand[Common.INDEX_REPEATING] = repeatingType;
		
		return parsedCommand;
	}
	
	/**
	 * This function is used to parse the work info
	 * 
	 * @param commandType
	 *            the type of the command
	 * @param commandString
	 *            the string content of the comand
	 * @return the corresponding work info
	 */
	private static String parseWorkInfo(Common.COMMAND_TYPES commandType,
			String commandString) {
		String workInfo;
		if (commandString.trim().equals("")) {
			workInfo = checkForAddCommand(commandType);
		} else{
			workInfo = commandString.trim();
		}
		return workInfo;
	}
	
	/**
	 * This function is used to check if this is an ADD command or not when the task info is empty
	 * @param commandType the type of the command
	 * @return NULL if this is not an ADD command. Throw error vice versa
	 */
	private static String checkForAddCommand(Common.COMMAND_TYPES commandType) {
		if (isAddCommandType(commandType)){
			throw new IllegalArgumentException("Invalid command: work information cannot be empty.");
		}else{
			return Common.NULL;
		}
	}	

	/**
	 * This function is used to parse the important indicator for the task
	 * 
	 * @param commandString
	 *            the string content of the command
	 * @param isImpt
	 *            the indicator whether it is important or not
	 * @return the command string after removing the important indicator
	 */
	private static String parseImportance(String commandString, String isImpt) {
		commandString = (isImpt.equals(Common.TRUE)) ? removeImptMark(commandString)
				: commandString;
		return commandString;
	}

	/**
	 * This function is used to parse the tag for the task
	 * 
	 * @param commandString
	 *            the strig content of the command
	 * @param tag
	 *            the tag in the command
	 * @return the command string after removing the tag
	 */
	private static String parseTag(String commandString, String tag) {
		commandString = (!tag.equals(Common.NULL)) ? removeTag(commandString)
				: commandString;
		return commandString;
	}
	
	// End of segment: D:\CS2103 Proj\src\Parser.java





	/**
	 * origin: D:\CS2103 Proj\src\Parser.java
	 */

	/**
	 * This method is used to check a command string for valid date and remove
	 * the valid date from this command string. If the command string contains
	 * more than 2 valid dates, it will throw an exception message.
	 * 
	 * @param commandString
	 *            command string at the moment
	 * @param keys
	 *            list of key words corresponding to the key type
	 * @param keyType
	 *            key type of the date (START or END)
	 * @return array of strings. First field is the commandString after remove
	 *         the valid date. Second field is the string of the date.
	 */
	private static String[] checkDate(String commandString, String[] keys,
			String keyType) {
		String proccessedString = commandString + "";
		boolean hasDate = false;
		String dateString = Common.NULL;
		for (int i = 0; i < keys.length; i++) {
			// find first occurrence of a <key>
			int keyIndex = proccessedString.toLowerCase().indexOf(keys[i]);
			int keyLength = keys[i].length();
			boolean isValidIndex = keyIndex == 0 || (keyIndex > 0 && proccessedString.charAt(keyIndex-1) == ' ');
			while (isValidIndex) {
				// get string before the date key
				String stringBeforeKey = getStringBeforeIndex(proccessedString, keyIndex);
				// get string after the date key
				String stringAfterKey = getStringAfterKey(keys, proccessedString, i, keyIndex, keyLength);

				int dateLastIndex = isValidDate(stringAfterKey);
				if (dateLastIndex == INVALID) {
					keyIndex = proccessedString.indexOf(keys[i], keyIndex + keyLength);
				} else {
					checkMultipleDates(hasDate);
					dateString = getStringBeforeIndex(stringAfterKey, dateLastIndex);
					hasDate = true;
					proccessedString = stringBeforeKey.trim() + " " + stringAfterKey.substring(dateLastIndex).trim();
					keyIndex = proccessedString.indexOf(keys[i]);
				}
				isValidIndex = keyIndex == 0 || (keyIndex > 0 && proccessedString.charAt(keyIndex-1) == ' ');
			}
		}

		if (hasDate) {
			return new String[] { proccessedString, dateString };
		} else{
			return new String[] { commandString, dateString };
		}
	}
	
	// Check if this command has multiple dates in the same type
	private static void checkMultipleDates(boolean hasDate) {
		if (hasDate) {
			throw new IllegalArgumentException("Invalid Command: Multiple Dates");
		}
	}
	
	// Get the String after a key word
	private static String getStringAfterKey(String[] keys, String temp, int i,
			int keyIndex, int keyLength) {
		String stringAfterKey;
		if (isSpecialEndKeyword(keys, i)) {
			stringAfterKey = keys[i] + " " + temp.substring(keyIndex + keyLength).trim();
		} else {
			stringAfterKey = temp.substring(keyIndex + keyLength).trim();
		}
		return stringAfterKey;
	}
	
	// Check if this is a special key word in the end date kys
	private static boolean isSpecialEndKeyword(String[] keys, int i) {
		return keys[i].equals("today") || keys[i].equals("tonight") || keys[i].equals("tomorrow") || keys[i].equals("next");
	}
	
	// Get the string before a certain index
	private static String getStringBeforeIndex(String temp, int keyIndex) {
		return temp.substring(0, keyIndex).trim();
	}

	// End of segment: D:\CS2103 Proj\src\Parser.java





	/**
	 * origin: D:\CS2103 Proj\src\Parser.java
	 */

	/**
	 * Checks whether a string is a valid date or not.
	 * 
	 * @param dateString
	 *            - the string which is being checked.
	 * @return number of words in the date string if the string contains a date;
	 *         otherwise, returns INVALID(-1).
	 */
	private static int isValidDate(String dateString) {
		CustomDate dateTester = new CustomDate();
		String[] dateStringArray = Common.splitBySpace(dateString);
		int length = getMaximumLengthForProcessing(dateStringArray);
		dateString = cropDateString(dateStringArray, length);
		while (!dateString.isEmpty()) {
			int result = dateTester.convert(dateString);
			if (result == VALID) {
				return dateString.length();
			} else if (result == CustomDate.OUT_OF_BOUNDS) {
				throw new IllegalArgumentException("The time is out of bounds. Please recheck!");
			}
			dateString = Common.removeLastWord(dateString);
		}
		return INVALID;
	}
	
	// Crop the possible date string to the maximum length for date string
	private static String cropDateString(String[] dateStringArray, int length) {
		String dateString;
		dateString = "";
		// construct the date tester string.
		for (int i = 0; i < length; i++) {
			dateString = (dateString + " " + dateStringArray[i]).trim();
		}
		return dateString;
	}
	
	// Determine the maximum length for the investigated date string
	private static int getMaximumLengthForProcessing(String[] dateStringArray) {
		int length;
		if (dateStringArray.length >= MAX_DATE_LENGTH) {
			length = MAX_DATE_LENGTH;
		} else {
			length = dateStringArray.length;
		}
		return length;
	}

	/**
	 * Checks whether the specified command string has more than one hash tags.
	 * 
	 * @param commandString
	 *            - the string which is being checked.
	 * @return true if it contains more than one hash tag; false otherwise.
	 */
	private static boolean hasMultipleTags(String commandString) {
		String[] words = Common.splitBySpace(commandString);
		boolean hasTag = false;

		for (int i = 0; i < words.length; i++) {
			if (words[i].startsWith(Common.HASH_TAG)) {
				if (hasTag) {
					return true;
				}
				hasTag = true;
			}
		}
		return false;
	}

	/**
	 * Removes the first hash tag from the specified string.
	 * 
	 * @param commandString
	 *            - the string from which the hash tag is being removed.
	 * @return the string with hash tag being removed if it contains a hash tag;
	 *         otherwise, returns the same string.
	 */
	private static String removeTag(String commandString) {
		String[] words = Common.splitBySpace(commandString);
		String result = "";
		int index = indexOfTag(commandString);
		if (index >= 0) {
			for (int i = 0; i < words.length; i++) {
				if (i != index) {
					result = result + " " + words[i];
				}
			}
			return result.trim();
		}
		return commandString;
	}

	/**
	 * Returns content of the hash tag in the specified command string.
	 * 
	 * @param commandString
	 *            - the string which may contains a hash tag.
	 * @return the content of the hash tag with '#' being removed if the string
	 *         contains a hash tag; the string Common.NULL otherwise.
	 */
	private static String getTagName(String commandString) {
		String[] words = Common.splitBySpace(commandString);
		for (int i = 0; i < words.length; i++) {
			if (words[i].startsWith(Common.HASH_TAG)) {
				return words[i];
			}
		}
		return Common.NULL;
	}

	/**
	 * Returns the index of the first hash tag in the specified command string.
	 * 
	 * @param commandString
	 *            - the string which is being checked.
	 * @return the starting index if the command string contains a hag tag; -1
	 *         otherwise.
	 */
	private static int indexOfTag(String commandString) {
		String[] words = Common.splitBySpace(commandString);
		for (int i = 0; i < words.length; i++) {
			if (words[i].startsWith(Common.HASH_TAG)) {
				return i;
			}
		}
		return -1;
	}

	/**
	 * Checks whether the specified command string contains more than one
	 * important marks.
	 * 
	 * @param commandString
	 *            - the string which is being checked.
	 * @return true if it contains more than one important marks; false,
	 *         otherwise.
	 */
	private static boolean hasMultipleImptMarks(String commandString) {
		String[] words = Common.splitBySpace(commandString);
		boolean isImpt = false;

		for (int i = 0; i < words.length; i++) {
			if (words[i].equals(Common.IMPT_MARK)) {
				if (isImpt) {
					return true;
				}
				isImpt = true;
			}
		}

		return false;
	}

	/**
	 * Checks whether the specified command string is important.
	 * 
	 * @param commandString
	 *            - the string which is being checked.
	 * @return the string Common.TRUE if it is a important task; otherwise, returns the
	 *         string Common.FALSE.
	 */
	private static String isImptTask(String commandString) {
		String[] words = Common.splitBySpace(commandString);

		for (int i = 0; i < words.length; i++) {
			if (words[i].equals(Common.IMPT_MARK)) {
				return Common.TRUE;
			}
		}

		return Common.FALSE;
	}

	/**
	 * Removes the important mark from the specified command string.
	 * 
	 * @param commandString
	 *            - the string from which the important mark is being removed.
	 * @return the string after removing the first important mark if it contains
	 *         important mark; otherwise the same string is returned.
	 */
	private static String removeImptMark(String commandString) {
		String[] words = Common.splitBySpace(commandString);
		String result = "";
		for (int i = 0; i < words.length; i++) {
			if (!words[i].equals(Common.IMPT_MARK)) {
				result = result + " " + words[i];
			}
		}
		return result.trim();
	}

	
	/******************************** Determine COMMAND_TYPES Section ***************************************************************/

	private static boolean isAddCommand(String commandTypeString) {
		return commandTypeString.equalsIgnoreCase("add")
				||commandTypeString.equalsIgnoreCase("insert");
	}

	private static boolean isEditCommand(String commandTypeString) {
		boolean isEdit = commandTypeString.equalsIgnoreCase("edit")
				|| commandTypeString.equalsIgnoreCase("set")
				|| commandTypeString.equalsIgnoreCase("modify")
				|| commandTypeString.equalsIgnoreCase("mod");
		return isEdit;
	}

	private static boolean isRemoveCommand(String commandTypeString) {
		boolean isRemove = commandTypeString.equalsIgnoreCase("remove")
				|| commandTypeString.equalsIgnoreCase("rm")
				|| commandTypeString.equalsIgnoreCase("delete")
				|| commandTypeString.equalsIgnoreCase("del");
		return isRemove;
	}
	
	private static boolean isRecoverCommand(String commandTypeString){
		boolean isRecover = commandTypeString.equalsIgnoreCase("recover") || commandTypeString.equalsIgnoreCase("rec");
		return isRecover;
	}

	private static boolean isUndoCommand(String commandTypeString) {
		return commandTypeString.equalsIgnoreCase("undo");
	}

	private static boolean isRedoCommand(String commandTypeString) {
		return commandTypeString.equalsIgnoreCase("redo");
	}

	private static boolean isSearchCommand(String commandTypeString) {
		boolean isSearch = commandTypeString.equalsIgnoreCase("search")
				|| commandTypeString.equalsIgnoreCase("find");
		return isSearch;
	}

	private static boolean isTodayCommand(String commandTypeString) {
		return commandTypeString.equalsIgnoreCase("today");
	}

	private static boolean isShowAllCommand(String commandTypeString) {
		boolean isShowAll = commandTypeString.equalsIgnoreCase("all")
				|| commandTypeString.equalsIgnoreCase("show")
				|| commandTypeString.equalsIgnoreCase("display")
				|| commandTypeString.equalsIgnoreCase("list")
				|| commandTypeString.equalsIgnoreCase("ls");
		return isShowAll;
	}
	
	private static boolean isClearAllCommand(String commandTypeString) {
		boolean isClearAll = commandTypeString.equalsIgnoreCase("clear")
				|| commandTypeString.equalsIgnoreCase("clr");
		return isClearAll;
	}

	private static boolean isCompleteCommand(String commandTypeString) {
		return commandTypeString.equalsIgnoreCase("done")
				|| commandTypeString.equalsIgnoreCase("complete");
	}

	private static boolean isIncompleteCommand(String commandTypeString) {
		return commandTypeString.equalsIgnoreCase("undone")
				|| commandTypeString.equalsIgnoreCase("incomplete");
	}

	private static boolean isMarkCommand(String commandTypeString) {
		boolean isMark = commandTypeString.equalsIgnoreCase("mark") 
				||commandTypeString.equalsIgnoreCase("highlight") ;
		return isMark;
	}

	private static boolean isUnmarkCommand(String commandTypeString) {
		boolean isUnMark = commandTypeString.equalsIgnoreCase("unmark") 
				||commandTypeString.equalsIgnoreCase("unhighlight") ;
		return isUnMark;
	}

	private static boolean isSettingsCommand(String commandTypeString) {
		return commandTypeString.equalsIgnoreCase("settings");
	}

	private static boolean isHelpCommand(String commandTypeString) {
		return commandTypeString.equalsIgnoreCase("help");
	}

	private static boolean isSyncCommand(String commandTypeString) {
		return commandTypeString.equalsIgnoreCase("sync");
	}

	private static boolean isExitCommand(String commandTypeString) {
		return commandTypeString.equalsIgnoreCase("exit") || commandTypeString.equalsIgnoreCase("end");
	}
}

	// End of segment: D:\CS2103 Proj\src\Parser.java





	/**
	 * origin: D:\CS2103 Proj\src\Synchronization.java
	 */

public class Synchronization  {
	// Logger of this class
	private static Logger logger = Logger.getLogger("Sync");
	/* messages */
	private static final String CALENDAR_TITLE = "iDo";
	private static final String CALENDAR_SUMMARY = "This calendar synchronizes with iDo Task Manager.";
	private static final String SERVICE_NAME = "sg.edu.nus.cs2103aug2013-w13-03j";
	
	/* Default time for reminders*/
	private static final int REMINDER_MINUTES = 30;

	/* Username and password to login */
	String username = null;
	String password = null;
	boolean isValid = false;
	/* Model */
	Model model;
	History commandHistory;
	/* calendar service */
	CalendarService service;

	/* The base URL for a user's calendar metafeed (needs a username appended). */
	private static final String METAFEED_URL_BASE = "https://www.google.com/calendar/feeds/";

	/*The string to add to the user's metafeedUrl to access the owncalendars feed.*/
	private static final String OWNCALENDARS_FEED_URL_SUFFIX = "/owncalendars/full";

	/*The string to add to the user's eventfeedUrl to access the private feed.*/
	private static final String EVENT_FEED_URL_SUFFIX = "/private/full";
	
	/* Event feed URL */
	private URL eventFeedUrl = null;

	/* a list of event entry from Google calendar */
	private List<CalendarEventEntry> eventEntry = new ArrayList<CalendarEventEntry>();
	
	/**
	 * Constructor of this class
	 * 
	 * @param m
	 *            model of this application
	 */
	public Synchronization(Model m, History c) {
		model = m;
		commandHistory = c;
	}
	
	/*************** start of public methods ****************/
	/**
	 * Sets user account and password for login.
	 * @param n - username.
	 * @param p - password.
	 */
	public void setUsernameAndPassword(String n, String p) {
		username = n;
		password = p;
	}

	/**
	 * Starts the synchronization with Google Calendar.
	 * @return feedback
	 */
	public String execute() {
		try {
			eventFeedUrl = formEventFeedUrl(service);
		} catch (IOException | ServiceException e) {
			return Common.MESSAGE_SYNC_FAIL_TO_CREATE_CALENDAR;
		}
		
		// Sync new task to Google Calendar
		try {
			eventEntry = getEventsFromGCal(service, eventFeedUrl);
			syncNewTasksToGCal(service, model, eventFeedUrl);
		} catch (ServiceException | IOException e) {
			logger.log(Level.INFO, "Cannot get events from service");
		}

		// Update task due to changes for existiting tasks in both GCal and iDo
		try {
			updateModifiedTasks(service, model, eventEntry, eventFeedUrl);
		} catch (ServiceException|IOException e) {
			logger.log(Level.INFO, "Fail to update changes between GCal and iDo");
		}
		
		// Deelete events on GCal which have been deleted locally
		try {
			syncDeletedTasksToGCal(service, model, eventEntry, eventFeedUrl);
		} catch (ServiceException | IOException e) {
			return Common.MESSAGE_SYNC_SERVICE_STOPPED;
		}

		// Get all events from Google calendar
		try {
			eventEntry = getEventsFromGCal(service, eventFeedUrl);
		} catch (IOException | ServiceException e) {
			return Common.MESSAGE_SYNC_SERVICE_STOPPED;
		}

		// Delete tasks locally which have been deleted on GCal
		deleteTasksLocally(eventEntry, model);

		// Add tasks locally which have been added on GCal
		addEventsLocally(eventEntry, model); 
		
		commandHistory.clearUndoStack();
		commandHistory.clearRedoStack();
		return Common.MESSAGE_SYNC_SUCCESSFUL;
	}
	
	/**
	 * Initialize the service with the stored username and password
	 * 
	 * @throws AuthenticationException
	 *             this exception will be thrown if the Google account is
	 *             invalid
	 */
	public void initService() throws AuthenticationException {
		// Create a new service
		service = new CalendarService(SERVICE_NAME);
		// Authenticate using ClientLogin
		service.setUserCredentials(username, password);
	}
	
	/**
	 * This function is used to create the new calendar "iDo" if it does not
	 * exist in the corresponding Google account
	 * 
	 * @param service
	 *            the currently connected service
	 * @return the URL of the calendar
	 */
	private URL formEventFeedUrl(CalendarService service) throws ServiceException, IOException {
		URL owncalUrl = new URL(METAFEED_URL_BASE + username
				+ OWNCALENDARS_FEED_URL_SUFFIX);
		String calId = isCalendarExist(service, owncalUrl);
		if (calId == null) {
			CalendarEntry calendar = createCalendar(service, owncalUrl);
			calId = trimId(calendar.getId());
			logger.log(Level.INFO, "Successfully create a new calendar");
		}
		return new URL(METAFEED_URL_BASE + calId + EVENT_FEED_URL_SUFFIX);
	}
	
	/**
	 * This function is used to get the calendar id
	 * 
	 * @param id
	 *            the full content of the ID
	 * @return the cropped ID
	 */
	private String trimId(String id) {
		String[] temp = id.trim().split("/");
		return temp[temp.length - 1].toString();
	}
	
	/**
	 * This function is the main function to sync new local tasks to Google
	 * Calendar
	 * 
	 * @param service
	 *            the currently connected service
	 * @param model
	 *            model of tasks from the application
	 * @param feedUrl
	 *            the URL of the calendar
	 */
	private void syncNewTasksToGCal(CalendarService service, Model model, URL feedUrl)
			throws ServiceException, IOException {
		ObservableList<Task> pendingList = model.getPendingList();
		for (int i = 0; i < pendingList.size(); i++) {
			Task task = pendingList.get(i);
			if (task.getStatus() == Task.Status.NEWLY_ADDED) {
				CalendarEventEntry event = addEvent(service, feedUrl, task);
				task.setIndexId(event.getId());
				task.setStatus(Task.Status.UNCHANGED);
			}
		}
	}

	/**
	 * This function is used to add an event to the Google Calendar
	 * @param service the currently connected service
	 * @param feedUrl the URL of the calendar
	 * @param task the task which has to be added
	 * @return the added event entry on Google Calendar
	 */
	private CalendarEventEntry addEvent(CalendarService service, URL feedUrl,
			Task task) throws ServiceException, IOException {
		CalendarEventEntry event;
		if (task.isRecurringTask()) {
			event = createRecurringEvent(service, task.getWorkInfo(), task
					.getStartDate().returnInRecurringFormat(), task
					.getEndDate().returnInRecurringFormat(), task
					.getTag().getRepetition(), null,
					task.getNumOccurrences(), task.getTag()
							.getInterval(), task.isImportantTask(),
					feedUrl);
		} else {
			if (!task.isFloatingTask()) {// has start date and end date
				event = createSingleEvent(service, task.getWorkInfo(),
						task.getStartDate(), task.getEndDate(),
						task.isImportantTask(), feedUrl);
			} else{// no start date and no end date
				CustomDate startDate = new CustomDate();
				CustomDate endDate = new CustomDate();
				endDate.setTimeInMillis(startDate.getTimeInMillis() + CustomDate.DAY_IN_MILLIS);
				event = createRecurringEvent(service, task.getWorkInfo(),
						startDate.returnInRecurringFormat().substring(0, 8),
						endDate.returnInRecurringFormat().substring(0, 8),
						"daily", null, 0, task.getTag().getInterval(),
						task.isImportantTask(), feedUrl);
			}
		}
		return event;
	}
	
	// End of segment: D:\CS2103 Proj\src\Synchronization.java





	/**
	 * origin: D:\CS2103 Proj\src\Synchronization.java
	 */

	/**
	 * This function is used to set the number of occurences for a recurring
	 * data to be passed to the constructor of Recurrence object
	 * 
	 * @param occurrence
	 *            the number of occurrences
	 * @param recurData
	 *            the recurring data in String format
	 * @return the modified recurring data
	 */
	private String setOccurrenceForEntry(int occurrence,
			String recurData) {
		
		if (occurrence > 0) {
			recurData = recurData + ";COUNT=" + occurrence;
		}
		return recurData;
	}
	
	/**
	 * This function is used to set the interval for a recurring data to be
	 * passed to the constructor of Recurrence object
	 * 
	 * @param interval
	 *            the interval of the repetition
	 * @param recurData
	 *            the recurring data in String format
	 * @return the modified recurring data
	 */
	private String setIntervalForEntry(int interval,
			String recurData) {
		
		if (interval > 0) {
			recurData = recurData + ";INTERVAL=" + interval;
		}
		return recurData;
	}
	
	/**
	 * This function is used to set the frequency for a recurring datat to be
	 * passed to the constructor of Recurrence object
	 * 
	 * @param freq
	 *            the frequency of the repetition
	 * @param recurData
	 *            the recurring data in String format
	 * @return the modified recurring data
	 */
	private String setFrequencyForEntry(String freq, String recurData) {
		if (freq.contains("day") || freq.contains("daily")) {
			recurData = recurData + "RRULE:FREQ="
					+ "DAILY";
		} else if (freq.contains("week")) {
			recurData = recurData + "RRULE:FREQ="
					+ "WEEKLY";
		} else if (freq.contains("month")) {
			recurData = recurData + "RRULE:FREQ="
					+ "MONTHLY";
		} else if (freq.contains("year")) {
			recurData = recurData + "RRULE:FREQ="
					+ "YEARLY";
		}
		return recurData;
	}
	
	/**
	 * This function is used to convert a recurring event into a normal event on
	 * Google Calendar
	 * 
	 * @param service
	 *            the currently connected service
	 * @param entries
	 *            the list of entries on Google Calendar
	 * @param feedURL
	 *            the URL of the calendar
	 * @param pendingList
	 *            the list of pending tasks on iDo
	 * @param i
	 *            the index of the task
	 * @param j
	 *            the index of the entry
	 */
	private void convertFromRecurringToNormalEntry(CalendarService service,
			List<CalendarEventEntry> entries, URL feedURL,
			List<Task> pendingList, int i, int j) throws IOException,
			ServiceException {
		entries.get(j).delete();
		CalendarEventEntry replace = new CalendarEventEntry();
		replace.setTitle(new PlainTextConstruct(
				pendingList.get(i).getWorkInfo()));
		
		DateTime startTime = pendingList.get(i)
				.getStartDate()
				.returnInDateTimeFormat();
		DateTime endTime = pendingList.get(i)
				.getEndDate()
				.returnInDateTimeFormat();
		
		When eventTimes = new When();
		eventTimes.setStartTime(startTime);
		eventTimes.setEndTime(endTime);
		replace.addTime(eventTimes);
		
		CalendarEventEntry insertedEntry = service
				.insert(feedURL, replace);
		entries.set(j, insertedEntry);
		pendingList.get(i).setIndexId(
				insertedEntry.getId());
	}
	
	/**
	 * This function is used to check if the event entry is a normal entry
	 * 
	 * @param entries
	 *            list of entries on Google Calendar
	 * @param j
	 *            the index of the entry
	 * @return true if the event is indeed a normal event or vice versa
	 */
	private boolean isNormalEntry(List<CalendarEventEntry> entries, int j) {
		return entries.get(j).getRecurrence() == null;
	}
	
	/**
	 * This function is used to check if the task is a normal task
	 * 
	 * @param pendingList
	 *            the list of pending tasks in iDo
	 * @param i
	 *            the index of the task
	 * @return true if the task is indeed a normal task or vice versa
	 */
	private boolean isNormalTask(List<Task> pendingList, int i) {
		return !pendingList.get(i).isRecurringTask()
				&& pendingList.get(i).getStartDate() != null;
	}

	/**
	 * This function is used to sync all deleted tasks in iDo to Google Calendar
	 * so that these corresponding events on Google Calendar are also deleted
	 * 
	 * @param service
	 *            the currently connected service
	 * @param model
	 *            the model of tasks from the application
	 * @param entries
	 *            the list of entries in iDo
	 * @param feedUrl
	 *            the URL of the calendar
	 */
	private void syncDeletedTasksToGCal(CalendarService service, Model model,
			List<CalendarEventEntry> entries, URL feedUrl)
			throws ServiceException, IOException {
		List<CalendarEventEntry> tobeDelete = new ArrayList<CalendarEventEntry>();
		ObservableList<Task> completedTasks = model.getCompleteList();
		ObservableList<Task> deletedTasks = model.getTrashList();
		deleteTasksInOtherTabsOnGCal(entries, tobeDelete, completedTasks);
		deleteTasksInOtherTabsOnGCal(entries, tobeDelete, deletedTasks);
		deleteEvents(service, tobeDelete, feedUrl);
		
	}
	
	/**
	 * Delete list of tasks which are moved from pending tab to complete tab or
	 * trash tab
	 * 
	 * @param entries
	 *            the list of tasks in iDo
	 * @param tobeDelete
	 *            the list of event entries to be deleted on Google Calendar
	 * @param movedTasks
	 *            the list of tasks in complete tab or trash tab
	 */
	private void deleteTasksInOtherTabsOnGCal(List<CalendarEventEntry> entries,
			List<CalendarEventEntry> tobeDelete,
			ObservableList<Task> movedTasks) {
		for (int i = 0; i < movedTasks.size(); i++) {
			if (movedTasks.get(i).getStatus() == Task.Status.DELETED) {
				for (int j = 0; j < entries.size(); j++) {
					if (movedTasks.get(i).getIndexId()
							.equals(entries.get(j).getId())) {
						tobeDelete.add(entries.get(j));
						break;
					}
				}
				movedTasks.get(i).setStatus(Task.Status.UNCHANGED);
			}
		}
	}
	
	/**
	 * This function is used to sync all deleted events on Google Calendar back
	 * to iDo so that the corresponding tasks in iDo are also deleted.
	 * 
	 * @param entries
	 *            the list of entries on Google Calendar
	 * @param model
	 *            the model of tasks from the application
	 */
	private void deleteTasksLocally(List<CalendarEventEntry> entries,
			Model model) {
		List<Task> pendingList = model.getPendingList();
		ArrayList<String> entryIds = getGCalEntriesIdList(entries);
		for (int i = 0; i < pendingList.size(); i++) {
			if (!entryIds.contains(pendingList.get(i).getIndexId()) && pendingList.get(i).getStatus() != Task.Status.ADDED_WHEN_SYNC) {
				Task t = pendingList.remove(i);
				t.setStatus(Task.Status.UNCHANGED);
				model.getTrashList().add(t);
				i--;
			}
		}
	}
	
	/**
	 * This function is used to get the list of entries IDs from iDo
	 * 
	 * @param entries
	 *            the list of entries on Google Calendar
	 * @return the list of IDs
	 */
	private ArrayList<String> getGCalEntriesIdList(List<CalendarEventEntry> entries) {
		ArrayList<String> entryIds = new ArrayList<String>();
		for (int i = 0; i < entries.size(); i++) {
			entryIds.add(entries.get(i).getId());
		}
		return entryIds;
	}
	
	/**
	 * This function is used to sync newly added events on Google Calendar to
	 * the local application iDo
	 * 
	 * @param entries
	 *            the list of entries on Google Calendar
	 * @param model
	 *            the model of tasks from the application
	 */
	private void addEventsLocally(List<CalendarEventEntry> entries, Model model) {
		List<Task> pendingList = model.getPendingList();
		ArrayList<String> taskIds = getLocalEntriesIdList(pendingList);
		taskIds.addAll(model.getRemovedIdDuringSync());
		
		for (int i = 0; i < entries.size(); i++) {
			CalendarEventEntry e = entries.get(i);
			boolean isNewEntry = !taskIds.contains(e.getId());
			if (isNewEntry) {
				processAddingNewTask(entries, pendingList, i, e);
			}
		}
	}
	
	/**
	 * This function is used to add a new task to iDo
	 * 
	 * @param entries
	 *            the list of entries on Google Calendar
	 * @param pendingList
	 *            the list of pending tasks in iDo
	 * @param i
	 *            the index of the entry
	 * @param e
	 *            the actual entry
	 */
	private void processAddingNewTask(List<CalendarEventEntry> entries,
			List<Task> pendingList, int i, CalendarEventEntry e) {
		Task newTask = new Task();
		newTask.setWorkInfo(e.getTitle().getPlainText());
		try {
			setupDateForTimedTask(entries, i, newTask);
		} catch (IndexOutOfBoundsException | NullPointerException exception) { // which means it is a recurring event
			String recurData = e.getRecurrence().getValue();
			if (recurData.contains("VALUE=DATE:")) {// all day recurring event
				setupDateForAllDayRecurringTask(newTask, recurData);
			} else {// timed recurring event
				setupDateForTimedRecurringTask(newTask, recurData);
			}
		}
		newTask.setIndexId(e.getId());
		newTask.setStatus(Task.Status.UNCHANGED);
		if (!e.getReminder().isEmpty()){
			newTask.setIsImportant(true);
		}
		pendingList.add(newTask);
	}
	
	/**
	 * This function is used to set date for a timed task with the given event
	 * entry from Google Calendar
	 * 
	 * @param entries
	 *            the list of entries in Google Calendar
	 * @param i
	 *            the index of the entry
	 * @param newTask
	 *            the modified task
	 */
	private void setupDateForTimedTask(List<CalendarEventEntry> entries, int i,
			Task newTask) {
		DateTime start = entries.get(i).getTimes().get(0)
				.getStartTime();
		DateTime end = entries.get(i).getTimes().get(0)
				.getEndTime();
		CustomDate startDate = new CustomDate(start);
		CustomDate endDate = new CustomDate(end);
		newTask.setStartDate(startDate);
		newTask.setEndDate(endDate);
		newTask.setTag(new Tag(newTask.getTag().getTag(), "null"));
	}
	
	/**
	 * This function is used to set date for a recurring task with the given
	 * recurring event entry from Google Calendar
	 * 
	 * @param newTask
	 *            the modified task
	 * @param recurData
	 *            the recurring data
	 */
	private void setupDateForTimedRecurringTask(Task newTask, String recurData) {
		int startDateIndex = recurData.indexOf(":");
		CustomDate startDate = getDateForTimedRecurringTask(recurData,
				startDateIndex);
		int endDateIndex = recurData.indexOf(":",
				startDateIndex + 1);
		CustomDate endDate = getDateForTimedRecurringTask(recurData,
				endDateIndex);
		newTask.setStartDate(startDate);
		newTask.setEndDate(endDate);

		String freq = getFrequency(recurData);
		freq = checkInterval(recurData, freq);
		newTask.setTag(new Tag(newTask.getTag().getTag(), freq.toLowerCase()));

		checkOccurrencesForTimedRecurringTask(newTask, recurData, freq);
	}
	
	/**
	 * This function is used to update the number of occurrences for a timed
	 * recurring task
	 * 
	 * @param newTask
	 *            the modified task
	 * @param recurData
	 *            the recurring data
	 * @param freq
	 *            the frequency of repetition
	 */
	private void checkOccurrencesForTimedRecurringTask(Task newTask,
			String recurData, String freq) {
		newTask.setTag(new Tag(newTask.getTag().getTag(), freq.toLowerCase()));
		if (recurData.contains("COUNT=")) {
			int startIndex = recurData.indexOf("COUNT=") + 6;
			int endIndex = recurData.indexOf(";", startIndex);
			if (endIndex < 0) {
				endIndex = recurData.indexOf("\n", startIndex);
			}
			int count = Integer.parseInt(recurData.substring(startIndex, endIndex));
			newTask.setNumOccurrences(count);
		}
	}
	
	/**
	 * This function is used to extract the date from the recurring data in
	 * format for timed recurring task
	 * 
	 * @param recurData
	 *            the recurring data
	 * @param dateIndex
	 *            the start index of the date
	 * @return the converted date into CustomDate object
	 */
	private CustomDate getDateForTimedRecurringTask(String recurData,
			int dateIndex) {
		String startDateString = recurData.substring(
				dateIndex + 1, dateIndex + 16);
		CustomDate date = new CustomDate(
				startDateString.substring(6, 8) + "/"
						+ startDateString.substring(4, 6) + "/"
						+ startDateString.substring(0, 4) + " "
						+ startDateString.substring(9, 11)
						+ ":"
						+ startDateString.substring(11, 13));
		return date;
	}
	
	/**
	 * This function is used to update the dates for an all day recurring task
	 * with the given all day recurring event entry from the google Calendar
	 * 
	 * @param recurData
	 *            the recurring data
	 * @param task
	 *            the modified task
	 */
	private void setupDateForAllDayRecurringTask(Task task, String recurData) {
		int startDateIndex = recurData.indexOf(":");
		CustomDate startDate = getDateForAllDayRecurringEvent(recurData, startDateIndex);
		int endDateIndex = recurData.indexOf(":", startDateIndex + 1);
		CustomDate endDate = getDateForAllDayRecurringEvent(recurData, endDateIndex);
		task.setStartDate(startDate);
		task.setEndDate(endDate);

		setupRecurrenceInfoForAllDayRecurringTask(task, recurData);
	}

	/**
	 * This function is used to setup the repetition info for a task from the
	 * given recurring data
	 * 
	 * @param task
	 *            the modified task
	 * @param recurData
	 *            the recurring data
	 */
	private void setupRecurrenceInfoForAllDayRecurringTask(Task task,
			String recurData) {
		String freq = getFrequency(recurData);
		freq = checkInterval(recurData, freq);
		task.setTag(new Tag(task.getTag().getTag(), freq.toLowerCase()));
		checkOccurrencesForAllDayRecurringTask(task, recurData, freq);
	}
	
	/**
	 * This function is used to update the number of occurrences of an all day
	 * recurring task
	 * 
	 * @param task
	 *            the modified task
	 * @param recurData
	 *            the recurring data
	 * @param freq
	 *            the frequency of repetition
	 */
	private void checkOccurrencesForAllDayRecurringTask(Task task, String recurData, String freq) {
		if (recurData.contains("COUNT=")) {
			int startIndex = recurData.indexOf("COUNT=") + 6;
			int endIndex = recurData.indexOf(";", startIndex);
			if (endIndex < 0) {
				endIndex = recurData.indexOf("\n", startIndex);
			}
			int count = Integer.parseInt(recurData.substring(
					startIndex, endIndex));
			task.setNumOccurrences(count);
		} else if (freq.equals("DAILY")) {
			setFloatingTask(task);
		}
	}
	
	/**
	 * This function is used to set a task to be a floating task
	 * @param task
	 */
	private void setFloatingTask(Task task) {
		task.setStartDate(null);
		task.setEndDate(null);
		task.setTag(new Tag(task.getTag().getTag(), "null"));
	}
	
	/**
	 * This function is used to process the interval and update it to the
	 * frequency from the given recurring data
	 * 
	 * @param recurData
	 *            the recurring data
	 * @param freq
	 *            the frequency of repetition
	 * @return the updated frequency
	 */
	private String checkInterval(String recurData, String freq) {
		if (recurData.contains("INTERVAL=")) {
			int startIndex = recurData.indexOf("INTERVAL=") + 9;
			int endIndex = recurData.indexOf(";", startIndex);
			if (endIndex < 0) {
				endIndex = recurData.indexOf("\n", startIndex);
			}
			
			int interval = Integer.parseInt(recurData
					.substring(startIndex, endIndex));
			String suffix = "";
			if (freq.equalsIgnoreCase("daily")) {
				suffix = "days";
			} else if (freq.equalsIgnoreCase("weekly")) {
				suffix = "weeks";
			} else if (freq.equalsIgnoreCase("monthly")) {
				suffix = "months";
			} else {
				suffix = "years";
			}
			freq = "every" + interval + suffix;
		}
		return freq;
	}	
	
	/**
	 * This function is used to get the basic frequency from the recurring data
	 * (does not consider the interval)
	 * 
	 * @param recurData
	 *            the recurring data
	 * @return the basic corresponding frequency
	 */
	private String getFrequency(String recurData) {
		int freqStartIndex = recurData.indexOf("FREQ=");
		int freqEndIndex = getFrequencyEndIndex(recurData, freqStartIndex);
		String freq = recurData.substring(freqStartIndex + 5, freqEndIndex);
		return freq;
	}
	
	// Get the last index of the frequency in the recurring data with the given start index
	private int getFrequencyEndIndex(String recurData, int freqStartIndex) {
		int freqEndIndex;
		if (recurData.contains("BYDAY")
				|| recurData.contains("BYMONTHDAY")
				|| recurData.contains("COUNT")
				|| recurData.contains("INTERVAL")) {
			freqEndIndex = recurData.indexOf(";",
					freqStartIndex);
		} else {
			freqEndIndex = recurData.indexOf("\n", freqStartIndex);
			if (freqEndIndex == -1){
				freqEndIndex = recurData.length();
			}
		}
		return freqEndIndex;
	}
	
	/**
	 * Get date from the recurrence data by indicating the start index of date
	 * @param recurData
	 * @param dateIndex
	 * @return
	 */
	private CustomDate getDateForAllDayRecurringEvent(String recurData,
			int dateIndex) {
		String endDateString = recurData.substring(dateIndex + 1, dateIndex + 9);
		CustomDate date = new CustomDate(endDateString.substring(6, 8) + "/"
						+ endDateString.substring(4, 6) + "/" + endDateString.substring(0, 4));
		return date;
	}

	
	/**
	 * Get all entries ID of events in the local application iDo
	 * 
	 * @param pendingList
	 *            the list to tasks to retrieve IDs
	 * @return the list of entries IDs
	 */
	private ArrayList<String> getLocalEntriesIdList(List<Task> pendingList) {
		ArrayList<String> taskIds = new ArrayList<String>();
		for (int i = 0; i < pendingList.size(); i++) {
			taskIds.add(pendingList.get(i).getIndexId());
		}
		return taskIds;
	}
	
	/**
	 * Retrieve all event entries from calendar "iDo" on Google Calendar
	 *
	 */
	private List<CalendarEventEntry> getEventsFromGCal(CalendarService service,
			URL feedUrl) throws IOException, ServiceException {
		// Send the request and receive the response:
		CalendarEventFeed eventFeed = service.getFeed(feedUrl,
				CalendarEventFeed.class);

		List<CalendarEventEntry> entry = eventFeed.getEntries();
		return entry;
	}

	/**
	 * Creates a new secondary calendar using the owncalendars feed.
	 * 
	 * @param service
	 *            An authenticated CalendarService object.
	 * @return The newly created calendar entry.
	 * @throws IOException
	 *             If there is a problem communicating with the server.
	 * @throws ServiceException
	 *             If the service is unable to handle the request.
	 */
	CalendarEntry createCalendar(CalendarService service,
			URL owncalendarsFeedUrl) throws IOException, ServiceException {

		Calendar cal = new GregorianCalendar();
		String timeZone = cal.getTimeZone().getID();
		
		// Create the calendar
		CalendarEntry calendar = new CalendarEntry();
		calendar.setTitle(new PlainTextConstruct(CALENDAR_TITLE));
		calendar.setSummary(new PlainTextConstruct(CALENDAR_SUMMARY));
		calendar.setHidden(HiddenProperty.FALSE);
		calendar.setTimeZone(new TimeZoneProperty(timeZone));

		// Insert the calendar
		return service.insert(owncalendarsFeedUrl, calendar);
	}

	/**
	 * Helper method to create either single-instance or recurring events. For
	 * simplicity, some values that might normally be passed as parameters (such
	 * as author name, email, etc.) are hard-coded.
	 * 
	 * @param service
	 *            An authenticated CalendarService object.
	 * @param eventTitle
	 *            Title of the event to create.
	 * @param eventContent
	 *            Text content of the event to create.
	 * @param recurData
	 *            Recurrence value for the event, or null for single-instance
	 *            events.
	 * @param isQuickAdd
	 *            True if eventContent should be interpreted as the text of a
	 *            quick add event.
	 * @param wc
	 *            A WebContent object, or null if this is not a web content
	 *            event.
	 * @return The newly-created CalendarEventEntry.
	 * @throws ServiceException
	 *             If the service is unable to handle the request.
	 * @throws IOException
	 *             Error communicating with the server.
	 */
	CalendarEventEntry createEvent(CalendarService service, String title,
			CustomDate startDate, CustomDate endDate, String recurData,
			boolean isImportant, boolean isQuickAdd, URL feedUrl)
			throws ServiceException, IOException {
		CalendarEventEntry myEntry = new CalendarEventEntry();

		myEntry.setTitle(new PlainTextConstruct(title));
		myEntry.setQuickAdd(isQuickAdd);

		if (recurData == null) {
			setTimeForNormalEvent(startDate, endDate, myEntry);
		} else {
			setTimeForRecurringEvent(recurData, myEntry);
		}

		if (isImportant) {
			setReminder(myEntry);
		}

		// Send the request and receive the response:
		return service.insert(feedUrl, myEntry);
	}
	
	/**
	 * This function is used to set the recurrence data for an event entry
	 * 
	 * @param recurData
	 *            the recurring data
	 * @param myEntry
	 *            the modified event entry on Google Calendar
	 */
	private void setTimeForRecurringEvent(String recurData,
			CalendarEventEntry myEntry) {
		Recurrence recur = new Recurrence();
		recur.setValue(recurData);
		myEntry.setRecurrence(recur);
	}
	
	/**
	 * Set time for normal event
	 * 
	 * @param startDate
	 *            the start date of new task
	 * @param endDate
	 *            the end date of new task
	 * @param myEntry
	 *            the added entry on Google Calendar
	 */
	private void setTimeForNormalEvent(CustomDate startDate,
			CustomDate endDate, CalendarEventEntry myEntry) {
		DateTime startTime = startDate.returnInDateTimeFormat();
		DateTime endTime = endDate.returnInDateTimeFormat();
		
		When eventTimes = new When();
		eventTimes.setStartTime(startTime);
		eventTimes.setEndTime(endTime);
		myEntry.addTime(eventTimes);
	}

	/**
	 * Creates a single-occurrence event.
	 * 
	 * @param service
	 *            An authenticated CalendarService object.
	 * @param eventTitle
	 *            Title of the event to create.
	 * @param eventContent
	 *            Text content of the event to create.
	 * @return The newly-created CalendarEventEntry.
	 * @throws ServiceException
	 *             If the service is unable to handle the request.
	 * @throws IOException
	 *             Error communicating with the server.
	 */
	CalendarEventEntry createSingleEvent(CalendarService service,
			String eventContent, CustomDate startDate, CustomDate endDate,
			boolean isImport, URL feedUrl) throws ServiceException, IOException {
		return createEvent(service, eventContent, startDate, endDate, null, isImport, false, feedUrl);
	}

	/**
	 * Creates a new recurring event.
	 * 
	 * @param service
	 *            An authenticated CalendarService object.
	 * @param eventTitle
	 *            Title of the event to create.
	 * @param eventContent
	 *            Text content of the event to create.
	 * @return The newly-created CalendarEventEntry.
	 * @throws ServiceException
	 *             If the service is unable to handle the request.
	 * @throws IOException
	 *             Error communicating with the server.
	 */
	private CalendarEventEntry createRecurringEvent(CalendarService service,
			String eventContent, String startDate, String endDate, String freq,
			String until, int count, int interval, boolean isImport, URL feedUrl)
			throws ServiceException, IOException {

		String recurData = setRecurrenceData(startDate, endDate, freq, until, count, interval);

		return createEvent(service, eventContent, null, null, recurData, isImport, false, feedUrl);
	}
	
	/**
	 * This function is used to set the recurrence data suitable to pass to the
	 * constructor of Recurrence object
	 * 
	 * @param startDate
	 *            the start date in String format
	 * @param endDate
	 *            the end date in String format
	 * @param freq
	 *            the frequency in String format
	 * @param until
	 *            the until limit in String format
	 * @param count
	 *            the number of occurrences in String format
	 * @param interval
	 *            the interval between period
	 * @return the recurrence info
	 */
	private String setRecurrenceData(String startDate, String endDate,
			String freq, String until, int count, int interval) {
		String recurData = "DTSTART;TZID=" + TimeZone.getDefault().getID()
				+ ":" + startDate + "\r\n" + "DTEND;TZID="
				+ TimeZone.getDefault().getID() + ":" + endDate + "\r\n";
		
		recurData = setFrequencyForEntry(freq, recurData);
		recurData = setIntervalForEntry(interval, recurData);
		recurData = setOccurrenceForEntry(count, recurData);
		recurData += "\r\n";
		return recurData;
	}

	/**
	 * Makes a batch request to delete all the events in the given list. If any
	 * of the operations fails, the errors returned from the server are
	 * displayed. The CalendarEntry objects in the list given as a parameters
	 * must be entries returned from the server that contain valid edit links
	 * (for optimistic concurrency to work). Note: You can add entries to a
	 * batch request for the other operation types (INSERT, QUERY, and UPDATE)
	 * in the same manner as shown below for DELETE operations.
	 * 
	 * @param service
	 *            An authenticated CalendarService object.
	 * @param eventsToDelete
	 *            A list of CalendarEventEntry objects to delete.
	 * @throws ServiceException
	 *             If the service is unable to handle the request.
	 * @throws IOException
	 *             Error communicating with the server.
	 */
	private static void deleteEvents(CalendarService service,
			List<CalendarEventEntry> eventsToDelete, URL feedUrl)
			throws ServiceException, IOException {
		// Add each item in eventsToDelete to the batch request.
		CalendarEventFeed batchRequest = new CalendarEventFeed();
		
		for (int i = 0; i < eventsToDelete.size(); i++) {
			CalendarEventEntry toDelete = eventsToDelete.get(i);
			// Modify the entry toDelete with batch ID and operation type.
			BatchUtils.setBatchId(toDelete, String.valueOf(i));
			BatchUtils.setBatchOperationType(toDelete,
					BatchOperationType.DELETE);
			batchRequest.getEntries().add(toDelete);
		}

		// Get the URL to make batch requests to
		CalendarEventFeed feed = service.getFeed(feedUrl,
				CalendarEventFeed.class);
		Link batchLink = feed.getLink(Link.Rel.FEED_BATCH, Link.Type.ATOM);
		URL batchUrl = new URL(batchLink.getHref());

		service.batch(batchUrl, batchRequest);
	}

	/**
	 * Makes a batch request to update all the events in the given list. If any
	 * of the operations fails, the errors returned from the server are
	 * displayed. The CalendarEntry objects in the list given as a parameters
	 * must be entries returned from the server that contain valid edit links
	 * (for optimistic concurrency to work). Note: You can add entries to a
	 * batch request for the other operation types (INSERT, QUERY, and UPDATE)
	 * in the same manner as shown below for DELETE operations.
	 * 
	 * @param service
	 *            An authenticated CalendarService object.
	 * @param eventsToDelete
	 *            A list of CalendarEventEntry objects to update.
	 * @throws ServiceException
	 *             If the service is unable to handle the request.
	 * @throws IOException
	 *             Error communicating with the server.
	 */
	private void updateEvents(CalendarService service,
			List<CalendarEventEntry> eventsToUpdate, URL feedUrl)
			throws ServiceException, IOException {
		// Add each item in eventsToUpdate to the batch request.
		CalendarEventFeed batchRequest = new CalendarEventFeed();
		
		for (int i = 0; i < eventsToUpdate.size(); i++) {
			CalendarEventEntry toUpdate = eventsToUpdate.get(i);
			// Modify the entry toUpdate with batch ID and operation type.
			BatchUtils.setBatchId(toUpdate, String.valueOf(i));
			BatchUtils.setBatchOperationType(toUpdate,
					BatchOperationType.UPDATE);
			batchRequest.getEntries().add(toUpdate);
		}

		// Get the URL to make batch requests to
		CalendarEventFeed feed = service.getFeed(feedUrl,
				CalendarEventFeed.class);
		Link batchLink = feed.getLink(Link.Rel.FEED_BATCH, Link.Type.ATOM);
		URL batchUrl = new URL(batchLink.getHref());

		service.batch(batchUrl, batchRequest);
	}
	
	/**
	 * This function is used to set reminder for an event in the calendar
	 * 
	 * @param event
	 *            the modified event
	 */
	private void setReminder(CalendarEventEntry event) {
		Reminder r = new Reminder();
		Method m = Method.ALERT;

		r.setMinutes(REMINDER_MINUTES);
		r.setMethod(m);
		event.getReminder().add(r);
	}
	
	/**
	 * This function is used to check whether the connected service has already
	 * had the calendar "iDo" yet If yes, it will return the calendar ID. Else,
	 * return null
	 * 
	 * @param service
	 *            the currently connected service
	 * @param feedUrl
	 *            the URL of Google Calendar
	 * @return the calendar ID if exists
	 */
	private String isCalendarExist(CalendarService service, URL feedUrl) {
		String calendarId = null;
		CalendarFeed resultFeed = null;
		List<CalendarEntry> entries = null;
		
		try {
			resultFeed = service.getFeed(feedUrl, CalendarFeed.class);
			entries = resultFeed.getEntries();
		} catch (IOException e) {
			logger.log(Level.INFO, "Error in IO when checking calendar");
		} catch (ServiceException e) {
			logger.log(Level.INFO, "Error in connecting to service when checking calendar");
		}
		
		if (entries != null) {
			for (int i = 0; i < entries.size(); i++) {
				if (entries.get(i).getTitle().getPlainText().equals(CALENDAR_TITLE)) {
					calendarId = trimId(entries.get(i).getId());
					break;
				}
			}
		}
		return calendarId;
	}
}

	// End of segment: D:\CS2103 Proj\src\Synchronization.java





	/**
	 * origin: D:\CS2103 Proj\src\TestSynchronization.java
	 */

public class TestSynchronization {

	@Test
	public void test() {
		//history object
		History history = new History();
		//model object
		Model model = new Model();
	
		Synchronization sync = new Synchronization(model, history);
		
		//set a valid username and password
		sync.setUsernameAndPassword("jimcs2103iDo@gmail.com", "cs2103cs2101");
		try {
			sync.initService();
		} catch (AuthenticationException e) {
			assert(false);
		}
		
		//test case for empty tasks
		assertEquals(Common.MESSAGE_SYNC_SUCCESSFUL, sync.execute());
		
		//test case for timed tasks
		Task task = new Task();
		task.setWorkInfo("timed task");
		task.setStartDate(new CustomDate("6pm"));
		task.setEndDate(new CustomDate("7pm"));
		model.addTaskToPending(task);
		
		assertEquals(Common.MESSAGE_SYNC_SUCCESSFUL, sync.execute());
		
		//test case for floating tasks
		Task task1 = new Task();
		task1.setWorkInfo("floating task");
		model.getPendingList().clear();
		model.addTaskToPending(task1);
		
		assertEquals(Common.MESSAGE_SYNC_SUCCESSFUL, sync.execute());
		
		//test case for recurring tasks
		Task task2 = new Task();
		task2.setWorkInfo("timed task");
		task2.setStartDate(new CustomDate("4pm"));
		task2.setEndDate(new CustomDate("6pm"));
		task2.setTag(new Tag(Common.HYPHEN, "weekly"));
		model.getPendingList().clear();
		model.addTaskToPending(task2);
		
		assertEquals(Common.MESSAGE_SYNC_SUCCESSFUL, sync.execute());
	}

}

	// End of segment: D:\CS2103 Proj\src\TestSynchronization.java





